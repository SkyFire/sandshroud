Index: AIInterface.cpp
===================================================================
--- AIInterface.cpp	(revision 1419)
+++ AIInterface.cpp	(working copy)
@@ -479,6 +479,9 @@
 			}
 
 			CALL_SCRIPT_EVENT(m_Unit, OnDied)(pUnit);
+			if ( m_Unit->IsCreature() )
+				CALL_INSTANCE_SCRIPT_EVENT( m_Unit->GetMapMgr(), OnCreatureDeath )( TO_CREATURE( m_Unit ), pUnit );
+
 			m_AIState = STATE_IDLE;
 
 			StopMovement(0);
Index: AreaTrigger.cpp
===================================================================
--- AreaTrigger.cpp	(revision 1419)
+++ AreaTrigger.cpp	(working copy)
@@ -130,6 +130,7 @@
 	AreaTrigger* pAreaTrigger = AreaTriggerStorage.LookupEntry( id );
 
 	sHookInterface.OnAreaTrigger(_player, id);
+	CALL_INSTANCE_SCRIPT_EVENT( _player->GetMapMgr(), OnAreaTrigger )( _player, id );
 
 	// if in BG handle is triggers
 	if( _player->m_bg )
Index: Creature.cpp
===================================================================
--- Creature.cpp	(revision 1419)
+++ Creature.cpp	(working copy)
@@ -1276,6 +1276,8 @@
 		}
 
 	}
+
+	CALL_INSTANCE_SCRIPT_EVENT( m_mapMgr, OnCreaturePushToWorld )( creature_shared_from_this() );
 }
 
 // this is used for guardians. They are non respawnable creatures linked to a player
Index: GameObject.cpp
===================================================================
--- GameObject.cpp	(revision 1419)
+++ GameObject.cpp	(working copy)
@@ -689,6 +689,7 @@
 void GameObject::OnPushToWorld()
 {
 	Object::OnPushToWorld();
+	CALL_INSTANCE_SCRIPT_EVENT( m_mapMgr, OnGameObjectPushToWorld )( gob_shared_from_this() );
 }
 
 void GameObject::OnRemoveInRangeObject(ObjectPointer pObj)
Index: MapMgr.cpp
===================================================================
--- MapMgr.cpp	(revision 1419)
+++ MapMgr.cpp	(working copy)
@@ -95,6 +95,8 @@
 		SetCollision(true);
 	else
 		SetCollision(false);
+
+	mInstanceScript = NULL;
 }
 
 void MapMgr::Init()
@@ -114,6 +116,8 @@
 	sEventMgr.RemoveEvents(shared_from_this());
 	delete ScriptInterface;
 	delete m_stateManager;
+	if ( mInstanceScript != NULL )
+		mInstanceScript->Destroy();
 
 	// Remove objects
 	if(_cells)
@@ -1466,6 +1470,9 @@
 	ObjectSet::iterator i;
 	uint32 last_exec=getMSTime();
 
+	// Create Instance script
+	LoadInstanceScript();
+
 	/* create static objects */
 	for(GOSpawnList::iterator itr = _map->staticSpawns.GOSpawns.begin(); itr != _map->staticSpawns.GOSpawns.end(); ++itr)
 	{
@@ -1493,6 +1500,9 @@
 	// initialize worldstates
 	sWorldStateTemplateManager.ApplyMapTemplate(shared_from_this());
 
+	// Call script OnLoad virtual procedure
+	CALL_INSTANCE_SCRIPT_EVENT( shared_from_this(), OnLoad )();
+
 	if( GetMapInfo()->type == INSTANCE_NULL )
 		sHookInterface.OnContinentCreate(shared_from_this());
 
@@ -2214,3 +2224,14 @@
 	}
 	PlayerStorageMaplock.Release();
 }
+
+void MapMgr::LoadInstanceScript()
+{
+	mInstanceScript = sScriptMgr.CreateScriptClassForInstance( _mapId, shared_from_this() );
+};
+
+void MapMgr::CallScriptUpdate()
+{
+	ASSERT( mInstanceScript );
+	mInstanceScript->UpdateEvent();
+};
Index: MapMgr.h
===================================================================
--- MapMgr.h	(revision 1419)
+++ MapMgr.h	(working copy)
@@ -38,6 +38,7 @@
 class Corpse;
 class CBattleground;
 class Instance;
+class InstanceScript;
 
 
 enum MapMgrTimers
@@ -75,6 +76,8 @@
 class Transporter;
 #define RESERVE_EXPAND_SIZE 1024
 
+#define CALL_INSTANCE_SCRIPT_EVENT( Mgr, Func ) if ( Mgr != NULL && Mgr->GetScript() != NULL ) Mgr->GetScript()->Func
+
 class SERVER_DECL MapMgr : public CellHandler <MapCell>, public EventableObject,public ThreadContext, public std::tr1::enable_shared_from_this<MapMgr>
 {
 	friend class UpdateObjectThread;
@@ -399,6 +402,15 @@
 	
 	SessionSet::iterator __session_iterator_1;
 	SessionSet::iterator __session_iterator_2;
+
+	// Script related
+	InstanceScript* GetScript() { return mInstanceScript; };
+	void LoadInstanceScript();
+	void CallScriptUpdate();
+
+protected:
+
+	InstanceScript* mInstanceScript;
 };
 
 #endif
Index: MapScriptInterface.cpp
===================================================================
--- MapScriptInterface.cpp	(revision 1419)
+++ MapScriptInterface.cpp	(working copy)
@@ -17,11 +17,6 @@
  *
  */
 
-/* * Class InstanceScript
-   * Instanced class created for each instance of the map, holds all 
-   * scriptable exports
-*/
-
 /* * Class MapScriptInterface
    * Provides an interface to mapmgr for scripts, to obtain objects,
    * get players, etc.
Index: MapScriptInterface.h
===================================================================
--- MapScriptInterface.h	(revision 1419)
+++ MapScriptInterface.h	(working copy)
@@ -20,11 +20,6 @@
 #ifndef _MAP_SCRIPT_INTERFACE_H
 #define _MAP_SCRIPT_INTERFACE_H
 
-/* * Class InstanceScript
-   * Instanced class created for each instance of the map, holds all 
-   * scriptable exports
-*/
-
 /* * Class MapScriptInterface
    * Provides an interface to mapmgr for scripts, to obtain objects,
    * get players, etc.
@@ -104,24 +99,5 @@
 
 #define sStructFactory StructFactory::getSingleton()
 
-class SERVER_DECL InstanceScript
-{
-public:
-	InstanceScript(MapMgrPointer instance);
-	virtual ~InstanceScript() {}
-
-	virtual GameObjectPointer GetObjectForOpenLock(PlayerPointer pCaster, SpellPointer pSpell, SpellEntry* pProto) { return NULLGOB; }
-
-	virtual void SetLockOptions(uint32 uEntryId, GameObjectPointer pGameObject) { }
-	virtual uint32 GetRespawnTimeForCreature(uint32 uEntryId, CreaturePointer pCreature) { return 240000; }
-
-	virtual void Destroy() {}
-	virtual void UpdateEvent() {}
-
-protected:
-	MapMgrPointer _instance;
-
-};
-
 #endif
 
Index: MiscHandler.cpp
===================================================================
--- MiscHandler.cpp	(revision 1419)
+++ MiscHandler.cpp	(working copy)
@@ -1148,6 +1148,7 @@
 	PlayerPointer plyr = GetPlayer();
    
 	CALL_GO_SCRIPT_EVENT(obj, OnActivate)(_player);
+	CALL_INSTANCE_SCRIPT_EVENT( _player->GetMapMgr(), OnGameObjectActivate )( obj, _player );
 
 	uint32 type = obj->GetByte(GAMEOBJECT_BYTES_1, GAMEOBJECT_BYTES_TYPE_ID);
 	switch (type)
Index: Object.cpp
===================================================================
--- Object.cpp	(revision 1419)
+++ Object.cpp	(working copy)
@@ -1827,6 +1827,7 @@
 			pVictim->EventDeathAuraRemoval();
 			/* Set victim health to 0 */
 			pVictim->SetUInt32Value(UNIT_FIELD_HEALTH, 0);
+			CALL_INSTANCE_SCRIPT_EVENT( m_mapMgr, OnPlayerDeath )( TO_PLAYER( pVictim ), pKiller );
 
 			if( IsCreature() )
 			{
Index: Player.cpp
===================================================================
--- Player.cpp	(revision 1419)
+++ Player.cpp	(working copy)
@@ -3611,6 +3611,8 @@
 	// execute some of zeh hooks
 	sHookInterface.OnEnterWorld(plr_shared_from_this());
 	sHookInterface.OnZone(plr_shared_from_this(), m_zoneId, 0);
+	CALL_INSTANCE_SCRIPT_EVENT( m_mapMgr, OnZoneChange )( plr_shared_from_this(), m_zoneId, 0 );
+	CALL_INSTANCE_SCRIPT_EVENT( m_mapMgr, OnPlayerEnter )( plr_shared_from_this() );
 
 	if(m_TeleportState == 1)		// First world enter
 		CompleteLoading();
@@ -7870,6 +7872,7 @@
 
 	m_playerInfo->lastZone = ZoneId;
 	sHookInterface.OnZone(plr_shared_from_this(), ZoneId, oldzone);
+	CALL_INSTANCE_SCRIPT_EVENT( m_mapMgr, OnZoneChange )( plr_shared_from_this(), ZoneId, oldzone );
 
 
 	AreaTable *at = dbcArea.LookupEntry(GetAreaID());
Index: ScriptMgr.cpp
===================================================================
--- ScriptMgr.cpp	(revision 1419)
+++ ScriptMgr.cpp	(working copy)
@@ -368,6 +368,11 @@
 	_questscripts.insert( qs );
 }
 
+void ScriptMgr::register_instance_script( uint32 pMapId, exp_create_instance_ai pCallback )
+{
+	mInstances.insert( InstanceCreateMap::value_type( pMapId, pCallback ) );
+};
+
 CreatureAIScript* ScriptMgr::CreateAIScriptClassForEntry(CreaturePointer pCreature)
 {
 	CreatureCreateMap::iterator itr = _creatures.find(pCreature->GetEntry());
@@ -388,6 +393,16 @@
 	return (function_ptr)(pGameObject);
 }
 
+InstanceScript* ScriptMgr::CreateScriptClassForInstance( uint32 pMapId, MapMgrPointer pMapMgr )
+{
+	InstanceCreateMap::iterator Iter = mInstances.find( pMapMgr->GetMapId() );
+	if ( Iter == mInstances.end() )
+		return NULL;
+
+	exp_create_instance_ai function_ptr = Iter->second;
+	return ( function_ptr )( pMapMgr );
+};
+
 bool ScriptMgr::CallScriptedDummySpell(uint32 uSpellId, uint32 i, SpellPointer pSpell)
 {
 	HandleDummySpellMap::iterator itr = _spells.find(uSpellId);
@@ -466,13 +481,6 @@
 	sEventMgr.AddEvent(_gameobject, &GameObject::CallScriptUpdate, EVENT_SCRIPT_UPDATE_EVENT, frequency, 0,EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
 }
 
-
-/* InstanceAI Stuff */
-
-InstanceScript::InstanceScript(MapMgrPointer instance) : _instance(instance)
-{
-}
-
 /* QuestScript Stuff */
 
 /* Gossip Stuff*/
@@ -721,6 +729,30 @@
 	delete this;
 }
 
+/* InstanceAI Stuff */
+
+InstanceScript::InstanceScript( MapMgrPointer pMapMgr ) : mInstance( pMapMgr )
+{
+};
+
+void InstanceScript::RegisterUpdateEvent( uint32 pFrequency )
+{
+	sEventMgr.AddEvent( mInstance, &MapMgr::CallScriptUpdate, EVENT_SCRIPT_UPDATE_EVENT, pFrequency, 0, EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT );
+};
+
+void InstanceScript::ModifyUpdateEvent( uint32 pNewFrequency )
+{
+	sEventMgr.ModifyEventTimeAndTimeLeft( mInstance, EVENT_SCRIPT_UPDATE_EVENT, pNewFrequency );
+};
+
+void InstanceScript::RemoveUpdateEvent()
+{
+	sEventMgr.RemoveEvents( mInstance, EVENT_SCRIPT_UPDATE_EVENT );
+};
+
+/* Hook Stuff */
+
+
 void ScriptMgr::register_hook(ServerHookEvents event, void * function_pointer)
 {
 	ASSERT(event < NUM_SERVER_HOOKS);
Index: ScriptMgr.h
===================================================================
--- ScriptMgr.h	(revision 1419)
+++ ScriptMgr.h	(working copy)
@@ -22,6 +22,7 @@
 
 #define SCRIPT_MODULE void*
 #define ADD_CREATURE_FACTORY_FUNCTION(cl) static CreatureAIScript * Create(CreaturePointer c) { return new cl(c); }
+#define ADD_INSTANCE_FACTORY_FUNCTION( ClassName ) static InstanceScript* Create( MapMgrPointer pMapMgr ) { return new ClassName( pMapMgr ); };
 
 class Channel;
 class Guild;
@@ -106,6 +107,7 @@
 class CreatureAIScript;
 class GossipScript;
 class GameObjectAIScript;
+class InstanceScript;
 class ScriptMgr;
 struct ItemPrototype;
 class QuestLogEntry;
@@ -113,6 +115,7 @@
 /* Factory Imports (from script lib) */
 typedef CreatureAIScript*(*exp_create_creature_ai)(CreaturePointer pCreature);
 typedef GameObjectAIScript*(*exp_create_gameobject_ai)(GameObjectPointer pGameObject);
+typedef InstanceScript* ( *exp_create_instance_ai )( MapMgrPointer pMapMgr );
 typedef bool(*exp_handle_dummy_spell)(uint32 i, SpellPointer pSpell);
 typedef bool(*exp_handle_dummy_aura)(uint32 i, AuraPointer pAura, bool apply);
 typedef void(*exp_script_register)(ScriptMgr * mgr);
@@ -125,6 +128,7 @@
 typedef HM_NAMESPACE::hash_map<uint32, exp_create_gameobject_ai> GameObjectCreateMap;
 typedef HM_NAMESPACE::hash_map<uint32, exp_handle_dummy_aura> HandleDummyAuraMap;
 typedef HM_NAMESPACE::hash_map<uint32, exp_handle_dummy_spell> HandleDummySpellMap;
+typedef HM_NAMESPACE::hash_map< uint32, exp_create_instance_ai > InstanceCreateMap;
 typedef set<GossipScript*> CustomGossipScripts;
 typedef set<QuestScript*> QuestScripts;
 typedef list<void*> ServerHookList;
@@ -144,6 +148,7 @@
 
 	CreatureAIScript * CreateAIScriptClassForEntry(CreaturePointer pCreature);
 	GameObjectAIScript * CreateAIScriptClassForGameObject(uint32 uEntryId, GameObjectPointer pGameObject);
+	InstanceScript* CreateScriptClassForInstance( uint32 pMapId, MapMgrPointer pMapMgr );
 
 	bool CallScriptedDummySpell(uint32 uSpellId, uint32 i, SpellPointer pSpell);
 	bool CallScriptedDummyAura( uint32 uSpellId, uint32 i, AuraPointer  pAura, bool apply);
@@ -158,10 +163,13 @@
 	void register_hook(ServerHookEvents event, void * function_pointer);
 	void register_item_gossip_script(uint32 entry, GossipScript * gs);
 	void register_quest_script(uint32 entry, QuestScript * qs);
+	void register_instance_script( uint32 pMapId, exp_create_instance_ai pCallback );
 
 	HEARTHSTONE_INLINE GossipScript * GetDefaultGossipScript() { return DefaultGossipScript; }
 
 protected:
+
+	InstanceCreateMap mInstances;
 	CreatureCreateMap _creatures;
 	GameObjectCreateMap _gameobjects;
 	HandleDummyAuraMap _auras;
@@ -263,6 +271,58 @@
 	virtual void OnPlayerItemPickup(uint32 itemId, uint32 totalCount, PlayerPointer mTarget, QuestLogEntry *qLogEntry) {}
 };
 
+/* * Class InstanceScript
+   * Instanced class created for each instance of the map, holds all 
+   * scriptable exports
+*/
+
+class SERVER_DECL InstanceScript
+{
+public:
+	InstanceScript( MapMgrPointer pMapMgr );
+	virtual ~InstanceScript() {};
+
+	// Procedures that had been here before
+	virtual GameObjectPointer	GetObjectForOpenLock( PlayerPointer pCaster, SpellPointer pSpell, SpellEntry* pSpellEntry ) { return NULLGOB; };
+	virtual void				SetLockOptions( uint32 pEntryId, GameObjectPointer pGameObject ) {};
+	virtual uint32				GetRespawnTimeForCreature( uint32 pEntryId, CreaturePointer pCreature) { return 240000; };
+
+	// Player
+	virtual void				OnPlayerDeath( PlayerPointer pVictim, UnitPointer pKiller ) {};
+
+	// Area and AreaTrigger
+	virtual void				OnPlayerEnter( PlayerPointer pPlayer ) {};
+	virtual void				OnAreaTrigger( PlayerPointer pPlayer, uint32 pAreaId ) {};
+	virtual void				OnZoneChange( PlayerPointer pPlayer, uint32 pNewZone, uint32 pOldZone ) {};
+
+	// Data get / set - idea taken from ScriptDev2
+	virtual void				SetInstanceData( uint32 pType, uint32 pIndex, uint32 pData ) {};
+	virtual uint32				GetInstanceData( uint32 pType, uint32 pIndex ) { return 0; };
+
+	// Creature / GameObject - part of it is simple reimplementation for easier use Creature / GO < --- > Script
+	virtual void				OnCreatureDeath( CreaturePointer pVictim, UnitPointer pKiller ) {};
+	virtual void				OnCreaturePushToWorld( CreaturePointer pCreature ) {};
+	virtual void				OnGameObjectActivate( GameObjectPointer pGameObject, PlayerPointer pPlayer ) {};
+	virtual void				OnGameObjectPushToWorld( GameObjectPointer pGameObject ) {};
+
+	// Standard virtual methods
+	virtual void				OnLoad() {};
+	virtual void				UpdateEvent() {};
+	virtual void				Destroy() {};
+
+	// UpdateEvent
+	void						RegisterUpdateEvent( uint32 pFrequency );
+	void						ModifyUpdateEvent( uint32 pNewFrequency );
+	void						RemoveUpdateEvent();
+
+	// Something to return Instance's MapMgr
+	MapMgrPointer				GetInstance() { return mInstance; };
+
+protected:
+
+	MapMgrPointer mInstance;
+};
+
 class SERVER_DECL HookInterface : public Singleton<HookInterface>
 {
 public:
Index: SpellEffects.cpp
===================================================================
--- SpellEffects.cpp	(revision 1419)
+++ SpellEffects.cpp	(working copy)
@@ -3308,7 +3308,10 @@
 				return;
 
 			if( gameObjTarget->GetByte(GAMEOBJECT_BYTES_1, 1) == GAMEOBJECT_TYPE_GOOBER)
+			{
 				CALL_GO_SCRIPT_EVENT(gameObjTarget, OnActivate)(TO_PLAYER(p_caster));
+				CALL_INSTANCE_SCRIPT_EVENT( gameObjTarget->GetMapMgr(), OnGameObjectActivate )( gameObjTarget, p_caster );
+			};
 
 			if(sQuestMgr.OnGameObjectActivate(p_caster, gameObjTarget))
 			{
@@ -3341,6 +3344,7 @@
 		TO_PLAYER(caster)->UpdateNearbyGameObjects();
 	
 	CALL_GO_SCRIPT_EVENT(gameObjTarget, OnActivate)(TO_PLAYER(caster));
+	CALL_INSTANCE_SCRIPT_EVENT( gameObjTarget->GetMapMgr(), OnGameObjectActivate )( gameObjTarget, TO_PLAYER( caster ) );
 	gameObjTarget->SetByte(GAMEOBJECT_BYTES_1,GAMEOBJECT_BYTES_STATE, 0);	
 
 	if( gameObjTarget->GetEntry() == 183146)
