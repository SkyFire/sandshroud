Index: extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj
===================================================================
--- extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj	(revision 1488)
+++ extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj	(working copy)
@@ -151,11 +151,11 @@
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp" />
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastArea.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastContour.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp" />
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastLayers.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMeshDetail.cpp" />
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRasterization.cpp" />
@@ -234,7 +234,7 @@
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h" />
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h" />
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h" />
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.h" />
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourStatus.h" />
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h" />
     <ClInclude Include="..\..\src\MangosMap.h" />
     <ClInclude Include="..\..\src\MapBuilder.h" />
Index: extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj.filters
===================================================================
--- extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj.filters	(revision 1488)
+++ extras/mMap Builder/win/VC100/MoveMapGen_VC100.vcxproj.filters	(working copy)
@@ -60,48 +60,6 @@
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Collision\vmap\WorldModel.cpp">
       <Filter>Collision\vmap</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.cpp">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastArea.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastContour.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMeshDetail.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRasterization.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRegion.cpp">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Collision\g3dlite\Vector4int8.cpp">
       <Filter>Collision\G3D</Filter>
     </ClCompile>
@@ -207,6 +165,48 @@
     <ClCompile Include="..\..\..\..\src\hearthstone-shared\Collision\g3dlite\AABox.cpp">
       <Filter>Collision\G3D</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastArea.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastContour.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastLayers.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMeshDetail.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRasterization.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRegion.cpp">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\src\MMapCommon.h">
@@ -251,27 +251,6 @@
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Collision\vmap\WorldModel.h">
       <Filter>Collision\vmap</Filter>
     </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.h">
-      <Filter>Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h">
-      <Filter>Pathfinding\Recast</Filter>
-    </ClInclude>
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Collision\g3dlite\vectorMath.h">
       <Filter>Collision\G3D</Filter>
     </ClInclude>
@@ -431,5 +410,26 @@
     <ClInclude Include="..\..\..\..\src\hearthstone-shared\Collision\g3dlite\AABox.h">
       <Filter>Collision\G3D</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Detour\DetourStatus.h">
+      <Filter>Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h">
+      <Filter>Pathfinding\Recast</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ No newline at end of file
Index: src/hearthstone-shared/Network/ListenSocket.h
===================================================================
--- src/hearthstone-shared/Network/ListenSocket.h	(revision 1488)
+++ src/hearthstone-shared/Network/ListenSocket.h	(working copy)
@@ -161,10 +161,9 @@
 	void OnAccept(void * pointer)
 	{
 		int fd = *(int*)pointer;
-
-		/* no idea if this will work on x64 :P */
+		char* cpointer = ((char*)pointer);
 #ifndef X64
-		sockaddr_in * addr = (sockaddr_in*)&((char*)pointer)[42];
+		sockaddr_in * addr = (sockaddr_in*)&cpointer[42];
 #else
 		// Crow: This will work for x64, at least with what I've tested.
 		// Unsure about external IPs, as when scanning data, I saw the IP appear twice, once at 4, and once at somewhere around 12
Index: src/hearthstone-shared/Pathfinding/Detour/DetourCommon.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourCommon.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourCommon.cpp	(working copy)
@@ -238,6 +238,9 @@
 	return false;
 }
 
+/// @par
+///
+/// All points are projected onto the xz-plane, so the y-values are ignored.
 bool dtPointInPolygon(const float* pt, const float* verts, const int nverts)
 {
 	// TODO: Replace pnpoly with triArea2D tests?
@@ -291,6 +294,9 @@
 	return ((amin+eps) > bmax || (amax-eps) < bmin) ? false : true;
 }
 
+/// @par
+///
+/// All vertices are projected onto the xz-plane, so the y-values are ignored.
 bool dtOverlapPolyPoly2D(const float* polya, const int npolya,
 						 const float* polyb, const int npolyb)
 {
Index: src/hearthstone-shared/Pathfinding/Detour/DetourCommon.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourCommon.h	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourCommon.h	(working copy)
@@ -19,15 +19,66 @@
 #ifndef DETOURCOMMON_H
 #define DETOURCOMMON_H
 
+/**
+@defgroup detour Detour
+
+Members in this module are used to create, manipulate, and query navigation 
+meshes.
+
+@note This is a summary list of members.  Use the index or search 
+feature to find minor members.
+*/
+
+/// @name General helper functions
+/// @{
+
+/// Swaps the values of the two parameters.
+///  @param[in,out]	a	Value A
+///  @param[in,out]	b	Value B
 template<class T> inline void dtSwap(T& a, T& b) { T t = a; a = b; b = t; }
+
+/// Returns the minimum of two values.
+///  @param[in]		a	Value A
+///  @param[in]		b	Value B
+///  @return The minimum of the two values.
 template<class T> inline T dtMin(T a, T b) { return a < b ? a : b; }
+
+/// Returns the maximum of two values.
+///  @param[in]		a	Value A
+///  @param[in]		b	Value B
+///  @return The maximum of the two values.
 template<class T> inline T dtMax(T a, T b) { return a > b ? a : b; }
+
+/// Returns the absolute value.
+///  @param[in]		a	The value.
+///  @return The absolute value of the specified value.
 template<class T> inline T dtAbs(T a) { return a < 0 ? -a : a; }
+
+/// Returns the square of the value.
+///  @param[in]		a	The value.
+///  @return The square of the value.
 template<class T> inline T dtSqr(T a) { return a*a; }
+
+/// Clamps the value to the specified range.
+///  @param[in]		v	The value to clamp.
+///  @param[in]		mn	The minimum permitted return value.
+///  @param[in]		mx	The maximum permitted return value.
+///  @return The value, clamped to the specified range.
 template<class T> inline T dtClamp(T v, T mn, T mx) { return v < mn ? mn : (v > mx ? mx : v); }
 
+/// Returns the square root of the value.
+///  @param[in]		x	The value.
+///  @return The square root of the vlaue.
 float dtSqrt(float x);
 
+/// @}
+/// @name Vector helper functions.
+/// @{
+
+/// Derives the cross product of two vectors. (@p v1 x @p v2)
+///  @param[out]	dest	The cross product. [(x, y, z)]
+///  @param[in]		v1		A Vector [(x, y, z)]
+///  @param[in]		v2		A vector [(x, y, z)]
 inline void dtVcross(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[1]*v2[2] - v1[2]*v2[1];
@@ -35,11 +86,20 @@
 	dest[2] = v1[0]*v2[1] - v1[1]*v2[0]; 
 }
 
+/// Derives the dot product of two vectors. (@p v1 . @p v2)
+///  @param[in]		v1	A Vector [(x, y, z)]
+///  @param[in]		v2	A vector [(x, y, z)]
+/// @return The dot product.
 inline float dtVdot(const float* v1, const float* v2)
 {
 	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
 }
 
+/// Performs a scaled vector addition. (@p v1 + (@p v2 * @p s))
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to scale and add to @p v1. [(x, y, z)]
+///  @param[in]		s		The amount to scale @p v2 by before adding to @p v1.
 inline void dtVmad(float* dest, const float* v1, const float* v2, const float s)
 {
 	dest[0] = v1[0]+v2[0]*s;
@@ -47,6 +107,11 @@
 	dest[2] = v1[2]+v2[2]*s;
 }
 
+/// Performs a linear interpolation between two vectors. (@p v1 toward @p v2)
+///  @param[out]	dest	The result vector. [(x, y, x)]
+///  @param[in]		v1		The starting vector.
+///  @param[in]		v2		The destination vector.
+///	 @param[in]		t		The interpolation factor. [Limits: 0 <= value <= 1.0]
 inline void dtVlerp(float* dest, const float* v1, const float* v2, const float t)
 {
 	dest[0] = v1[0]+(v2[0]-v1[0])*t;
@@ -54,6 +119,10 @@
 	dest[2] = v1[2]+(v2[2]-v1[2])*t;
 }
 
+/// Performs a vector addition. (@p v1 + @p v2)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to add to @p v1. [(x, y, z)]
 inline void dtVadd(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[0]+v2[0];
@@ -61,6 +130,10 @@
 	dest[2] = v1[2]+v2[2];
 }
 
+/// Performs a vector subtraction. (@p v1 - @p v2)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to subtract from @p v1. [(x, y, z)]
 inline void dtVsub(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[0]-v2[0];
@@ -68,6 +141,10 @@
 	dest[2] = v1[2]-v2[2];
 }
 
+/// Scales the vector by the specified value. (@p v * @p t)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v		The vector to scale. [(x, y, z)]
+///  @param[in]		t		The scaling factor.
 inline void dtVscale(float* dest, const float* v, const float t)
 {
 	dest[0] = v[0]*t;
@@ -75,6 +152,9 @@
 	dest[2] = v[2]*t;
 }
 
+/// Selects the minimum value of each element from the specified vectors.
+///  @param[in,out]	mn	A vector.  (Will be updated with the result.) [(x, y, z)]
+///  @param[in]	v	A vector. [(x, y, z)]
 inline void dtVmin(float* mn, const float* v)
 {
 	mn[0] = dtMin(mn[0], v[0]);
@@ -82,6 +162,9 @@
 	mn[2] = dtMin(mn[2], v[2]);
 }
 
+/// Selects the maximum value of each element from the specified vectors.
+///  @param[in,out]	mx	A vector.  (Will be updated with the result.) [(x, y, z)]
+///  @param[in]		v	A vector. [(x, y, z)]
 inline void dtVmax(float* mx, const float* v)
 {
 	mx[0] = dtMax(mx[0], v[0]);
@@ -89,11 +172,19 @@
 	mx[2] = dtMax(mx[2], v[2]);
 }
 
+/// Sets the vector elements to the specified values.
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		x		The x-value of the vector.
+///  @param[in]		y		The y-value of the vector.
+///  @param[in]		z		The z-value of the vector.
 inline void dtVset(float* dest, const float x, const float y, const float z)
 {
 	dest[0] = x; dest[1] = y; dest[2] = z;
 }
 
+/// Performs a vector copy.
+///  @param[out]	dest	The result. [(x, y, z)]
+///  @param[in]		a		The vector to copy. [(x, y, z)]
 inline void dtVcopy(float* dest, const float* a)
 {
 	dest[0] = a[0];
@@ -101,16 +192,26 @@
 	dest[2] = a[2];
 }
 
+/// Derives the scalar length of the vector.
+///  @param[in]		v The vector. [(x, y, z)]
+/// @return The scalar length of the vector.
 inline float dtVlen(const float* v)
 {
 	return dtSqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
 }
 
+/// Derives the square of the scalar length of the vector. (len * len)
+///  @param[in]		v The vector. [(x, y, z)]
+/// @return The square of the scalar length of the vector.
 inline float dtVlenSqr(const float* v)
 {
 	return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
 }
 
+/// Returns the distance between two points.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The distance between the two points.
 inline float dtVdist(const float* v1, const float* v2)
 {
 	const float dx = v2[0] - v1[0];
@@ -119,6 +220,10 @@
 	return dtSqrt(dx*dx + dy*dy + dz*dz);
 }
 
+/// Returns the square of the distance between two points.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The square of the distance between the two points.
 inline float dtVdistSqr(const float* v1, const float* v2)
 {
 	const float dx = v2[0] - v1[0];
@@ -127,6 +232,12 @@
 	return dx*dx + dy*dy + dz*dz;
 }
 
+/// Derives the distance between the specified points on the xz-plane.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The distance between the point on the xz-plane.
+///
+/// The vectors are projected onto the xz-plane, so the y-values are ignored.
 inline float dtVdist2D(const float* v1, const float* v2)
 {
 	const float dx = v2[0] - v1[0];
@@ -134,6 +245,10 @@
 	return dtSqrt(dx*dx + dz*dz);
 }
 
+/// Derives the square of the distance between the specified points on the xz-plane.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The square of the distance between the point on the xz-plane.
 inline float dtVdist2DSqr(const float* v1, const float* v2)
 {
 	const float dx = v2[0] - v1[0];
@@ -141,6 +256,8 @@
 	return dx*dx + dz*dz;
 }
 
+/// Normalizes the vector.
+///  @param[in,out]	v	The vector to normalize. [(x, y, z)]
 inline void dtVnormalize(float* v)
 {
 	float d = 1.0f / dtSqrt(dtSqr(v[0]) + dtSqr(v[1]) + dtSqr(v[2]));
@@ -149,6 +266,13 @@
 	v[2] *= d;
 }
 
+/// Performs a 'sloppy' colocation check of the specified points.
+///  @param[in]		p0	A point. [(x, y, z)]
+///  @param[in]		p1	A point. [(x, y, z)]
+/// @return True if the points are considered to be at the same location.
+///
+/// Basically, this function will return true if the specified points are 
+/// close enough to eachother to be considered colocated.
 inline bool dtVequal(const float* p0, const float* p1)
 {
 	static const float thr = dtSqr(1.0f/16384.0f);
@@ -156,44 +280,37 @@
 	return d < thr;
 }
 
-inline unsigned int dtNextPow2(unsigned int v)
-{
-	v--;
-	v |= v >> 1;
-	v |= v >> 2;
-	v |= v >> 4;
-	v |= v >> 8;
-	v |= v >> 16;
-	v++;
-	return v;
-}
-
-inline unsigned int dtIlog2(unsigned int v)
-{
-	unsigned int r;
-	unsigned int shift;
-	r = (v > 0xffff) << 4; v >>= r;
-	shift = (v > 0xff) << 3; v >>= shift; r |= shift;
-	shift = (v > 0xf) << 2; v >>= shift; r |= shift;
-	shift = (v > 0x3) << 1; v >>= shift; r |= shift;
-	r |= (v >> 1);
-	return r;
-}
-
-inline int dtAlign4(int x) { return (x+3) & ~3; }
-
-inline int dtOppositeTile(int side) { return (side+4) & 0x7; }
-
+/// Derives the dot product of two vectors on the xz-plane. (@p u . @p v)
+///  @param[in]		u		A vector [(x, y, z)]
+///  @param[in]		v		A vector [(x, y, z)]
+/// @return The dot product on the xz-plane.
+///
+/// The vectors are projected onto the xz-plane, so the y-values are ignored.
 inline float dtVdot2D(const float* u, const float* v)
 {
 	return u[0]*v[0] + u[2]*v[2];
 }
 
+/// Derives the xz-plane 2D perp product of the two vectors. (uz*vx - ux*vz)
+///  @param[in]		u		The LHV vector [(x, y, z)]
+///  @param[in]		v		The RHV vector [(x, y, z)]
+/// @return The dot product on the xz-plane.
+///
+/// The vectors are projected onto the xz-plane, so the y-values are ignored.
 inline float dtVperp2D(const float* u, const float* v)
 {
 	return u[2]*v[0] - u[0]*v[2];
 }
 
+/// @}
+/// @name Computational geometry helper functions.
+/// @{
+
+/// Derives the signed xz-plane area of the triangle ABC, or the relationship of line AB to point C.
+///  @param[in]		a		Vertex A. [(x, y, z)]
+///  @param[in]		b		Vertex B. [(x, y, z)]
+///  @param[in]		c		Vertex C. [(x, y, z)]
+/// @return The signed xz-plane area of the triangle.
 inline float dtTriArea2D(const float* a, const float* b, const float* c)
 {
 	const float abx = b[0] - a[0];
@@ -203,6 +320,13 @@
 	return acx*abz - abx*acz;
 }
 
+/// Determines if two axis-aligned bounding boxes overlap.
+///  @param[in]		amin	Minimum bounds of box A. [(x, y, z)]
+///  @param[in]		amax	Maximum bounds of box A. [(x, y, z)]
+///  @param[in]		bmin	Minimum bounds of box B. [(x, y, z)]
+///  @param[in]		bmax	Maximum bounds of box B. [(x, y, z)]
+/// @return True if the two AABB's overlap.
+/// @see dtOverlapBounds
 inline bool dtOverlapQuantBounds(const unsigned short amin[3], const unsigned short amax[3],
 								 const unsigned short bmin[3], const unsigned short bmax[3])
 {
@@ -213,6 +337,13 @@
 	return overlap;
 }
 
+/// Determines if two axis-aligned bounding boxes overlap.
+///  @param[in]		amin	Minimum bounds of box A. [(x, y, z)]
+///  @param[in]		amax	Maximum bounds of box A. [(x, y, z)]
+///  @param[in]		bmin	Minimum bounds of box B. [(x, y, z)]
+///  @param[in]		bmax	Maximum bounds of box B. [(x, y, z)]
+/// @return True if the two AABB's overlap.
+/// @see dtOverlapQuantBounds
 inline bool dtOverlapBounds(const float* amin, const float* amax,
 							const float* bmin, const float* bmax)
 {
@@ -223,9 +354,21 @@
 	return overlap;
 }
 
+/// Derives the closest point on a triangle from the specified reference point.
+///  @param[out]	closest	The closest point on the triangle.	
+///  @param[in]		p		The reference point from which to test. [(x, y, z)]
+///  @param[in]		a		Vertex A of triangle ABC. [(x, y, z)]
+///  @param[in]		b		Vertex B of triangle ABC. [(x, y, z)]
+///  @param[in]		c		Vertex C of triangle ABC. [(x, y, z)]
 void dtClosestPtPointTriangle(float* closest, const float* p,
 							  const float* a, const float* b, const float* c);
 
+/// Derives the y-axis height of the closest point on the triangle from the specified reference point.
+///  @param[in]		p		The reference point from which to test. [(x, y, z)]
+///  @param[in]		a		Vertex A of triangle ABC. [(x, y, z)]
+///  @param[in]		b		Vertex B of triangle ABC. [(x, y, z)]
+///  @param[in]		c		Vertex C of triangle ABC. [(x, y, z)]
+///  @param[out]	h		The resulting height.
 bool dtClosestHeightPointTriangle(const float* p, const float* a, const float* b, const float* c, float& h);
 
 bool dtIntersectSegmentPoly2D(const float* p0, const float* p1,
@@ -233,6 +376,11 @@
 							  float& tmin, float& tmax,
 							  int& segMin, int& segMax);
 
+/// Determines if the specified point is inside the convex polygon on the xz-plane.
+///  @param[in]		pt		The point to check. [(x, y, z)]
+///  @param[in]		verts	The polygon vertices. [(x, y, z) * @p nverts]
+///  @param[in]		nverts	The number of vertices. [Limit: >= 3]
+/// @return True if the point is inside the polygon.
 bool dtPointInPolygon(const float* pt, const float* verts, const int nverts);
 
 bool dtDistancePtPolyEdgesSqr(const float* pt, const float* verts, const int nverts,
@@ -240,9 +388,99 @@
 
 float dtDistancePtSegSqr2D(const float* pt, const float* p, const float* q, float& t);
 
+/// Derives the centroid of a convex polygon.
+///  @param[out]	tc		The centroid of the polgyon. [(x, y, z)]
+///  @param[in]		idx		The polygon indices. [(vertIndex) * @p nidx]
+///  @param[in]		nidx	The number of indices in the polygon. [Limit: >= 3]
+///  @param[in]		verts	The polygon vertices. [(x, y, z) * vertCount]
 void dtCalcPolyCenter(float* tc, const unsigned short* idx, int nidx, const float* verts);
 
+/// Determines if the two convex polygons overlap on the xz-plane.
+///  @param[in]		polya		Polygon A vertices.	[(x, y, z) * @p npolya]
+///  @param[in]		npolya		The number of vertices in polygon A.
+///  @param[in]		polyb		Polygon B vertices.	[(x, y, z) * @p npolyb]
+///  @param[in]		npolyb		The number of vertices in polygon B.
+/// @return True if the two polygons overlap.
 bool dtOverlapPolyPoly2D(const float* polya, const int npolya,
 						 const float* polyb, const int npolyb);
 
+/// @}
+/// @name Miscellanious functions.
+/// @{
+
+inline unsigned int dtNextPow2(unsigned int v)
+{
+	v--;
+	v |= v >> 1;
+	v |= v >> 2;
+	v |= v >> 4;
+	v |= v >> 8;
+	v |= v >> 16;
+	v++;
+	return v;
+}
+
+inline unsigned int dtIlog2(unsigned int v)
+{
+	unsigned int r;
+	unsigned int shift;
+	r = (v > 0xffff) << 4; v >>= r;
+	shift = (v > 0xff) << 3; v >>= shift; r |= shift;
+	shift = (v > 0xf) << 2; v >>= shift; r |= shift;
+	shift = (v > 0x3) << 1; v >>= shift; r |= shift;
+	r |= (v >> 1);
+	return r;
+}
+
+inline int dtAlign4(int x) { return (x+3) & ~3; }
+
+inline int dtOppositeTile(int side) { return (side+4) & 0x7; }
+
+/// @}
+
 #endif // DETOURCOMMON_H
+
+///////////////////////////////////////////////////////////////////////////
+
+// This section contains detailed documentation for members that don't have
+// a source file. It reduces clutter in the main section of the header.
+
+/**
+
+@fn float dtTriArea2D(const float* a, const float* b, const float* c)
+@par
+
+The vertices are projected onto the xz-plane, so the y-values are ignored.
+
+This is a low cost function than can be used for various purposes.  Its main purpose
+is for point/line relationship testing.
+
+In all cases: A value of zero indicates that all vertices are collinear or represent the same point.
+(On the xz-plane.)
+
+When used for point/line relationship tests, AB usually represents a line against which
+the C point is to be tested.  In this case:
+
+A positive value indicates that point C is to the left of line AB, looking from A toward B.<br/>
+A negative value indicates that point C is to the right of lineAB, looking from A toward B.
+
+When used for evaluating a triangle:
+
+The absolute value of the return value is two times the area of the triangle when it is
+projected onto the xz-plane.
+
+A positive return value indicates:
+
+<ul>
+<li>The vertices are wrapped in the normal Detour wrap direction.</li>
+<li>The triangle's 3D face normal is in the general up direction.</li>
+</ul>
+
+A negative return value indicates:
+
+<ul>
+<li>The vertices are reverse wrapped. (Wrapped opposite the normal Detour wrap direction.)</li>
+<li>The triangle's 3D face normal is in the general down direction.</li>
+</ul>
+
+*/
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.cpp	(working copy)
@@ -21,7 +21,6 @@
 #include "DetourCommon.h"
 #include "../../Common.h"
 
-
 inline bool overlapSlabs(const float* amin, const float* amax,
 						 const float* bmin, const float* bmax,
 						 const float px, const float py)
@@ -58,6 +57,15 @@
 	return false;
 }
 
+static float getSlabCoord(const float* va, const int side)
+{
+	if (side == 0 || side == 4)
+		return va[0];
+	else if (side == 2 || side == 6)
+		return va[2];
+	return 0;
+}
+
 static void calcSlabEndPoints(const float* va, const float* vb, float* bmin, float* bmax, const int side)
 {
 	if (side == 0 || side == 4)
@@ -127,6 +135,10 @@
 	return new(mem) dtNavMesh;
 }
 
+/// @par
+///
+/// This function will only free the memory for tiles with the #DT_TILE_FREE_DATA
+/// flag set.
 void freeNavMesh(dtNavMesh* navmesh)
 {
 	if (!navmesh) return;
@@ -135,6 +147,19 @@
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
+
+/// @class dtNavMesh
+///
+/// This class is usually used in conjunction with the dtNavMeshQuery class.
+/// 
+/// Technically, all navigation meshes are tiled. A 'solo' mesh is simply a navigation mesh initialized 
+/// to have only a single tile.
+///
+/// This class does not implement any asynchronous methods. So the ::dtStatus result of all methods will 
+/// always contain either a success or failure flag.
+/// 
+/// @see dtNavMeshQuery, dtCreateNavMeshData(), dtNavMeshCreateParams, #mallocNavMesh, #freeNavMesh
+
 dtNavMesh::dtNavMesh() :
 	m_tileWidth(0),
 	m_tileHeight(0),
@@ -183,10 +208,10 @@
 	
 	m_tiles = (dtMeshTile*)malloc(sizeof(dtMeshTile)*m_maxTiles);
 	if (!m_tiles)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_OUT_OF_MEMORY;
 	m_posLookup = (dtMeshTile**)malloc(sizeof(dtMeshTile*)*m_tileLutSize);
 	if (!m_posLookup)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_OUT_OF_MEMORY;
 	memset(m_tiles, 0, sizeof(dtMeshTile)*m_maxTiles);
 	memset(m_posLookup, 0, sizeof(dtMeshTile*)*m_tileLutSize);
 	m_nextFree = 0;
@@ -198,11 +223,12 @@
 	}
 	
 	// Init ID generator values.
-	m_tileBits = STATIC_TILE_BITS;    //dtIlog2(dtNextPow2((unsigned int)params->maxTiles));
-	m_polyBits = STATIC_POLY_BITS;    //dtIlog2(dtNextPow2((unsigned int)params->maxPolys));
-	m_saltBits = STATIC_SALT_BITS;    //sizeof(dtPolyRef)*8 - m_tileBits - m_polyBits;
-	//if (m_saltBits < SALT_MIN_BITS)
-		//return DT_FAILURE;
+	m_tileBits = dtIlog2(dtNextPow2((unsigned int)params->maxTiles));
+	m_polyBits = dtIlog2(dtNextPow2((unsigned int)params->maxPolys));
+	// Only allow 31 salt bits, since the salt mask is calculated using 32bit uint and it will overflow.
+	m_saltBits = dtMin((unsigned int)31, 32 - m_tileBits - m_polyBits);
+	if (m_saltBits < 10)
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	return DT_SUCCESS;
 }
@@ -212,9 +238,9 @@
 	// Make sure the data is in right format.
 	dtMeshHeader* header = (dtMeshHeader*)data;
 	if (header->magic != DT_NAVMESH_MAGIC)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_WRONG_MAGIC;
 	if (header->version != DT_NAVMESH_VERSION)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_WRONG_VERSION;
 
 	dtNavMeshParams params;
 	dtVcopy(params.orig, header->bmin);
@@ -223,13 +249,17 @@
 	params.maxTiles = 1;
 	params.maxPolys = header->polyCount;
 	
-	dtStatus res = init(&params);
-	if (res != DT_SUCCESS)
-		return res;
+	dtStatus status = init(&params);
+	if (dtStatusFailed(status))
+		return status;
 
 	return addTile(data, dataSize, flags, 0, 0);
 }
 
+/// @par
+///
+/// @note The parameters are created automatically when the single tile
+/// initialization is performed.
 const dtNavMeshParams* dtNavMesh::getParams() const
 {
 	return &m_params;
@@ -244,6 +274,7 @@
 	
 	float amin[2], amax[2];
 	calcSlabEndPoints(va,vb, amin,amax, side);
+	const float apos = getSlabCoord(va, side);
 
 	// Remove links pointing to 'side' and compact the links array. 
 	float bmin[2], bmax[2];
@@ -260,11 +291,18 @@
 		{
 			// Skip edges which do not point to the right side.
 			if (poly->neis[j] != m) continue;
-			// Check if the segments touch.
+			
 			const float* vc = &tile->verts[poly->verts[j]*3];
 			const float* vd = &tile->verts[poly->verts[(j+1) % nv]*3];
+			const float bpos = getSlabCoord(vc, side);
+			
+			// Segments are not close enough.
+			if (dtAbs(apos-bpos) > 0.01f)
+				continue;
+			
+			// Check if the segments touch.
 			calcSlabEndPoints(vc,vd, bmin,bmax, side);
-
+			
 			if (!overlapSlabs(amin,amax, bmin,bmax, 0.01f, tile->header->walkableClimb)) continue;
 			
 			// Add return value.
@@ -281,10 +319,12 @@
 	return n;
 }
 
-void dtNavMesh::unconnectExtLinks(dtMeshTile* tile, int side)
+void dtNavMesh::unconnectExtLinks(dtMeshTile* tile, dtMeshTile* target)
 {
-	if (!tile) return;
+	if (!tile || !target) return;
 
+	const unsigned int targetNum = decodePolyIdTile(getTileRef(target));
+
 	for (int i = 0; i < tile->header->polyCount; ++i)
 	{
 		dtPoly* poly = &tile->polys[i];
@@ -292,7 +332,8 @@
 		unsigned int pj = DT_NULL_LINK;
 		while (j != DT_NULL_LINK)
 		{
-			if (tile->links[j].side == side)
+			if (tile->links[j].side != 0xff &&
+				decodePolyIdTile(tile->links[j].ref) == targetNum)
 			{
 				// Revove link.
 				unsigned int nj = tile->links[j].next;
@@ -323,19 +364,25 @@
 		dtPoly* poly = &tile->polys[i];
 
 		// Create new links.
-		unsigned short m = DT_EXT_LINK | (unsigned short)side;
+//		unsigned short m = DT_EXT_LINK | (unsigned short)side;
+		
 		const int nv = poly->vertCount;
 		for (int j = 0; j < nv; ++j)
 		{
-			// Skip edges which do not point to the right side.
-			if (poly->neis[j] != m) continue;
+			// Skip non-portal edges.
+			if ((poly->neis[j] & DT_EXT_LINK) == 0)
+				continue;
 			
+			const int dir = (int)(poly->neis[j] & 0xff);
+			if (side != -1 && dir != side)
+				continue;
+			
 			// Create new links
 			const float* va = &tile->verts[poly->verts[j]*3];
 			const float* vb = &tile->verts[poly->verts[(j+1) % nv]*3];
 			dtPolyRef nei[4];
 			float neia[4*2];
-			int nnei = findConnectingPolys(va,vb, target, dtOppositeTile(side), nei,neia,4);
+			int nnei = findConnectingPolys(va,vb, target, dtOppositeTile(dir), nei,neia,4);
 			for (int k = 0; k < nnei; ++k)
 			{
 				unsigned int idx = allocLink(tile);
@@ -344,13 +391,13 @@
 					dtLink* link = &tile->links[idx];
 					link->ref = nei[k];
 					link->edge = (unsigned char)j;
-					link->side = (unsigned char)side;
+					link->side = (unsigned char)dir;
 					
 					link->next = poly->firstLink;
 					poly->firstLink = idx;
 
 					// Compress portal limits to a byte value.
-					if (side == 0 || side == 4)
+					if (dir == 0 || dir == 4)
 					{
 						float tmin = (neia[k*2+0]-va[2]) / (vb[2]-va[2]);
 						float tmax = (neia[k*2+1]-va[2]) / (vb[2]-va[2]);
@@ -359,7 +406,7 @@
 						link->bmin = (unsigned char)(dtClamp(tmin, 0.0f, 1.0f)*255.0f);
 						link->bmax = (unsigned char)(dtClamp(tmax, 0.0f, 1.0f)*255.0f);
 					}
-					else if (side == 2 || side == 6)
+					else if (dir == 2 || dir == 6)
 					{
 						float tmin = (neia[k*2+0]-va[0]) / (vb[0]-va[0]);
 						float tmax = (neia[k*2+1]-va[0]) / (vb[0]-va[0]);
@@ -549,7 +596,8 @@
 	}
 }
 
-dtStatus dtNavMesh::closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip, const float* pos, float* closest)
+void dtNavMesh::closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip,
+										 const float* pos, float* closest) const
 {
 	const dtPoly* poly = &tile->polys[ip];
 	
@@ -576,11 +624,11 @@
 			closestDistSqr = d;
 		}
 	}
-	
-	return DT_SUCCESS;
 }
 
-dtPolyRef dtNavMesh::findNearestPolyInTile(const dtMeshTile* tile, const float* center, const float* extents, float* nearestPt)
+dtPolyRef dtNavMesh::findNearestPolyInTile(const dtMeshTile* tile,
+										   const float* center, const float* extents,
+										   float* nearestPt) const
 {
 	float bmin[3], bmax[3];
 	dtVsub(bmin, center, extents);
@@ -597,8 +645,7 @@
 	{
 		dtPolyRef ref = polys[i];
 		float closestPtPoly[3];
-		if (closestPointOnPolyInTile(tile, decodePolyIdPoly(ref), center, closestPtPoly) != DT_SUCCESS)
-			continue;
+		closestPointOnPolyInTile(tile, decodePolyIdPoly(ref), center, closestPtPoly);
 		float d = dtVdistSqr(center, closestPtPoly);
 		if (d < nearestDistanceSqr)
 		{
@@ -612,7 +659,8 @@
 	return nearest;
 }
 
-int dtNavMesh::queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax, dtPolyRef* polys, const int maxPolys)
+int dtNavMesh::queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax,
+								   dtPolyRef* polys, const int maxPolys) const
 {
 	if (tile->bvTree)
 	{
@@ -692,19 +740,34 @@
 	}
 }
 
+/// @par
+///
+/// The add operation will fail if the data is in the wrong format, the allocated tile
+/// space is full, or there is a tile already at the specified reference.
+///
+/// The lastRef parameter is used to restore a tile with the same tile
+/// reference it had previously used.  In this case the #dtPolyRef's for the
+/// tile will be restored to the same values they were before the tile was 
+/// removed.
+///
+/// @see dtCreateNavMeshData, #removeTile
 dtStatus dtNavMesh::addTile(unsigned char* data, int dataSize, int flags,
 							dtTileRef lastRef, dtTileRef* result)
 {
 	// Make sure the data is in right format.
 	dtMeshHeader* header = (dtMeshHeader*)data;
 	if (header->magic != DT_NAVMESH_MAGIC)
-		return DT_FAILURE_DATA_MAGIC;
+		return DT_FAILURE | DT_WRONG_MAGIC;
 	if (header->version != DT_NAVMESH_VERSION)
-		return DT_FAILURE_DATA_VERSION;
+		return DT_FAILURE | DT_WRONG_VERSION;
 
 	// Make sure the location is free.
-	if (getTileAt(header->x, header->y))
-		return DT_IN_PROGRESS;
+	const dtMeshTile* existingMesh = getTileAt(header->x, header->y, header->layer);
+	if (existingMesh)
+	{
+		*result = getTileRef(existingMesh);
+		return DT_FAILURE | DT_IN_PROGRESS;
+	}
 
 	// Allocate a tile.
 	dtMeshTile* tile = 0;
@@ -722,7 +785,7 @@
 		// Try to relocate the tile to specific index with same salt.
 		int tileIndex = (int)decodePolyIdTile((dtPolyRef)lastRef);
 		if (tileIndex >= m_maxTiles)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 		// Try to find the specific tile id from the free list.
 		dtMeshTile* target = &m_tiles[tileIndex];
 		dtMeshTile* prev = 0;
@@ -734,7 +797,7 @@
 		}
 		// Could not find the correct location.
 		if (tile != target)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 		// Remove from freelist
 		if (!prev)
 			m_nextFree = tile->next;
@@ -747,13 +810,13 @@
 
 	// Make sure we could allocate a tile.
 	if (!tile)
-		return DT_FAILURE_OUT_OF_MEMORY;
-
+		return DT_FAILURE | DT_OUT_OF_MEMORY;
+	
 	// Insert tile into the position lut.
 	int h = computeTileHash(header->x, header->y, m_tileLutMask);
 	tile->next = m_posLookup[h];
 	m_posLookup[h] = tile;
-
+	
 	// Patch header pointers.
 	const int headerSize = dtAlign4(sizeof(dtMeshHeader));
 	const int vertsSize = dtAlign4(sizeof(float)*3*header->vertCount);
@@ -775,6 +838,10 @@
 	tile->bvTree = (dtBVNode*)d; d += bvtreeSize;
 	tile->offMeshCons = (dtOffMeshConnection*)d; d += offMeshLinksSize;
 
+	// If there are no items in the bvtree, reset the tree pointer.
+	if (!bvtreeSize)
+		tile->bvTree = 0;
+
 	// Build links freelist
 	tile->linksFreeList = 0;
 	tile->links[header->maxLinkCount-1].next = DT_NULL_LINK;
@@ -790,74 +857,140 @@
 	connectIntLinks(tile);
 	connectIntOffMeshLinks(tile);
 
-	// Create connections connections.
+	// Create connections with neighbour tiles.
+	dtMeshTile* neis[MAX_NEIS];
+	int nneis;
+	
+	// Connect with layers in current tile.
+	nneis = getTilesAt(header->x, header->y, neis, MAX_NEIS);
+	for (int j = 0; j < nneis; ++j)
+	{
+		if (neis[j] == tile) continue;
+		connectExtLinks(tile, neis[j], -1);
+		connectExtLinks(neis[j], tile, -1);
+		connectExtOffMeshLinks(tile, neis[j], -1);
+		connectExtOffMeshLinks(neis[j], tile, -1);
+	}
+	
+	// Connect with neighbour tiles.
 	for (int i = 0; i < 8; ++i)
 	{
-		dtMeshTile* nei = getNeighbourTileAt(header->x, header->y, i);
-		if (nei)
+		nneis = getNeighbourTilesAt(header->x, header->y, i, neis, MAX_NEIS);
+		for (int j = 0; j < nneis; ++j)
 		{
-			connectExtLinks(tile, nei, i);
-			connectExtLinks(nei, tile, dtOppositeTile(i));
-			connectExtOffMeshLinks(tile, nei, i);
-			connectExtOffMeshLinks(nei, tile, dtOppositeTile(i));
+			connectExtLinks(tile, neis[j], i);
+			connectExtLinks(neis[j], tile, dtOppositeTile(i));
+			connectExtOffMeshLinks(tile, neis[j], i);
+			connectExtOffMeshLinks(neis[j], tile, dtOppositeTile(i));
 		}
 	}
-
-	if(result)
+	
+	if (result)
 		*result = getTileRef(tile);
-
+	
 	return DT_SUCCESS;
 }
 
-const dtMeshTile* dtNavMesh::getTileAt(int x, int y) const
+const dtMeshTile* dtNavMesh::getTileAt(const int x, const int y, const int layer) const
 {
 	// Find tile based on hash.
 	int h = computeTileHash(x,y,m_tileLutMask);
 	dtMeshTile* tile = m_posLookup[h];
 	while (tile)
 	{
-		if (tile->header && tile->header->x == x && tile->header->y == y)
+		if (tile->header &&
+			tile->header->x == x &&
+			tile->header->y == y &&
+			tile->header->layer == layer)
+		{
 			return tile;
+		}
 		tile = tile->next;
 	}
 	return 0;
 }
 
-dtMeshTile* dtNavMesh::getNeighbourTileAt(int x, int y, int side) const
+int dtNavMesh::getNeighbourTilesAt(const int x, const int y, const int side, dtMeshTile** tiles, const int maxTiles) const
 {
+	int nx = x, ny = y;
 	switch (side)
 	{
-		case 0: x++; break;
-		case 1: x++; y++; break;
-		case 2: y++; break;
-		case 3: x--; y++; break;
-		case 4: x--; break;
-		case 5: x--; y--; break;
-		case 6: y--; break;
-		case 7: x++; y--; break;
+		case 0: nx++; break;
+		case 1: nx++; ny++; break;
+		case 2: ny++; break;
+		case 3: nx--; ny++; break;
+		case 4: nx--; break;
+		case 5: nx--; ny--; break;
+		case 6: ny--; break;
+		case 7: nx++; ny--; break;
 	};
 
+	return getTilesAt(nx, ny, tiles, maxTiles);
+}
+
+int dtNavMesh::getTilesAt(const int x, const int y, dtMeshTile** tiles, const int maxTiles) const
+{
+	int n = 0;
+	
 	// Find tile based on hash.
 	int h = computeTileHash(x,y,m_tileLutMask);
 	dtMeshTile* tile = m_posLookup[h];
 	while (tile)
 	{
-		if (tile->header && tile->header->x == x && tile->header->y == y)
-			return tile;
+		if (tile->header &&
+			tile->header->x == x &&
+			tile->header->y == y)
+		{
+			if (n < maxTiles)
+				tiles[n++] = tile;
+		}
 		tile = tile->next;
 	}
-	return 0;
+	
+	return n;
 }
 
-dtTileRef dtNavMesh::getTileRefAt(int x, int y) const
+/// @par
+///
+/// This function will not fail if the tiles array is too small to hold the
+/// entire result set.  It will simply fill the array to capacity.
+int dtNavMesh::getTilesAt(const int x, const int y, dtMeshTile const** tiles, const int maxTiles) const
 {
+	int n = 0;
+	
 	// Find tile based on hash.
 	int h = computeTileHash(x,y,m_tileLutMask);
 	dtMeshTile* tile = m_posLookup[h];
 	while (tile)
 	{
-		if (tile->header && tile->header->x == x && tile->header->y == y)
+		if (tile->header &&
+			tile->header->x == x &&
+			tile->header->y == y)
+		{
+			if (n < maxTiles)
+				tiles[n++] = tile;
+		}
+		tile = tile->next;
+	}
+	
+	return n;
+}
+
+
+dtTileRef dtNavMesh::getTileRefAt(const int x, const int y, const int layer) const
+{
+	// Find tile based on hash.
+	int h = computeTileHash(x,y,m_tileLutMask);
+	dtMeshTile* tile = m_posLookup[h];
+	while (tile)
+	{
+		if (tile->header &&
+			tile->header->x == x &&
+			tile->header->y == y &&
+			tile->header->layer == layer)
+		{
 			return getTileRef(tile);
+		}
 		tile = tile->next;
 	}
 	return 0;
@@ -900,16 +1033,22 @@
 
 dtStatus dtNavMesh::getTileAndPolyByRef(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
-	if (ip >= (unsigned int)m_tiles[it].header->polyCount) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
+	if (ip >= (unsigned int)m_tiles[it].header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	*tile = &m_tiles[it];
 	*poly = &m_tiles[it].polys[ip];
 	return DT_SUCCESS;
 }
 
+/// @par
+///
+/// @warning Only use this function if it is known that the provided polygon
+/// reference is valid. This function is faster than #getTileAndPolyByRef, but
+/// it does not validate the reference.
 void dtNavMesh::getTileAndPolyByRefUnsafe(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const
 {
 	unsigned int salt, it, ip;
@@ -920,6 +1059,7 @@
 
 bool dtNavMesh::isValidPolyRef(dtPolyRef ref) const
 {
+	if (!ref) return false;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
 	if (it >= (unsigned int)m_maxTiles) return false;
@@ -928,18 +1068,25 @@
 	return true;
 }
 
+/// @par
+///
+/// This function returns the data for the tile so that, if desired,
+/// it can be added back to the navigation mesh at a later point.
+///
+/// @see #addTile
 dtStatus dtNavMesh::removeTile(dtTileRef ref, unsigned char** data, int* dataSize)
 {
 	if (!ref)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
+
 	unsigned int tileIndex = decodePolyIdTile((dtPolyRef)ref);
 	unsigned int tileSalt = decodePolyIdSalt((dtPolyRef)ref);
 	if ((int)tileIndex >= m_maxTiles)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 
 	dtMeshTile* tile = &m_tiles[tileIndex];
 	if (tile->salt != tileSalt)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 
 	// Remove tile from hash lookup.
 	int h = computeTileHash(tile->header->x,tile->header->y,m_tileLutMask);
@@ -958,16 +1105,28 @@
 		prev = cur;
 		cur = cur->next;
 	}
+
+	//// Remove connections to neighbour tiles.
+	// Create connections with neighbour tiles.
+	dtMeshTile* neis[MAX_NEIS];
+	int nneis;
+
+	// Connect with layers in current tile.
+	nneis = getTilesAt(tile->header->x, tile->header->y, neis, MAX_NEIS);
+	for (int j = 0; j < nneis; ++j)
+	{
+		if (neis[j] == tile) continue;
+		unconnectExtLinks(neis[j], tile);
+	}
 	
-	// Remove connections to neighbour tiles.
+	// Connect with neighbour tiles.
 	for (int i = 0; i < 8; ++i)
 	{
-		dtMeshTile* nei = getNeighbourTileAt(tile->header->x,tile->header->y,i);
-		if (!nei) continue;
-		unconnectExtLinks(nei, dtOppositeTile(i));
+		nneis = getNeighbourTilesAt(tile->header->x, tile->header->y, i, neis, MAX_NEIS);
+		for (int j = 0; j < nneis; ++j)
+			unconnectExtLinks(neis[j], tile);
 	}
-	
-	
+		
 	// Reset tile.
 	if (tile->flags & DT_TILE_FREE_DATA)
 	{
@@ -1010,12 +1169,25 @@
 
 dtTileRef dtNavMesh::getTileRef(const dtMeshTile* tile) const
 {
-	if (!tile)
-		return 0;
+	if (!tile) return 0;
 	const unsigned int it = tile - m_tiles;
 	return (dtTileRef)encodePolyId(tile->salt, it, 0);
 }
 
+/// @par
+///
+/// Example use case:
+/// @code
+///
+/// const dtPolyRef base = navmesh->getPolyRefBase(tile);
+/// for (int i = 0; i < tile->header->polyCount; ++i)
+/// {
+///     const dtPoly* p = &tile->polys[i];
+///     const dtPolyRef ref = base | (dtPolyRef)i;
+///     
+///     // Use the reference to access the polygon data.
+/// }
+/// @endcode
 dtPolyRef dtNavMesh::getPolyRefBase(const dtMeshTile* tile) const
 {
 	if (!tile) return 0;
@@ -1036,6 +1208,7 @@
 	unsigned char area;							// Area ID of the polygon.
 };
 
+///  @see #storeTileState
 int dtNavMesh::getTileStateSize(const dtMeshTile* tile) const
 {
 	if (!tile) return 0;
@@ -1044,12 +1217,17 @@
 	return headerSize + polyStateSize;
 }
 
+/// @par
+///
+/// Tile state includes non-structural data such as polygon flags, area ids, etc.
+/// @note The state data is only valid until the tile reference changes.
+/// @see #getTileStateSize, #restoreTileState
 dtStatus dtNavMesh::storeTileState(const dtMeshTile* tile, unsigned char* data, const int maxDataSize) const
 {
 	// Make sure there is enough space to store the state.
 	const int sizeReq = getTileStateSize(tile);
 	if (maxDataSize < sizeReq)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_BUFFER_TOO_SMALL;
 		
 	dtTileState* tileState = (dtTileState*)data; data += dtAlign4(sizeof(dtTileState));
 	dtPolyState* polyStates = (dtPolyState*)data; data += dtAlign4(sizeof(dtPolyState) * tile->header->polyCount);
@@ -1071,23 +1249,28 @@
 	return DT_SUCCESS;
 }
 
+/// @par
+///
+/// Tile state includes non-structural data such as polygon flags, area ids, etc.
+/// @note This function does not impact the tile's #dtTileRef and #dtPolyRef's.
+/// @see #storeTileState
 dtStatus dtNavMesh::restoreTileState(dtMeshTile* tile, const unsigned char* data, const int maxDataSize)
 {
 	// Make sure there is enough space to store the state.
 	const int sizeReq = getTileStateSize(tile);
 	if (maxDataSize < sizeReq)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	const dtTileState* tileState = (const dtTileState*)data; data += dtAlign4(sizeof(dtTileState));
 	const dtPolyState* polyStates = (const dtPolyState*)data; data += dtAlign4(sizeof(dtPolyState) * tile->header->polyCount);
 	
 	// Check that the restore is possible.
 	if (tileState->magic != DT_NAVMESH_STATE_MAGIC)
-		return DT_FAILURE_DATA_MAGIC;
+		return DT_FAILURE | DT_WRONG_MAGIC;
 	if (tileState->version != DT_NAVMESH_STATE_VERSION)
-		return DT_FAILURE_DATA_VERSION;
+		return DT_FAILURE | DT_WRONG_VERSION;
 	if (tileState->ref != getTileRef(tile))
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	// Restore per poly state.
 	for (int i = 0; i < tile->header->polyCount; ++i)
@@ -1101,17 +1284,26 @@
 	return DT_SUCCESS;
 }
 
-// Returns start and end location of an off-mesh link polygon.
+/// @par
+///
+/// Off-mesh connections are stored in the navigation mesh as special 2-vertex 
+/// polygons with a single edge. At least one of the vertices is expected to be 
+/// inside a normal polygon. So an off-mesh connection is "entered" from a 
+/// normal polygon at one of its endpoints. This is the polygon identified by 
+/// the prevRef parameter.
 dtStatus dtNavMesh::getOffMeshConnectionPolyEndPoints(dtPolyRef prevRef, dtPolyRef polyRef, float* startPos, float* endPos) const
 {
 	unsigned int salt, it, ip;
 
+	if (!polyRef)
+		return DT_FAILURE;
+	
 	// Get current polygon
 	decodePolyId(polyRef, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtPoly* poly = &tile->polys[ip];
 
 	// Make sure that the current poly is indeed off-mesh link.
@@ -1146,6 +1338,9 @@
 {
 	unsigned int salt, it, ip;
 	
+	if (!ref)
+		return 0;
+	
 	// Get current polygon
 	decodePolyId(ref, salt, it, ip);
 	if (it >= (unsigned int)m_maxTiles) return 0;
@@ -1166,12 +1361,13 @@
 
 dtStatus dtNavMesh::setPolyFlags(dtPolyRef ref, unsigned short flags)
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	dtPoly* poly = &tile->polys[ip];
 	
 	// Change flags.
@@ -1182,12 +1378,13 @@
 
 dtStatus dtNavMesh::getPolyFlags(dtPolyRef ref, unsigned short* resultFlags) const
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtPoly* poly = &tile->polys[ip];
 
 	*resultFlags = poly->flags;
@@ -1197,12 +1394,13 @@
 
 dtStatus dtNavMesh::setPolyArea(dtPolyRef ref, unsigned char area)
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	dtPoly* poly = &tile->polys[ip];
 	
 	poly->setArea(area);
@@ -1212,12 +1410,13 @@
 
 dtStatus dtNavMesh::getPolyArea(dtPolyRef ref, unsigned char* resultArea) const
 {
+	if (!ref) return DT_FAILURE;
 	unsigned int salt, it, ip;
 	decodePolyId(ref, salt, it, ip);
-	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE;
-	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE;
+	if (it >= (unsigned int)m_maxTiles) return DT_FAILURE | DT_INVALID_PARAM;
+	if (m_tiles[it].salt != salt || m_tiles[it].header == 0) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtMeshTile* tile = &m_tiles[it];
-	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE;
+	if (ip >= (unsigned int)tile->header->polyCount) return DT_FAILURE | DT_INVALID_PARAM;
 	const dtPoly* poly = &tile->polys[ip];
 	
 	*resultArea = poly->getArea();
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.h	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMesh.h	(working copy)
@@ -20,322 +20,461 @@
 #define DETOURNAVMESH_H
 
 #include "../../Common.h"
+#include "DetourStatus.h"
 
-#ifdef WIN32
-    typedef unsigned __int64   uint64;
-#else
-#include <stdint.h>
-#ifndef uint64_t
-#ifdef __linux__
-#include <linux/types.h>
-#endif
-#endif
-    typedef uint64_t           uint64;
-#endif
-
 // Note: If you want to use 64-bit refs, change the types of both dtPolyRef & dtTileRef.
-// It is also recommended to change dtHashRef() to proper 64-bit hash too.
+// It is also recommended that you change dtHashRef() to a proper 64-bit hash.
 
-// Reference to navigation polygon.
-typedef uint64 dtPolyRef;
+/// A handle to a polygon within a navigation mesh tile.
+/// @ingroup detour
+typedef unsigned int dtPolyRef;
 
-// Reference to navigation mesh tile.
-typedef uint64 dtTileRef;
+/// A handle to a tile within a navigation mesh.
+/// @ingroup detour
+typedef unsigned int dtTileRef;
 
-// Maximum number of vertices per navigation polygon.
+/// The maximum number of vertices per navigation polygon.
+/// @ingroup detour
 static const int DT_VERTS_PER_POLYGON = 6;
 
-static const int DT_NAVMESH_MAGIC = 'D'<<24 | 'N'<<16 | 'A'<<8 | 'V'; //'DNAV';
-static const int DT_NAVMESH_VERSION = 6;
+/// The maximum number of connections with neighboring tiles.
+static const int MAX_NEIS = 32;
 
-static const int DT_NAVMESH_STATE_MAGIC = 'D'<<24 | 'N'<<16 | 'M'<<8 | 'S'; //'DNMS';
+/// @{
+/// @name Tile Serialization Constants
+/// These constants are used to detect whether a navigation tile's data
+/// and state format is compatible with the current build.
+///
+
+/// A magic number used to detect compatibility of navigation tile data.
+static const int DT_NAVMESH_MAGIC = 'D'<<24 | 'N'<<16 | 'A'<<8 | 'V';
+
+/// A version number used to detect compatibility of navigation tile data.
+static const int DT_NAVMESH_VERSION = 7;
+
+/// A magic number used to detect the compatibility of navigation tile states.
+static const int DT_NAVMESH_STATE_MAGIC = 'D'<<24 | 'N'<<16 | 'M'<<8 | 'S';
+
+/// A version number used to detect compatibility of navigation tile states.
 static const int DT_NAVMESH_STATE_VERSION = 1;
 
+/// @}
+
+/// A flag that indicates that an entity links to an external entity.
+/// (E.g. A polygon edge is a portal that links to another polygon.)
 static const unsigned short DT_EXT_LINK = 0x8000;
+
+/// A value that indicates the entity does not link to anything.
 static const unsigned int DT_NULL_LINK = 0xffffffff;
+
+/// A flag that indicates that an off-mesh connection can be traversed in both directions. (Is bi-directional.)
 static const unsigned int DT_OFFMESH_CON_BIDIR = 1;
 
+/// The maximum number of user defined area ids.
+/// @ingroup detour
 static const int DT_MAX_AREAS = 64;
 
-static const int STATIC_SALT_BITS = 12;
-static const int STATIC_TILE_BITS = 21;
-static const int STATIC_POLY_BITS = 31;
-// we cannot have over 31 bits for either tile nor poly
-// without changing polyCount to use 64bits too.
-
-// Flags for addTile
+/// Tile flags used for various functions and fields.
+/// For an example, see dtNavMesh::addTile().
 enum dtTileFlags
 {
-	DT_TILE_FREE_DATA = 0x01,					// Navmesh owns the tile memory and should free it.
+	/// The navigation mesh owns the tile memory and is responsible for freeing it.
+	DT_TILE_FREE_DATA = 0x01,
 };
 
-// Flags returned by findStraightPath().
+/// Vertex flags returned by dtNavMeshQuery::findStraightPath.
 enum dtStraightPathFlags
 {
-	DT_STRAIGHTPATH_START = 0x01,				// The vertex is the start position.
-	DT_STRAIGHTPATH_END = 0x02,					// The vertex is the end position.
-	DT_STRAIGHTPATH_OFFMESH_CONNECTION = 0x04,	// The vertex is start of an off-mesh link.
+	DT_STRAIGHTPATH_START = 0x01,				///< The vertex is the start position in the path.
+	DT_STRAIGHTPATH_END = 0x02,					///< The vertex is the end position in the path.
+	DT_STRAIGHTPATH_OFFMESH_CONNECTION = 0x04,	///< The vertex is the start of an off-mesh connection.
 };
 
-// Flags describing polygon properties.
+/// Flags representing the type of a navigation mesh polygon.
 enum dtPolyTypes
 {
-	DT_POLYTYPE_GROUND = 0,						// Regular ground polygons.
-	DT_POLYTYPE_OFFMESH_CONNECTION = 1,			// Off-mesh connections.
+	/// The polygon is a standard convex polygon that is part of the surface of the mesh.
+	DT_POLYTYPE_GROUND = 0,
+	/// The polygon is an off-mesh connection consisting of two vertices.
+	DT_POLYTYPE_OFFMESH_CONNECTION = 1,
 };
 
-enum dtStatus
+
+/// Defines a polyogn within a dtMeshTile object.
+/// @ingroup detour
+struct dtPoly
 {
-	DT_FAILURE = 0,								// Operation failed.
-	DT_FAILURE_DATA_MAGIC,
-	DT_FAILURE_DATA_VERSION,
-	DT_FAILURE_OUT_OF_MEMORY,
-	DT_SUCCESS,									// Operation succeed.
-	DT_IN_PROGRESS,								// Operation still in progress.
-};
+	/// Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)
+	unsigned int firstLink;
 
+	/// The indices of the polygon's vertices.
+	/// The actual vertices are located in dtMeshTile::verts.
+	unsigned short verts[DT_VERTS_PER_POLYGON];
 
-// Structure describing the navigation polygon data.
-struct dtPoly
-{
-	unsigned int firstLink;						// Index to first link in linked list. 
-	unsigned short verts[DT_VERTS_PER_POLYGON];	// Indices to vertices of the poly.
-	unsigned short neis[DT_VERTS_PER_POLYGON];	// Refs to neighbours of the poly.
-	unsigned short flags;						// Flags (see dtPolyFlags).
-	unsigned char vertCount;					// Number of vertices.
-	unsigned char areaAndtype;					// Bit packed: Area ID of the polygon, and Polygon type, see dtPolyTypes..
+	/// Packed data representing neighbor polygons references and flags for each edge.
+	unsigned short neis[DT_VERTS_PER_POLYGON];
+
+	/// The user defined polygon flags.
+	unsigned short flags;
+
+	/// The number of vertices in the polygon.
+	unsigned char vertCount;
+
+	/// The bit packed area id and polygon type.
+	/// @note Use the structure's set and get methods to acess this value.
+	unsigned char areaAndtype;
+
+	/// Sets the user defined area id. [Limit: < #DT_MAX_AREAS]
 	inline void setArea(unsigned char a) { areaAndtype = (areaAndtype & 0xc0) | (a & 0x3f); }
+
+	/// Sets the polygon type. (See: #dtPolyTypes.)
 	inline void setType(unsigned char t) { areaAndtype = (areaAndtype & 0x3f) | (t << 6); }
+
+	/// Gets the user defined area id.
 	inline unsigned char getArea() const { return areaAndtype & 0x3f; }
+
+	/// Gets the polygon type. (See: #dtPolyTypes)
 	inline unsigned char getType() const { return areaAndtype >> 6; }
 };
 
-// Stucture describing polygon detail triangles.
+/// Defines the location of detail sub-mesh data within a dtMeshTile.
 struct dtPolyDetail
 {
-	unsigned int vertBase;						// Offset to detail vertex array.
-	unsigned int triBase;						// Offset to detail triangle array.
-	unsigned char vertCount;					// Number of vertices in the detail mesh.
-	unsigned char triCount;						// Number of triangles.
+	unsigned int vertBase;			///< The offset of the vertices in the dtMeshTile::detailVerts array.
+	unsigned int triBase;			///< The offset of the triangles in the dtMeshTile::detailTris array.
+	unsigned char vertCount;		///< The number of vertices in the sub-mesh.
+	unsigned char triCount;			///< The number of triangles in the sub-mesh.
 };
 
-// Stucture describing a link to another polygon.
+/// Defines a link between polygons.
+/// @note This structure is rarely if ever used by the end user.
+/// @see dtMeshTile
 struct dtLink
 {
-	dtPolyRef ref;							// Neighbour reference.
-	unsigned int next;						// Index to next link.
-	unsigned char edge;						// Index to polygon edge which owns this link. 
-	unsigned char side;						// If boundary link, defines on which side the link is.
-	unsigned char bmin, bmax;				// If boundary link, defines the sub edge area.
+	dtPolyRef ref;					///< Neighbour reference. (The neighbor that is linked to.)
+	unsigned int next;				///< Index of the next link.
+	unsigned char edge;				///< Index of the polygon edge that owns this link.
+	unsigned char side;				///< If a boundary link, defines on which side the link is.
+	unsigned char bmin;				///< If a boundary link, defines the minimum sub-edge area.
+	unsigned char bmax;				///< If a boundary link, defines the maximum sub-edge area.
 };
 
+/// Bounding volume node.
+/// @note This structure is rarely if ever used by the end user.
+/// @see dtMeshTile
 struct dtBVNode
 {
-	unsigned short bmin[3], bmax[3];		// BVnode bounds
-	int i;									// Index to item or if negative, escape index.
+	unsigned short bmin[3];			///< Minimum bounds of the node's AABB. [(x, y, z)]
+	unsigned short bmax[3];			///< Maximum bounds of the node's AABB. [(x, y, z)]
+	int i;							///< The node's index. (Negative for escape sequence.)
 };
 
+/// Defines an navigation mesh off-mesh connection within a dtMeshTile object.
+/// An off-mesh connection is a user defined traversable connection made up to two vertices.
 struct dtOffMeshConnection
 {
-	float pos[6];							// Both end point locations.
-	float rad;								// Link connection radius.
-	unsigned short poly;					// Poly Id
-	unsigned char flags;					// Link flags
-	unsigned char side;						// End point side.
-	unsigned int userId;					// User ID to identify this connection.
+	/// The endpoints of the connection. [(ax, ay, az, bx, by, bz)]
+	float pos[6];
+
+	/// The radius of the endpoints. [Limit: >= 0]
+	float rad;		
+
+	/// The polygon reference of the connection within the tile.
+	unsigned short poly;
+
+	/// Link flags. 
+	/// @note These are not the connection's user defined flags. Those are assigned via the 
+	/// connection's dtPoly definition. These are link flags used for internal purposes.
+	unsigned char flags;
+
+	/// End point side.
+	unsigned char side;
+
+	/// The id of the offmesh connection. (User assigned when the navigation mesh is built.)
+	unsigned int userId;
 };
 
+/// Provides high level information related to a dtMeshTile object.
+/// @ingroup detour
 struct dtMeshHeader
 {
-	int magic;								// Magic number, used to identify the data.
-	int version;							// Data version number.
-	int x, y;								// Location of the time on the grid.
-	unsigned int userId;					// User ID of the tile.
-	int polyCount;							// Number of polygons in the tile.
-	int vertCount;							// Number of vertices in the tile.
-	int maxLinkCount;						// Number of allocated links.
-	int detailMeshCount;					// Number of detail meshes.
-	int detailVertCount;					// Number of detail vertices.
-	int detailTriCount;						// Number of detail triangles.
-	int bvNodeCount;						// Number of BVtree nodes.
-	int offMeshConCount;					// Number of Off-Mesh links.
-	int offMeshBase;						// Index to first polygon which is Off-Mesh link.
-	float walkableHeight;					// Height of the agent.
-	float walkableRadius;					// Radius of the agent
-	float walkableClimb;					// Max climb height of the agent.
-	float bmin[3], bmax[3];					// Bounding box of the tile.
-	float bvQuantFactor;					// BVtree quantization factor (world to bvnode coords)
+	int magic;				///< Tile magic number. (Used to identify the data format.)
+	int version;			///< Tile data format version number.
+	int x;					///< The x-position of the tile within the dtNavMesh tile grid. (x, y, layer)
+	int y;					///< The y-position of the tile within the dtNavMesh tile grid. (x, y, layer)
+	int layer;				///< The layer of the tile within the dtNavMesh tile grid. (x, y, layer)
+	unsigned int userId;	///< The user defined id of the tile.
+	int polyCount;			///< The number of polygons in the tile.
+	int vertCount;			///< The number of vertices in the tile.
+	int maxLinkCount;		///< The number of allocated links.
+	int detailMeshCount;	///< The number of sub-meshes in the detail mesh.
+	
+	/// The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)
+	int detailVertCount;
+	
+	int detailTriCount;			///< The number of triangles in the detail mesh.
+	int bvNodeCount;			///< The number of bounding volume nodes. (Zero if bounding volumes are disabled.)
+	int offMeshConCount;		///< The number of off-mesh connections.
+	int offMeshBase;			///< The index of the first polygon which is an off-mesh connection.
+	float walkableHeight;		///< The height of the agents using the tile.
+	float walkableRadius;		///< The radius of the agents using the tile.
+	float walkableClimb;		///< The maximum climb height of the agents using the tile.
+	float bmin[3];				///< The minimum bounds of the tile's AABB. [(x, y, z)]
+	float bmax[3];				///< The maximum bounds of the tile's AABB. [(x, y, z)]
+	
+	/// The bounding volume quantization factor. 
+	float bvQuantFactor;
 };
 
+/// Defines a navigation mesh tile.
+/// @ingroup detour
 struct dtMeshTile
 {
-	unsigned int salt;						// Counter describing modifications to the tile.
+	unsigned int salt;					///< Counter describing modifications to the tile.
 
-	unsigned int linksFreeList;				// Index to next free link.
-	dtMeshHeader* header;					// Pointer to tile header.
-	dtPoly* polys;							// Pointer to the polygons (will be updated when tile is added).
-	float* verts;							// Pointer to the vertices (will be updated when tile added).
-	dtLink* links;							// Pointer to the links (will be updated when tile added).
-	dtPolyDetail* detailMeshes;				// Pointer to detail meshes (will be updated when tile added).
-	float* detailVerts;						// Pointer to detail vertices (will be updated when tile added).
-	unsigned char* detailTris;				// Pointer to detail triangles (will be updated when tile added).
-	dtBVNode* bvTree;						// Pointer to BVtree nodes (will be updated when tile added).
-	dtOffMeshConnection* offMeshCons;		// Pointer to Off-Mesh links. (will be updated when tile added).
+	unsigned int linksFreeList;			///< Index to the next free link.
+	dtMeshHeader* header;				///< The tile header.
+	dtPoly* polys;						///< The tile polygons. [Size: dtMeshHeader::polyCount]
+	float* verts;						///< The tile vertices. [Size: dtMeshHeader::vertCount]
+	dtLink* links;						///< The tile links. [Size: dtMeshHeader::maxLinkCount]
+	dtPolyDetail* detailMeshes;			///< The tile's detail sub-meshes. [Size: dtMeshHeader::detailMeshCount]
+	
+	/// The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]
+	float* detailVerts;	
+
+	/// The detail mesh's triangles. [(vertA, vertB, vertC) * dtMeshHeader::detailTriCount]
+	unsigned char* detailTris;	
+
+	/// The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount]
+	/// (Will be null if bounding volumes are disabled.)
+	dtBVNode* bvTree;
+
+	dtOffMeshConnection* offMeshCons;		///< The tile off-mesh connections. [Size: dtMeshHeader::offMeshConCount]
 		
-	unsigned char* data;					// Pointer to tile data.
-	int dataSize;							// Size of the tile data.
-	int flags;								// Tile flags, see dtTileFlags.
-	dtMeshTile* next;						// Next free tile or, next tile in spatial grid.
+	unsigned char* data;					///< The tile data. (Not directly accessed under normal situations.)
+	int dataSize;							///< Size of the tile data.
+	int flags;								///< Tile flags. (See: #dtTileFlags)
+	dtMeshTile* next;						///< The next free tile, or the next tile in the spatial grid.
 };
 
+/// Configutration parameters used to define multi-tile navigation meshes.
+/// The values are used to allocate space during the initialization of a navigation mesh.
+/// @see dtNavMesh::init()
+/// @ingroup detour
 struct dtNavMeshParams
 {
-	float orig[3];					// Origin of the nav mesh tile space.
-	float tileWidth, tileHeight;	// Width and height of each tile.
-	int maxTiles;					// Maximum number of tiles the navmesh can contain.
-	int maxPolys;					// Maximum number of polygons each tile can contain.
+	float orig[3];					///< The world space origin of the navigation mesh's tile space. [(x, y, z)]
+	float tileWidth;				///< The width of each tile. (Along the x-axis.)
+	float tileHeight;				///< The height of each tile. (Along the z-axis.)
+	int maxTiles;					///< The maximum number of tiles the navigation mesh can contain.
+	int maxPolys;					///< The maximum number of polygons each tile can contain.
 };
 
-
+/// A navigation mesh based on tiles of convex polygons.
+/// @ingroup detour
 class dtNavMesh
 {
 public:
 	dtNavMesh();
 	~dtNavMesh();
 
-	// Initializes the nav mesh for tiled use.
-	// Params:
-	//  params - (in) navmesh initialization params, see dtNavMeshParams.
-	// Returns: True if succeed, else false.
+	/// @{
+	/// @name Initialization and Tile Management
+
+	/// Initializes the navigation mesh for tiled use.
+	///  @param[in]	params		Initialization parameters.
+	/// @return The status flags for the operation.
 	dtStatus init(const dtNavMeshParams* params);
 
-	// Initializes the nav mesh for single tile use.
-	// Params:
-	//  data - (in) Data of the new tile mesh.
-	//  dataSize - (in) Data size of the new tile mesh.
-	//	flags - (in) Tile flags, see dtTileFlags.
-	// Returns: True if succeed, else false.
+	/// Initializes the navigation mesh for single tile use.
+	///  @param[in]	data		Data of the new tile. (See: #dtCreateNavMeshData)
+	///  @param[in]	dataSize	The data size of the new tile.
+	///  @param[in]	flags		The tile flags. (See: #dtTileFlags)
+	/// @return The status flags for the operation.
+	///  @see dtCreateNavMeshData
 	dtStatus init(unsigned char* data, const int dataSize, const int flags);
 	
-	// Returns pointer to navmesh initialization params.
+	/// The navigation mesh initialization params.
 	const dtNavMeshParams* getParams() const;
 
-	// Adds new tile into the navmesh.
-	// The add will fail if the data is in wrong format,
-	// there is not enough tiles left, or if there is a tile already at the location.
-	// Params:
-	//  data - (in) Data of the new tile mesh.
-	//  dataSize - (in) Data size of the new tile mesh.
-	//	flags - (in) Tile flags, see dtTileFlags.
-	//  lastRef - (in,optional) Last tile ref, the tile will be restored so that
-	//            the reference (as well as poly references) will be the same. Default: 0.
-	//  result - (out,optional) tile ref if the tile was succesfully added.
+	/// Adds a tile to the navigation mesh.
+	///  @param[in]		data		Data for the new tile mesh. (See: #dtCreateNavMeshData)
+	///  @param[in]		dataSize	Data size of the new tile mesh.
+	///  @param[in]		flags		Tile flags. (See: #dtTileFlags)
+	///  @param[in]		lastRef		The desired reference for the tile. (When reloading a tile.) [opt] [Default: 0]
+	///  @param[out]	result		The tile reference. (If the tile was succesfully added.) [opt]
+	/// @return The status flags for the operation.
 	dtStatus addTile(unsigned char* data, int dataSize, int flags, dtTileRef lastRef, dtTileRef* result);
-
-	// Removes specified tile.
-	// Params:
-	//  ref - (in) Reference to the tile to remove.
-	//  data - (out) Data associated with deleted tile.
-	//  dataSize - (out) Size of the data associated with deleted tile. 
+	
+	/// Removes the specified tile from the navigation mesh.
+	///  @param[in]		ref			The reference of the tile to remove.
+	///  @param[out]	data		Data associated with deleted tile.
+	///  @param[out]	dataSize	Size of the data associated with deleted tile.
+	/// @return The status flags for the operation.
 	dtStatus removeTile(dtTileRef ref, unsigned char** data, int* dataSize);
 
-	// Calculates tile location based in input world position.
-	// Params:
-	//  pos - (in) world position of the query.
-	//  tx - (out) tile x location.
-	//  ty - (out) tile y location.
+	/// @}
+
+	/// @{
+	/// @name Query Functions
+
+	/// Calculates the tile grid location for the specified world position.
+	///  @param[in]	pos  The world position for the query. [(x, y, z)]
+	///  @param[out]	tx		The tile's x-location. (x, y)
+	///  @param[out]	ty		The tile's y-location. (x, y)
 	void calcTileLoc(const float* pos, int* tx, int* ty) const;
 
-	// Returns pointer to tile at specified location.
-	// Params:
-	//  x,y - (in) Location of the tile to get.
-	// Returns: pointer to tile if tile exists or 0 tile does not exists.
-	const dtMeshTile* getTileAt(int x, int y) const;
+	/// Gets the tile at the specified grid location.
+	///  @param[in]	x		The tile's x-location. (x, y, layer)
+	///  @param[in]	y		The tile's y-location. (x, y, layer)
+	///  @param[in]	layer	The tile's layer. (x, y, layer)
+	/// @return The tile, or null if the tile does not exist.
+	const dtMeshTile* getTileAt(const int x, const int y, const int layer) const;
 
-	// Returns reference to tile at specified location.
-	// Params:
-	//  x,y - (in) Location of the tile to get.
-	// Returns: reference to tile if tile exists or 0 tile does not exists.
-	dtTileRef getTileRefAt(int x, int y) const;
+	/// Gets all tiles at the specified grid location. (All layers.)
+	///  @param[in]		x			The tile's x-location. (x, y)
+	///  @param[in]		y			The tile's y-location. (x, y)
+	///  @param[out]	tiles		A pointer to an array of tiles that will hold the result.
+	///  @param[in]		maxTiles	The maximum tiles the tiles parameter can hold.
+	/// @return The number of tiles returned in the tiles array.
+	int getTilesAt(const int x, const int y,
+				   dtMeshTile const** tiles, const int maxTiles) const;
 	
-	// Returns tile references of a tile based on tile pointer.
+	/// Gets the tile reference for the tile at specified grid location.
+	///  @param[in]	x		The tile's x-location. (x, y, layer)
+	///  @param[in]	y		The tile's y-location. (x, y, layer)
+	///  @param[in]	layer	The tile's layer. (x, y, layer)
+	/// @return The tile reference of the tile, or 0 if there is none.
+	dtTileRef getTileRefAt(int x, int y, int layer) const;
+
+	/// Gets the tile reference for the specified tile.
+	///  @param[in]	tile	The tile.
+	/// @return The tile reference of the tile.
 	dtTileRef getTileRef(const dtMeshTile* tile) const;
 
-	// Returns tile based on references.
+	/// Gets the tile for the specified tile reference.
+	///  @param[in]	ref		The tile reference of the tile to retrieve.
+	/// @return The tile for the specified reference, or null if the 
+	///		reference is invalid.
 	const dtMeshTile* getTileByRef(dtTileRef ref) const;
 	
-	// Returns max number of tiles.
+	/// The maximum number of tiles supported by the navigation mesh.
+	/// @return The maximum number of tiles supported by the navigation mesh.
 	int getMaxTiles() const;
 	
-	// Returns pointer to tile in the tile array.
-	// Params:
-	//  i - (in) Index to the tile to retrieve, max index is getMaxTiles()-1.
-	// Returns: Pointer to specified tile.
+	/// Gets the tile at the specified index.
+	///  @param[in]	i		The tile index. [Limit: 0 >= index < #getMaxTiles()]
+	/// @return The tile at the specified index.
 	const dtMeshTile* getTile(int i) const;
 
-	// Returns pointer to tile and polygon pointed by the polygon reference.
-	// Params:
-	//  ref - (in) reference to a polygon.
-	//  tile - (out) pointer to the tile containing the polygon.
-	//  poly - (out) pointer to the polygon.
+	/// Gets the tile and polygon for the specified polygon reference.
+	///  @param[in]		ref		The reference for the a polygon.
+	///  @param[out]	tile	The tile containing the polygon.
+	///  @param[out]	poly	The polygon.
+	/// @return The status flags for the operation.
 	dtStatus getTileAndPolyByRef(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const;
 	
-	// Returns pointer to tile and polygon pointed by the polygon reference.
-	// Note: this function does not check if 'ref' s valid, and is thus faster. Use only with valid refs!
-	// Params:
-	//  ref - (in) reference to a polygon.
-	//  tile - (out) pointer to the tile containing the polygon.
-	//  poly - (out) pointer to the polygon.
+	/// Returns the tile and polygon for the specified polygon reference.
+	///  @param[in]		ref		A known valid reference for a polygon.
+	///  @param[out]	tile	The tile containing the polygon.
+	///  @param[out]	poly	The polygon.
 	void getTileAndPolyByRefUnsafe(const dtPolyRef ref, const dtMeshTile** tile, const dtPoly** poly) const;
 
-	// Returns true if polygon reference points to valid data.
+	/// Checks the validity of a polygon reference.
+	///  @param[in]	ref		The polygon reference to check.
+	/// @return True if polygon reference is valid for the navigation mesh.
 	bool isValidPolyRef(dtPolyRef ref) const;
 	
-	// Returns base poly id for specified tile, polygon refs can be deducted from this.
+	/// Gets the polygon reference for the tile's base polygon.
+	///  @param[in]	tile		The tile.
+	/// @return The polygon reference for the base polygon in the specified tile.
 	dtPolyRef getPolyRefBase(const dtMeshTile* tile) const;
 	
-	// Returns start and end location of an off-mesh link polygon.
-	// Params:
-	//	prevRef - (in) ref to the polygon before the link (used to select direction).
-	//	polyRef - (in) ref to the off-mesh link polygon.
-	//	startPos[3] - (out) start point of the link.
-	//	endPos[3] - (out) end point of the link.
-	// Returns: true if link is found.
+	/// Gets the endpoints for an off-mesh connection, ordered by "direction of travel".
+	///  @param[in]		prevRef		The reference of the polygon before the connection.
+	///  @param[in]		polyRef		The reference of the off-mesh connection polygon.
+	///  @param[out]	startPos	The start position of the off-mesh connection. [(x, y, z)]
+	///  @param[out]	endPos		The end position of the off-mesh connection. [(x, y, z)]
+	/// @return The status flags for the operation.
 	dtStatus getOffMeshConnectionPolyEndPoints(dtPolyRef prevRef, dtPolyRef polyRef, float* startPos, float* endPos) const;
 
-	// Returns pointer to off-mesh connection based on polyref, or null if ref not valid.
+	/// Gets the specified off-mesh connection.
+	///  @param[in]	ref		The polygon reference of the off-mesh connection.
+	/// @return The specified off-mesh connection, or null if the polygon reference is not valid.
 	const dtOffMeshConnection* getOffMeshConnectionByRef(dtPolyRef ref) const;
 	
-	// Sets polygon flags.
+	/// @}
+
+	/// @{
+	/// @name State Management
+	/// These functions do not effect #dtTileRef or #dtPolyRef's. 
+
+	/// Sets the user defined flags for the specified polygon.
+	///  @param[in]	ref		The polygon reference.
+	///  @param[in]	flags	The new flags for the polygon.
+	/// @return The status flags for the operation.
 	dtStatus setPolyFlags(dtPolyRef ref, unsigned short flags);
 
-	// Return polygon flags.
+	/// Gets the user defined flags for the specified polygon.
+	///  @param[in]		ref				The polygon reference.
+	///  @param[out]	resultFlags		The polygon flags.
+	/// @return The status flags for the operation.
 	dtStatus getPolyFlags(dtPolyRef ref, unsigned short* resultFlags) const;
 
-	// Set polygon type.
+	/// Sets the user defined area for the specified polygon.
+	///  @param[in]	ref		The polygon reference.
+	///  @param[in]	area	The new area id for the polygon. [Limit: < #DT_MAX_AREAS]
+	/// @return The status flags for the operation.
 	dtStatus setPolyArea(dtPolyRef ref, unsigned char area);
 
-	// Return polygon area type.
+	/// Gets the user defined area for the specified polygon.
+	///  @param[in]		ref			The polygon reference.
+	///  @param[out]	resultArea	The area id for the polygon.
+	/// @return The status flags for the operation.
 	dtStatus getPolyArea(dtPolyRef ref, unsigned char* resultArea) const;
 
-
-	// Returns number of bytes required to store tile state.
+	/// Gets the size of the buffer required by #storeTileState to store the specified tile's state.
+	///  @param[in]	tile	The tile.
+	/// @return The size of the buffer required to store the state.
 	int getTileStateSize(const dtMeshTile* tile) const;
 	
-	// Stores tile state to buffer.
+	/// Stores the non-structural state of the tile in the specified buffer. (Flags, area ids, etc.)
+	///  @param[in]		tile			The tile.
+	///  @param[out]	data			The buffer to store the tile's state in.
+	///  @param[in]		maxDataSize		The size of the data buffer. [Limit: >= #getTileStateSize]
+	/// @return The status flags for the operation.
 	dtStatus storeTileState(const dtMeshTile* tile, unsigned char* data, const int maxDataSize) const;
 	
-	// Restores tile state.
+	/// Restores the state of the tile.
+	///  @param[in]	tile			The tile.
+	///  @param[in]	data			The new state. (Obtained from #storeTileState.)
+	///  @param[in]	maxDataSize		The size of the state within the data buffer.
+	/// @return The status flags for the operation.
 	dtStatus restoreTileState(dtMeshTile* tile, const unsigned char* data, const int maxDataSize);
 	
+	/// @}
 
-	// Encodes a tile id.
+	/// @{
+	/// @name Encoding and Decoding
+	/// These functions are generally meant for internal use only.
+
+	/// Derives a standard polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	salt	The tile's salt value.
+	///  @param[in]	it		The index of the tile.
+	///  @param[in]	ip		The index of the polygon within the tile.
 	inline dtPolyRef encodePolyId(unsigned int salt, unsigned int it, unsigned int ip) const
 	{
 		return ((dtPolyRef)salt << (m_polyBits+m_tileBits)) | ((dtPolyRef)it << m_polyBits) | (dtPolyRef)ip;
 	}
 	
-	// Decodes a tile id.
+	/// Decodes a standard polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	ref   The polygon reference to decode.
+	///  @param[out]	salt	The tile's salt value.
+	///  @param[out]	it		The index of the tile.
+	///  @param[out]	ip		The index of the polygon within the tile.
+	///  @see #encodePolyId
 	inline void decodePolyId(dtPolyRef ref, unsigned int& salt, unsigned int& it, unsigned int& ip) const
 	{
 		const dtPolyRef saltMask = ((dtPolyRef)1<<m_saltBits)-1;
@@ -346,81 +485,201 @@
 		ip = (unsigned int)(ref & polyMask);
 	}
 
-	// Decodes a tile salt.
+	/// Extracts a tile's salt value from the specified polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	ref		The polygon reference.
+	///  @see #encodePolyId
 	inline unsigned int decodePolyIdSalt(dtPolyRef ref) const
 	{
 		const dtPolyRef saltMask = ((dtPolyRef)1<<m_saltBits)-1;
 		return (unsigned int)((ref >> (m_polyBits+m_tileBits)) & saltMask);
 	}
 	
-	// Decodes a tile id.
+	/// Extracts the tile's index from the specified polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	ref		The polygon reference.
+	///  @see #encodePolyId
 	inline unsigned int decodePolyIdTile(dtPolyRef ref) const
 	{
 		const dtPolyRef tileMask = ((dtPolyRef)1<<m_tileBits)-1;
 		return (unsigned int)((ref >> m_polyBits) & tileMask);
 	}
 	
-	// Decodes a poly id.
+	/// Extracts the polygon's index (within its tile) from the specified polygon reference.
+	///  @note This function is generally meant for internal use only.
+	///  @param[in]	ref		The polygon reference.
+	///  @see #encodePolyId
 	inline unsigned int decodePolyIdPoly(dtPolyRef ref) const
 	{
 		const dtPolyRef polyMask = ((dtPolyRef)1<<m_polyBits)-1;
 		return (unsigned int)(ref & polyMask);
 	}
+
+	/// @}
 	
 private:
 
-	// Returns pointer to tile in the tile array.
+	/// Returns pointer to tile in the tile array.
 	dtMeshTile* getTile(int i);
 
-	// Returns neighbour tile based on side. 
-	dtMeshTile* getNeighbourTileAt(int x, int y, int side) const;
-	// Returns all polygons in neighbour tile based on portal defined by the segment.
+	/// Returns neighbour tile based on side.
+	int getTilesAt(const int x, const int y,
+				   dtMeshTile** tiles, const int maxTiles) const;
+
+	/// Returns neighbour tile based on side.
+	int getNeighbourTilesAt(const int x, const int y, const int side,
+							dtMeshTile** tiles, const int maxTiles) const;
+	
+	/// Returns all polygons in neighbour tile based on portal defined by the segment.
 	int findConnectingPolys(const float* va, const float* vb,
 							const dtMeshTile* tile, int side,
 							dtPolyRef* con, float* conarea, int maxcon) const;
 	
-	// Builds internal polygons links for a tile.
+	/// Builds internal polygons links for a tile.
 	void connectIntLinks(dtMeshTile* tile);
-	// Builds internal polygons links for a tile.
+	/// Builds internal polygons links for a tile.
 	void connectIntOffMeshLinks(dtMeshTile* tile);
 
-	// Builds external polygon links for a tile.
+	/// Builds external polygon links for a tile.
 	void connectExtLinks(dtMeshTile* tile, dtMeshTile* target, int side);
-	// Builds external polygon links for a tile.
+	/// Builds external polygon links for a tile.
 	void connectExtOffMeshLinks(dtMeshTile* tile, dtMeshTile* target, int side);
 	
-	// Removes external links at specified side.
-	void unconnectExtLinks(dtMeshTile* tile, int side);
+	/// Removes external links at specified side.
+	void unconnectExtLinks(dtMeshTile* tile, dtMeshTile* target);
 	
+
 	// TODO: These methods are duplicates from dtNavMeshQuery, but are needed for off-mesh connection finding.
+	
+	/// Queries polygons within a tile.
+	int queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax,
+							dtPolyRef* polys, const int maxPolys) const;
+	/// Find nearest polygon within a tile.
+	dtPolyRef findNearestPolyInTile(const dtMeshTile* tile, const float* center,
+									const float* extents, float* nearestPt) const;
+	/// Returns closest point on polygon.
+	void closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip,
+								  const float* pos, float* closest) const;
+	
+	dtNavMeshParams m_params;			///< Current initialization params. TODO: do not store this info twice.
+	float m_orig[3];					///< Origin of the tile (0,0)
+	float m_tileWidth, m_tileHeight;	///< Dimensions of each tile.
+	int m_maxTiles;						///< Max number of tiles.
+	int m_tileLutSize;					///< Tile hash lookup size (must be pot).
+	int m_tileLutMask;					///< Tile hash lookup mask.
 
-	// Queries polygons within a tile.
-	int queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax, dtPolyRef* polys, const int maxPolys);
+	dtMeshTile** m_posLookup;			///< Tile hash lookup.
+	dtMeshTile* m_nextFree;				///< Freelist of tiles.
+	dtMeshTile* m_tiles;				///< List of tiles.
+		
+	unsigned int m_saltBits;			///< Number of salt bits in the tile ID.
+	unsigned int m_tileBits;			///< Number of tile bits in the tile ID.
+	unsigned int m_polyBits;			///< Number of poly bits in the tile ID.
+};
 
-	// Find nearest polygon within a tile.
-	dtPolyRef findNearestPolyInTile(const dtMeshTile* tile, const float* center, const float* extents, float* nearestPt);
+/// Allocates a navigation mesh object using the Detour allocator.
+/// @return A navigation mesh that is ready for initialization, or null on failure.
+///  @ingroup detour
+dtNavMesh* mallocNavMesh();
 
-	// Returns closest point on polygon.
-	dtStatus closestPointOnPolyInTile(const dtMeshTile* tile, unsigned int ip, const float* pos, float* closest);
+/// Frees the specified navigation mesh object using the Detour allocator.
+///  @param[in]	navmesh		A navigation mesh allocated using #mallocNavMesh
+///  @ingroup detour
+void freeNavMesh(dtNavMesh* navmesh);
 
-	dtNavMeshParams m_params;			// Current initialization params. TODO: do not store this info twice.
-	float m_orig[3];					// Origin of the tile (0,0)
-	float m_tileWidth, m_tileHeight;	// Dimensions of each tile.
-	int m_maxTiles;						// Max number of tiles.
-	int m_tileLutSize;					// Tile hash lookup size (must be pot).
-	int m_tileLutMask;					// Tile hash lookup mask.
+#endif // DETOURNAVMESH_H
 
-	dtMeshTile** m_posLookup;			// Tile hash lookup.
-	dtMeshTile* m_nextFree;				// Freelist of tiles.
-	dtMeshTile* m_tiles;				// List of tiles.
+///////////////////////////////////////////////////////////////////////////
 
-	unsigned int m_saltBits;			// Number of salt bits in the tile ID.
-	unsigned int m_tileBits;			// Number of tile bits in the tile ID.
-	unsigned int m_polyBits;			// Number of poly bits in the tile ID.
-};
+// This section contains detailed documentation for members that don't have
+// a source file. It reduces clutter in the main section of the header.
 
-// Helper function to allocate navmesh class using Detour allocator.
-dtNavMesh* mallocNavMesh();
-void freeNavMesh(dtNavMesh* navmesh);
+/**
 
-#endif // DETOURNAVMESH_H
+@typedef dtPolyRef
+@par
+
+Polygon references are subject to the same invalidate/preserve/restore 
+rules that apply to #dtTileRef's.  If the #dtTileRef for the polygon's
+tile changes, the polygon reference becomes invalid.
+
+Changing a polygon's flags, area id, etc. does not impact its polygon
+reference.
+
+@typedef dtTileRef
+@par
+
+The following changes will invalidate a tile reference:
+
+- The referenced tile has been removed from the navigation mesh.
+- The navigation mesh has been initialized using a different set
+  of #dtNavMeshParams.
+
+A tile reference is preserved/restored if the tile is added to a navigation 
+mesh initialized with the original #dtNavMeshParams and is added at the
+original reference location. (E.g. The lastRef parameter is used with
+dtNavMesh::addTile.)
+
+Basically, if the storage structure of a tile changes, its associated
+tile reference changes.
+
+
+@var unsigned short dtPoly::neis[DT_VERTS_PER_POLYGON]
+@par
+
+Each entry represents data for the edge starting at the vertex of the same index. 
+E.g. The entry at index n represents the edge data for vertex[n] to vertex[n+1].
+
+A value of zero indicates the edge has no polygon connection. (It makes up the 
+border of the navigation mesh.)
+
+The information can be extracted as follows: 
+@code 
+neighborRef = neis[n] & 0xff; // Get the neighbor polygon reference.
+
+if (neis[n] & #DT_EX_LINK)
+{
+    // The edge is an external (portal) edge.
+}
+@endcode
+
+@var float dtMeshHeader::bvQuantFactor
+@par
+
+This value is used for converting between world and bounding volume coordinates.
+For example:
+@code
+const float cs = 1.0f / tile->header->bvQuantFactor;
+const dtBVNode* n = &tile->bvTree[i];
+if (n->i >= 0)
+{
+    // This is a leaf node.
+    float worldMinX = tile->header->bmin[0] + n->bmin[0]*cs;
+    float worldMinY = tile->header->bmin[0] + n->bmin[1]*cs;
+    // Etc...
+}
+@endcode
+
+@struct dtMeshTile
+@par
+
+Tiles generally only exist within the context of a dtNavMesh object.
+
+Some tile content is optional.  For example, a tile may not contain any
+off-mesh connections.  In this case the associated pointer will be null.
+
+If a detail mesh exists it will share vertices with the base polygon mesh.  
+Only the vertices unique to the detail mesh will be stored in #detailVerts.
+
+@warning Tiles returned by a dtNavMesh object are not guarenteed to be populated.
+For example: The tile at a location might not have been loaded yet, or may have been removed.
+In this case, pointers will be null.  So if in doubt, check the polygon count in the 
+tile's header to determine if a tile has polygons defined.
+
+@var float dtOffMeshConnection::pos[6]
+@par
+
+For a properly built navigation mesh, vertex A will always be within the bounds of the mesh. 
+Vertex B is not required to be within the bounds of the mesh.
+
+*/
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.cpp	(working copy)
@@ -247,8 +247,6 @@
 		return false;
 	if (!params->polyCount || !params->polys)
 		return false;
-	if (!params->detailMeshes || !params->detailVerts || !params->detailTris)
-		return false;
 
 	const int nvp = params->nvp;
 	
@@ -293,23 +291,13 @@
 		for (int j = 0; j < nvp; ++j)
 		{
 			if (p[j] == MESH_NULL_IDX) break;
-			int nj = j+1;
-			if (nj >= nvp || p[nj] == MESH_NULL_IDX) nj = 0;
-			const unsigned short* va = &params->verts[p[j]*3];
-			const unsigned short* vb = &params->verts[p[nj]*3];
-			
 			edgeCount++;
 			
-			if (params->tileSize > 0)
+			if (p[nvp+j] & 0x8000)
 			{
-				if (va[0] == params->tileSize && vb[0] == params->tileSize)
-					portalCount++; // x+
-				else if (va[2] == params->tileSize && vb[2] == params->tileSize)
-					portalCount++; // z+
-				else if (va[0] == 0 && vb[0] == 0)
-					portalCount++; // x-
-				else if (va[2] == 0 && vb[2] == 0)
-					portalCount++; // z-
+				unsigned short dir = p[nvp+j] & 0xf;
+				if (dir != 0xf)
+					portalCount++;
 			}
 		}
 	}
@@ -318,19 +306,42 @@
 	
 	// Find unique detail vertices.
 	int uniqueDetailVertCount = 0;
-	for (int i = 0; i < params->polyCount; ++i)
+	int detailTriCount = 0;
+	if (params->detailMeshes)
 	{
-		const unsigned short* p = &params->polys[i*nvp*2];
-		int ndv = params->detailMeshes[i*4+1];
-		int nv = 0;
-		for (int j = 0; j < nvp; ++j)
+		// Has detail mesh, count unique detail vertex count and use input detail tri count.
+		detailTriCount = params->detailTriCount;
+		for (int i = 0; i < params->polyCount; ++i)
 		{
-			if (p[j] == MESH_NULL_IDX) break;
-			nv++;
+			const unsigned short* p = &params->polys[i*nvp*2];
+			int ndv = params->detailMeshes[i*4+1];
+			int nv = 0;
+			for (int j = 0; j < nvp; ++j)
+			{
+				if (p[j] == MESH_NULL_IDX) break;
+				nv++;
+			}
+			ndv -= nv;
+			uniqueDetailVertCount += ndv;
 		}
-		ndv -= nv;
-		uniqueDetailVertCount += ndv;
 	}
+	else
+	{
+		// No input detail mesh, build detail mesh from nav polys.
+		uniqueDetailVertCount = 0; // No extra detail verts.
+		detailTriCount = 0;
+		for (int i = 0; i < params->polyCount; ++i)
+		{
+			const unsigned short* p = &params->polys[i*nvp*2];
+			int nv = 0;
+			for (int j = 0; j < nvp; ++j)
+			{
+				if (p[j] == MESH_NULL_IDX) break;
+				nv++;
+			}
+			detailTriCount += nv-2;
+		}
+	}
 	
 	// Calculate data size
 	const int headerSize = dtAlign4(sizeof(dtMeshHeader));
@@ -339,8 +350,8 @@
 	const int linksSize = dtAlign4(sizeof(dtLink)*maxLinkCount);
 	const int detailMeshesSize = dtAlign4(sizeof(dtPolyDetail)*params->polyCount);
 	const int detailVertsSize = dtAlign4(sizeof(float)*3*uniqueDetailVertCount);
-	const int detailTrisSize = dtAlign4(sizeof(unsigned char)*4*params->detailTriCount);
-	const int bvTreeSize = dtAlign4(sizeof(dtBVNode)*params->polyCount*2);
+	const int detailTrisSize = dtAlign4(sizeof(unsigned char)*4*detailTriCount);
+	const int bvTreeSize = params->buildBvTree ? dtAlign4(sizeof(dtBVNode)*params->polyCount*2) : 0;
 	const int offMeshConsSize = dtAlign4(sizeof(dtOffMeshConnection)*storedOffMeshConCount);
 	
 	const int dataSize = headerSize + vertsSize + polysSize + linksSize +
@@ -372,6 +383,7 @@
 	header->version = DT_NAVMESH_VERSION;
 	header->x = params->tileX;
 	header->y = params->tileY;
+	header->layer = params->tileLayer;
 	header->userId = params->userId;
 	header->polyCount = totPolyCount;
 	header->vertCount = totVertCount;
@@ -380,14 +392,14 @@
 	dtVcopy(header->bmax, params->bmax);
 	header->detailMeshCount = params->polyCount;
 	header->detailVertCount = uniqueDetailVertCount;
-	header->detailTriCount = params->detailTriCount;
+	header->detailTriCount = detailTriCount;
 	header->bvQuantFactor = 1.0f / params->cs;
 	header->offMeshBase = params->polyCount;
 	header->walkableHeight = params->walkableHeight;
 	header->walkableRadius = params->walkableRadius;
 	header->walkableClimb = params->walkableClimb;
 	header->offMeshConCount = storedOffMeshConCount;
-	header->bvNodeCount = params->polyCount*2;
+	header->bvNodeCount = params->buildBvTree ? params->polyCount*2 : 0;
 	
 	const int offMeshVertsBase = params->vertCount;
 	const int offMeshPolyBase = params->polyCount;
@@ -416,7 +428,7 @@
 			n++;
 		}
 	}
-
+	
 	// Store polygons
 	// Mesh polys
 	const unsigned short* src = params->polys;
@@ -431,7 +443,27 @@
 		{
 			if (src[j] == MESH_NULL_IDX) break;
 			p->verts[j] = src[j];
-			p->neis[j] = (src[nvp+j]+1) & 0xffff;
+			if (src[nvp+j] & 0x8000)
+			{
+				// Border or portal edge.
+				unsigned short dir = src[nvp+j] & 0xf;
+				if (dir == 0xf) // Border
+					p->neis[j] = 0;
+				else if (dir == 0) // Portal x-
+					p->neis[j] = DT_EXT_LINK | 4;
+				else if (dir == 1) // Portal z+
+					p->neis[j] = DT_EXT_LINK | 2;
+				else if (dir == 2) // Portal x+
+					p->neis[j] = DT_EXT_LINK | 0;
+				else if (dir == 3) // Portal z-
+					p->neis[j] = DT_EXT_LINK | 6;
+			}
+			else
+			{
+				// Normal connection
+				p->neis[j] = src[nvp+j]+1;
+			}
+			
 			p->vertCount++;
 		}
 		src += nvp*2;
@@ -453,61 +485,68 @@
 			n++;
 		}
 	}
-	
-	// Store portal edges.
-	if (params->tileSize > 0)
+
+	// Store detail meshes and vertices.
+	// The nav polygon vertices are stored as the first vertices on each mesh.
+	// We compress the mesh data by skipping them and using the navmesh coordinates.
+	if (params->detailMeshes)
 	{
+		unsigned short vbase = 0;
 		for (int i = 0; i < params->polyCount; ++i)
 		{
-			dtPoly* poly = &navPolys[i];
-			for (int j = 0; j < poly->vertCount; ++j)
+			dtPolyDetail& dtl = navDMeshes[i];
+			const int vb = (int)params->detailMeshes[i*4+0];
+			const int ndv = (int)params->detailMeshes[i*4+1];
+			const int nv = navPolys[i].vertCount;
+			dtl.vertBase = (unsigned int)vbase;
+			dtl.vertCount = (unsigned char)(ndv-nv);
+			dtl.triBase = (unsigned int)params->detailMeshes[i*4+2];
+			dtl.triCount = (unsigned char)params->detailMeshes[i*4+3];
+			// Copy vertices except the first 'nv' verts which are equal to nav poly verts.
+			if (ndv-nv)
 			{
-				int nj = j+1;
-				if (nj >= poly->vertCount) nj = 0;
-
-				const unsigned short* va = &params->verts[poly->verts[j]*3];
-				const unsigned short* vb = &params->verts[poly->verts[nj]*3];
-							
-				if (va[0] == params->tileSize && vb[0] == params->tileSize) // x+
-					poly->neis[j] = DT_EXT_LINK | 0;
-				else if (va[2] == params->tileSize && vb[2]  == params->tileSize) // z+
-					poly->neis[j] = DT_EXT_LINK | 2;
-				else if (va[0] == 0 && vb[0] == 0) // x-
-					poly->neis[j] = DT_EXT_LINK | 4;
-				else if (va[2] == 0 && vb[2] == 0) // z-
-					poly->neis[j] = DT_EXT_LINK | 6;
+				memcpy(&navDVerts[vbase*3], &params->detailVerts[(vb+nv)*3], sizeof(float)*3*(ndv-nv));
+				vbase += (unsigned short)(ndv-nv);
 			}
 		}
+		// Store triangles.
+		memcpy(navDTris, params->detailTris, sizeof(unsigned char)*4*params->detailTriCount);
 	}
-
-	// Store detail meshes and vertices.
-	// The nav polygon vertices are stored as the first vertices on each mesh.
-	// We compress the mesh data by skipping them and using the navmesh coordinates.
-	unsigned short vbase = 0;
-	for (int i = 0; i < params->polyCount; ++i)
+	else
 	{
-		dtPolyDetail& dtl = navDMeshes[i];
-		const int vb = (int)params->detailMeshes[i*4+0];
-		const int ndv = (int)params->detailMeshes[i*4+1];
-		const int nv = navPolys[i].vertCount;
-		dtl.vertBase = (unsigned int)vbase;
-		dtl.vertCount = (unsigned char)(ndv-nv);
-		dtl.triBase = (unsigned int)params->detailMeshes[i*4+2];
-		dtl.triCount = (unsigned char)params->detailMeshes[i*4+3];
-		// Copy vertices except the first 'nv' verts which are equal to nav poly verts.
-		if (ndv-nv)
+		// Create dummy detail mesh by triangulating polys.
+		int tbase = 0;
+		for (int i = 0; i < params->polyCount; ++i)
 		{
-			memcpy(&navDVerts[vbase*3], &params->detailVerts[(vb+nv)*3], sizeof(float)*3*(ndv-nv));
-			vbase += (unsigned short)(ndv-nv);
+			dtPolyDetail& dtl = navDMeshes[i];
+			const int nv = navPolys[i].vertCount;
+			dtl.vertBase = 0;
+			dtl.vertCount = 0;
+			dtl.triBase = (unsigned int)tbase;
+			dtl.triCount = (unsigned char)(nv-2);
+			// Triangulate polygon (local indices).
+			for (int j = 2; j < nv; ++j)
+			{
+				unsigned char* t = &navDTris[tbase*4];
+				t[0] = 0;
+				t[1] = (unsigned char)(j-1);
+				t[2] = (unsigned char)j;
+				// Bit for each edge that belongs to poly boundary.
+				t[3] = (1<<2);
+				if (j == 2) t[3] |= (1<<0);
+				if (j == nv-1) t[3] |= (1<<4);
+				tbase++;
+			}
 		}
 	}
-	// Store triangles.
-	memcpy(navDTris, params->detailTris, sizeof(unsigned char)*4*params->detailTriCount);
 
 	// Store and create BVtree.
 	// TODO: take detail mesh into account! use byte per bbox extent?
-	createBVTree(params->verts, params->vertCount, params->polys, params->polyCount,
-				 nvp, params->cs, params->ch, params->polyCount*2, navBvtree);
+	if (params->buildBvTree)
+	{
+		createBVTree(params->verts, params->vertCount, params->polys, params->polyCount,
+					 nvp, params->cs, params->ch, params->polyCount*2, navBvtree);
+	}
 	
 	// Store Off-Mesh connections.
 	n = 0;
@@ -595,6 +634,7 @@
 	swapEndian(&header->version);
 	swapEndian(&header->x);
 	swapEndian(&header->y);
+	swapEndian(&header->layer);
 	swapEndian(&header->userId);
 	swapEndian(&header->polyCount);
 	swapEndian(&header->vertCount);
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.h	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshBuilder.h	(working copy)
@@ -21,56 +21,74 @@
 
 #include "../../Common.h"
 
-// The units of the parameters are specified in parenthesis as follows:
-// (vx) voxels, (wu) world units
+
+/// The units of the parameters are specified in parenthesis as follows:
+/// (vx) voxels, (wu) world units
 struct dtNavMeshCreateParams
 {
-	// Navmesh vertices.
-	const unsigned short* verts;			// Array of vertices, each vertex has 3 components. (vx).
-	int vertCount;							// Vertex count
-	// Navmesh polygons
-	const unsigned short* polys;			// Array of polygons, uses same format as rcPolyMesh. 
-	const unsigned short* polyFlags;		// Array of flags per polygon.
-	const unsigned char* polyAreas;			// Array of area ids per polygon.
-	int polyCount;							// Number of polygons
-	int nvp;								// Number of verts per polygon.
-	// Navmesh Detail
-	const unsigned int* detailMeshes;		// Detail meshes, uses same format as rcPolyMeshDetail.
-	const float* detailVerts;				// Detail mesh vertices, uses same format as rcPolyMeshDetail (wu).
-	int detailVertsCount;					// Total number of detail vertices
-	const unsigned char* detailTris;		// Array of detail tris per detail mesh.
-	int detailTriCount;						// Total number of detail triangles.
-	// Off-Mesh Connections.
-	const float* offMeshConVerts;			// Off-mesh connection vertices (wu).
-	const float* offMeshConRad;				// Off-mesh connection radii (wu).
-	const unsigned short* offMeshConFlags;	// Off-mesh connection flags.
-	const unsigned char* offMeshConAreas;	// Off-mesh connection area ids.
-	const unsigned char* offMeshConDir;		// Off-mesh connection direction flags (1 = bidir, 0 = oneway).
-	const unsigned int* offMeshConUserID;	// Off-mesh connection user id (optional).
-	int offMeshConCount;					// Number of off-mesh connections
-	// Tile location
-	unsigned int userId;					// User ID bound to the tile.
-	int tileX, tileY;						// Tile location (tile coords).
-	float bmin[3], bmax[3];					// Tile bounds (wu).
-	// Settings
-	float walkableHeight;					// Agent height (wu).
-	float walkableRadius;					// Agent radius (wu).
-	float walkableClimb;					// Agent max climb (wu).
-	float cs;								// Cell size (xz) (wu).
-	float ch;								// Cell height (y) (wu).
-	int tileSize;							// Tile size (width & height) (vx).
+	/// @name Navmesh vertices.
+	///@{
+	const unsigned short* verts;			///< Array of vertices, each vertex has 3 components. (vx).
+	int vertCount;							///< Vertex count
+	///@{
+
+	/// @name Navmesh polygons
+	///@{
+	const unsigned short* polys;			///< Array of polygons, uses same format as rcPolyMesh.
+	const unsigned short* polyFlags;		///< Array of flags per polygon.
+	const unsigned char* polyAreas;			///< Array of area ids per polygon.
+	int polyCount;							///< Number of polygons
+	int nvp;								///< Number of verts per polygon.
+	///@}
+
+	/// @name Navmesh Detail (optional)
+	///@{
+	const unsigned int* detailMeshes;		///< Detail meshes, uses same format as rcPolyMeshDetail.
+	const float* detailVerts;				///< Detail mesh vertices, uses same format as rcPolyMeshDetail (wu).
+	int detailVertsCount;					///< Total number of detail vertices
+	const unsigned char* detailTris;		///< Array of detail tris per detail mesh.
+	int detailTriCount;						///< Total number of detail triangles.
+	///@}
+
+	/// @name Off-Mesh Connections.
+	///@{
+	const float* offMeshConVerts;			///< Off-mesh connection vertices (wu).
+	const float* offMeshConRad;				///< Off-mesh connection radii (wu).
+	const unsigned short* offMeshConFlags;	///< Off-mesh connection flags.
+	const unsigned char* offMeshConAreas;	///< Off-mesh connection area ids.
+	const unsigned char* offMeshConDir;		///< Off-mesh connection direction flags (1 = bidir, 0 = oneway).
+	const unsigned int* offMeshConUserID;	///< Off-mesh connection user id (optional).
+	int offMeshConCount;					///< Number of off-mesh connections
+	///@}
+
+	/// @name Tile location
+	///@{
+	unsigned int userId;					///< User ID bound to the tile.
+	int tileX, tileY, tileLayer;			///< Tile location (tile coords).
+	float bmin[3], bmax[3];					///< Tile bounds (wu).
+	///@}
+
+	/// @name Settings
+	///@{
+	float walkableHeight;					///< Agent height (wu).
+	float walkableRadius;					///< Agent radius (wu).
+	float walkableClimb;					///< Agent max climb (wu).
+	float cs;								///< Cell size (xz) (wu).
+	float ch;								///< Cell height (y) (wu).
+	bool buildBvTree;						///< Flag indicating if BVTree for polygon query should be build.
+	///@}
 };
 
-// Build navmesh data from given input data.
+/// Build navmesh data from given input data.
 bool dtCreateNavMeshData(dtNavMeshCreateParams* params, unsigned char** outData, int* outDataSize);
 
-// Swaps endianess of navmesh header.
+/// Swaps endianess of navmesh header.
 bool dtNavMeshHeaderSwapEndian(unsigned char* data, const int dataSize);
 
-// Swaps endianess of the navmesh data. This function assumes that the header is in correct
-// endianess already. Call dtNavMeshHeaderSwapEndian() first on the data if the data is
-// assumed to be in wrong endianess to start with. If converting from native endianess to foreign,
-// call dtNavMeshHeaderSwapEndian() after the data has been swapped.
+/// Swaps endianess of the navmesh data. This function assumes that the header is in correct
+/// endianess already. Call dtNavMeshHeaderSwapEndian() first on the data if the data is
+/// assumed to be in wrong endianess to start with. If converting from native endianess to foreign,
+/// call dtNavMeshHeaderSwapEndian() after the data has been swapped.
 bool dtNavMeshDataSwapEndian(unsigned char* data, const int dataSize);
 
 #endif // DETOURNAVMESHBUILDER_H
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.cpp	(working copy)
@@ -22,6 +22,39 @@
 #include "DetourCommon.h"
 #include "../../Common.h"
 
+/// @class dtQueryFilter
+///
+/// <b>The Default Implmentation</b>
+/// 
+/// At construction: All area costs default to 1.0.  All flags are included
+/// and none are excluded.
+/// 
+/// If a polygon has both an include and an exclude flag, it will be excluded.
+/// 
+/// The way filtering works, a navigation mesh polygon must have at least one flag 
+/// set to ever be considered by a query. So a polygon with no flags will never
+/// be considered.
+///
+/// Setting the include flags to 0 will result in all polygons being excluded.
+///
+/// <b>Custom Implementations</b>
+/// 
+/// DT_VIRTUAL_QUERYFILTER must be defined in order to extend this class.
+/// 
+/// Implement a custom query filter by overriding the virtual passFilter() 
+/// and getCost() functions. If this is done, both functions should be as 
+/// fast as possible. Use cached local copies of data rather than accessing 
+/// your own objects where possible.
+/// 
+/// Custom implementations do not need to adhere to the flags or cost logic 
+/// used by the default implementation.  
+/// 
+/// In order for A* searches to work properly, the cost should be proportional to
+/// the travel distance. Implementing a cost modifier less than 1.0 is likely 
+/// to lead to problems during pathfinding.
+///
+/// @see dtNavMeshQuery
+
 dtQueryFilter::dtQueryFilter() :
 	m_includeFlags(0xffff),
 	m_excludeFlags(0)
@@ -60,9 +93,10 @@
 {
 	return dtVdist(pa, pb) * m_areaCost[curPoly->getArea()];
 }
-#endif
+#endif	
+	
+static const float H_SCALE = 0.999f; // Search heuristic scale.
 
-static const float H_SCALE = 2.0f; // Search heuristic scale.
 
 dtNavMeshQuery* mallocNavMeshQuery()
 {
@@ -79,7 +113,25 @@
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
+
+/// @class dtNavMeshQuery
+///
+/// For methods that support undersized buffers, if the buffer is too small 
+/// to hold the entire result set the return status of the method will include 
+/// the #DT_BUFFER_TOO_SMALL flag.
+///
+/// Constant member functions can be used by multiple clients without side
+/// effects. (E.g. No change to the closed list. No impact on an in-progress
+/// sliced path query. Etc.)
+/// 
+/// Walls and portals: A @e wall is a polygon segment that is 
+/// considered impassable. A @e portal is a passable segment between polygons.
+/// A portal may be treated as a wall based on the dtQueryFilter used for a query.
+///
+/// @see dtNavMesh, dtQueryFilter, #mallocNavMeshQuery(), #mallocNavMeshQuery()
+
 dtNavMeshQuery::dtNavMeshQuery() :
+	m_nav(0),
 	m_tinyNodePool(0),
 	m_nodePool(0),
 	m_openList(0)
@@ -100,6 +152,12 @@
 	free(m_openList);
 }
 
+/// @par 
+///
+/// Must be the first function called after construction, before other
+/// functions are used.
+///
+/// This function can be used multiple times.
 dtStatus dtNavMeshQuery::init(const dtNavMesh* nav, const int maxNodes)
 {
 	m_nav = nav;
@@ -114,7 +172,7 @@
 		}
 		m_nodePool = new (malloc(sizeof(dtNodePool))) dtNodePool(maxNodes, dtNextPow2(maxNodes/4));
 		if (!m_nodePool)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 	}
 	else
 	{
@@ -125,7 +183,7 @@
 	{
 		m_tinyNodePool = new (malloc(sizeof(dtNodePool))) dtNodePool(64, 32);
 		if (!m_tinyNodePool)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 	}
 	else
 	{
@@ -143,7 +201,7 @@
 		}
 		m_openList = new (malloc(sizeof(dtNodeQueue))) dtNodeQueue(maxNodes);
 		if (!m_openList)
-			return DT_FAILURE_OUT_OF_MEMORY;
+			return DT_FAILURE | DT_OUT_OF_MEMORY;
 	}
 	else
 	{
@@ -154,21 +212,32 @@
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
+
+/// @par
+///
+/// Uses the detail polygons to find the surface height. (Most accurate.)
+///
+/// @p pos does not have to be within the bounds of the polygon or navigation mesh.
+///
+/// See closestPointOnPolyBoundary() for a limited but faster option.
+///
 dtStatus dtNavMeshQuery::closestPointOnPoly(dtPolyRef ref, const float* pos, float* closest) const
 {
 	ASSERT(m_nav);
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
-	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
-		return DT_FAILURE;
-	if (!tile) return DT_FAILURE;
-	if (closestPointOnPolyInTile(tile, poly, pos, closest) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
+	if (!tile)
+		return DT_FAILURE | DT_INVALID_PARAM;
+	
+	closestPointOnPolyInTile(tile, poly, pos, closest);
+	
 	return DT_SUCCESS;
 }
 
-dtStatus dtNavMeshQuery::closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly,
-												  const float* pos, float* closest) const
+void dtNavMeshQuery::closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly,
+											  const float* pos, float* closest) const
 {
 	const unsigned int ip = (unsigned int)(poly - tile->polys);
 	const dtPolyDetail* pd = &tile->detailMeshes[ip];
@@ -246,18 +315,27 @@
 			closestDistSqr = d;
 		}
 	}
-	
-	return DT_SUCCESS;
 }
 
+/// @par
+///
+/// Much faster than closestPointOnPoly().
+///
+/// If the provided position lies within the polygon's xz-bounds (above or below), 
+/// then @p pos and @p closest will be equal.
+///
+/// The height of @p closest will be the polygon boundary.  The height detail is not used.
+/// 
+/// @p pos does not have to be within the bounds of the polybon or the navigation mesh.
+/// 
 dtStatus dtNavMeshQuery::closestPointOnPolyBoundary(dtPolyRef ref, const float* pos, float* closest) const
 {
 	ASSERT(m_nav);
 	
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
-	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	// Collect vertices.
 	float verts[DT_VERTS_PER_POLYGON*3];	
@@ -297,15 +375,19 @@
 	return DT_SUCCESS;
 }
 
-
+/// @par
+///
+/// Will return #DT_FAILURE if the provided position is outside the xz-bounds 
+/// of the polygon.
+/// 
 dtStatus dtNavMeshQuery::getPolyHeight(dtPolyRef ref, const float* pos, float* height) const
 {
 	ASSERT(m_nav);
 
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
-	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	if (poly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
 	{
@@ -343,9 +425,18 @@
 		}
 	}
 	
-	return DT_FAILURE;
+	return DT_FAILURE | DT_INVALID_PARAM;
 }
 
+/// @par 
+///
+/// @note If the search box does not intersect any polygons the search will 
+/// return #DT_SUCCESS, but @p nearestRef will be zero. So if in doubt, check 
+/// @p nearestRef before using @p nearestPt.
+///
+/// @warning This function is not suitable for large area searches.  If the search
+/// extents overlaps more than 128 polygons it may return an invalid result.
+///
 dtStatus dtNavMeshQuery::findNearestPoly(const float* center, const float* extents,
 										 const dtQueryFilter* filter,
 										 dtPolyRef* nearestRef, float* nearestPt) const
@@ -357,8 +448,8 @@
 	// Get nearby polygons from proximity grid.
 	dtPolyRef polys[128];
 	int polyCount = 0;
-	if (queryPolygons(center, extents, filter, polys, &polyCount, 128) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(queryPolygons(center, extents, filter, polys, &polyCount, 128)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	// Find nearest polygon amongst the nearby polygons.
 	dtPolyRef nearest = 0;
@@ -367,8 +458,7 @@
 	{
 		dtPolyRef ref = polys[i];
 		float closestPtPoly[3];
-		if (closestPointOnPoly(ref, center, closestPtPoly) != DT_SUCCESS)
-			continue;
+		closestPointOnPoly(ref, center, closestPtPoly);
 		float d = dtVdistSqr(center, closestPtPoly);
 		if (d < nearestDistanceSqr)
 		{
@@ -406,8 +496,7 @@
 		dtPolyRef ref = polys[i];
 		const dtPoly* poly = &tile->polys[m_nav->decodePolyIdPoly(ref)];
 		float closestPtPoly[3];
-		if (closestPointOnPolyInTile(tile, poly, center, closestPtPoly) != DT_SUCCESS)
-			continue;
+		closestPointOnPolyInTile(tile, poly, center, closestPtPoly);
 			
 		float d = dtVdistSqr(center, closestPtPoly);
 		if (d < nearestDistanceSqr)
@@ -489,8 +578,12 @@
 		const dtPolyRef base = m_nav->getPolyRefBase(tile);
 		for (int i = 0; i < tile->header->polyCount; ++i)
 		{
+			const dtPoly* p = &tile->polys[i];
+			const dtPolyRef ref = base | (dtPolyRef)i;
+			if (!filter->passFilter(ref, tile, p))
+				continue;
+				
 			// Calc polygon bounds.
-			dtPoly* p = &tile->polys[i];
 			const float* v = &tile->verts[p->verts[0]*3];
 			dtVcopy(bmin, v);
 			dtVcopy(bmax, v);
@@ -502,18 +595,23 @@
 			}
 			if (dtOverlapBounds(qmin,qmax, bmin,bmax))
 			{
-				const dtPolyRef ref = base | (dtPolyRef)i;
-				if (filter->passFilter(ref, tile, p))
-				{
-					if (n < maxPolys)
-						polys[n++] = ref;
-				}
+				if (n < maxPolys)
+					polys[n++] = ref;
 			}
 		}
 		return n;
 	}
 }
 
+/// @par 
+///
+/// If no polygons are found, the function will return #DT_SUCCESS with a
+/// @p polyCount of zero.
+///
+/// If @p polys is too small to hold the entire result set, then the array will 
+/// be filled to capacity. The method of choosing which polygons from the 
+/// full set are included in the partial result set is undefined.
+///
 dtStatus dtNavMeshQuery::queryPolygons(const float* center, const float* extents,
 									   const dtQueryFilter* filter,
 									   dtPolyRef* polys, int* polyCount, const int maxPolys) const
@@ -529,18 +627,23 @@
 	m_nav->calcTileLoc(bmin, &minx, &miny);
 	m_nav->calcTileLoc(bmax, &maxx, &maxy);
 
+	static const int MAX_NEIS = 32;
+	const dtMeshTile* neis[MAX_NEIS];
+	
 	int n = 0;
 	for (int y = miny; y <= maxy; ++y)
 	{
 		for (int x = minx; x <= maxx; ++x)
 		{
-			const dtMeshTile* tile = m_nav->getTileAt(x,y);
-			if (!tile) continue;
-			n += queryPolygonsInTile(tile, bmin, bmax, filter, polys+n, maxPolys-n);
-			if (n >= maxPolys)
+			const int nneis = m_nav->getTilesAt(x,y,neis,MAX_NEIS);
+			for (int j = 0; j < nneis; ++j)
 			{
-				*polyCount = n;
-				return DT_SUCCESS;
+				n += queryPolygonsInTile(neis[j], bmin, bmax, filter, polys+n, maxPolys-n);
+				if (n >= maxPolys)
+				{
+					*polyCount = n;
+					return DT_SUCCESS | DT_BUFFER_TOO_SMALL;
+				}
 			}
 		}
 	}
@@ -549,6 +652,17 @@
 	return DT_SUCCESS;
 }
 
+/// @par
+///
+/// If the end polygon cannot be reached through the navigation graph,
+/// the last polygon in the path will be the nearest the end polygon.
+///
+/// If the path array is to small to hold the full result, it will be filled as 
+/// far as possible from the start polygon toward the end polygon.
+///
+/// The start and end positions are used to calculate traversal costs. 
+/// (The y-values impact the result.)
+///
 dtStatus dtNavMeshQuery::findPath(dtPolyRef startRef, dtPolyRef endRef,
 								  const float* startPos, const float* endPos,
 								  const dtQueryFilter* filter,
@@ -561,14 +675,14 @@
 	*pathCount = 0;
 	
 	if (!startRef || !endRef)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	if (!maxPath)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	// Validate input
 	if (!m_nav->isValidPolyRef(startRef) || !m_nav->isValidPolyRef(endRef))
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	if (startRef == endRef)
 	{
@@ -592,6 +706,8 @@
 	dtNode* lastBestNode = startNode;
 	float lastBestNodeCost = startNode->total;
 	
+	dtStatus status = DT_SUCCESS;
+	
 	while (!m_openList->empty())
 	{
 		// Remove node from open list and put it in closed list.
@@ -641,7 +757,10 @@
 
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				status |= DT_OUT_OF_NODES;
 				continue;
+			}
 			
 			// If the node is visited the first time, calculate node position.
 			if (neighbourNode->flags == 0)
@@ -654,7 +773,7 @@
 			// Calculate cost and heuristic.
 			float cost = 0;
 			float heuristic = 0;
-
+			
 			// Special case for last node.
 			if (neighbourRef == endRef)
 			{
@@ -667,7 +786,7 @@
 													  bestRef, bestTile, bestPoly,
 													  neighbourRef, neighbourTile, neighbourPoly,
 													  0, 0, 0);
-
+				
 				cost = bestNode->cost + curCost + endCost;
 				heuristic = 0;
 			}
@@ -683,16 +802,21 @@
 			}
 
 			const float total = cost + heuristic;
-			if(total >= neighbourNode->total) // The new result is worse!
-				if (neighbourNode->flags & DT_NODE_OPEN || neighbourNode->flags & DT_NODE_CLOSED)
-					continue; // The node is already in open list or visited and processed, skip.
-
+			
+			// The node is already in open list and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_OPEN) && total >= neighbourNode->total)
+				continue;
+			// The node is already visited and process, and the new result is worse, skip.
+			if ((neighbourNode->flags & DT_NODE_CLOSED) && total >= neighbourNode->total)
+				continue;
+			
 			// Add or update the node.
 			neighbourNode->pidx = m_nodePool->getNodeIdx(bestNode);
 			neighbourNode->id = neighbourRef;
 			neighbourNode->flags &= ~DT_NODE_CLOSED;
 			neighbourNode->cost = cost;
 			neighbourNode->total = total;
+			
 			if (neighbourNode->flags & DT_NODE_OPEN)
 			{
 				// Already in open, update node location.
@@ -704,7 +828,7 @@
 				neighbourNode->flags |= DT_NODE_OPEN;
 				m_openList->push(neighbourNode);
 			}
-
+			
 			// Update nearest node to target so far.
 			if (heuristic < lastBestNodeCost)
 			{
@@ -713,7 +837,10 @@
 			}
 		}
 	}
-
+	
+	if (lastBestNode->id != endRef)
+		status |= DT_PARTIAL_RESULT;
+	
 	// Reverse the path.
 	dtNode* prev = 0;
 	dtNode* node = lastBestNode;
@@ -732,15 +859,28 @@
 	do
 	{
 		path[n++] = node->id;
+		if (n >= maxPath)
+		{
+			status |= DT_BUFFER_TOO_SMALL;
+			break;
+		}
 		node = m_nodePool->getNodeAtIdx(node->pidx);
 	}
-	while (node && n < maxPath);
+	while (node);
 	
 	*pathCount = n;
 	
-	return DT_SUCCESS;
+	return status;
 }
 
+/// @par
+///
+/// @warning Calling any non-slice methods before calling finalizeSlicedFindPath() 
+/// or finalizeSlicedFindPathPartial() may result in corrupted data!
+///
+/// The @p filter pointer is stored and used for the duration of the sliced
+/// path query.
+///
 dtStatus dtNavMeshQuery::initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef,
 											const float* startPos, const float* endPos,
 											const dtQueryFilter* filter)
@@ -759,11 +899,11 @@
 	m_query.filter = filter;
 	
 	if (!startRef || !endRef)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	// Validate input
 	if (!m_nav->isValidPolyRef(startRef) || !m_nav->isValidPolyRef(endRef))
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 
 	if (startRef == endRef)
 	{
@@ -790,9 +930,9 @@
 	return m_query.status;
 }
 	
-dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter)
+dtStatus dtNavMeshQuery::updateSlicedFindPath(const int maxIter, int* doneIters)
 {
-	if (m_query.status!= DT_IN_PROGRESS)
+	if (!dtStatusInProgress(m_query.status))
 		return m_query.status;
 
 	// Make sure the request is still valid.
@@ -816,7 +956,10 @@
 		if (bestNode->id == m_query.endRef)
 		{
 			m_query.lastBestNode = bestNode;
-			m_query.status = DT_SUCCESS;
+			const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
+			m_query.status = DT_SUCCESS | details;
+			if (doneIters)
+				*doneIters = iter;
 			return m_query.status;
 		}
 		
@@ -825,10 +968,12 @@
 		const dtPolyRef bestRef = bestNode->id;
 		const dtMeshTile* bestTile = 0;
 		const dtPoly* bestPoly = 0;
-		if (m_nav->getTileAndPolyByRef(bestRef, &bestTile, &bestPoly) != DT_SUCCESS)
+		if (dtStatusFailed(m_nav->getTileAndPolyByRef(bestRef, &bestTile, &bestPoly)))
 		{
 			// The polygon has disappeared during the sliced query, fail.
 			m_query.status = DT_FAILURE;
+			if (doneIters)
+				*doneIters = iter;
 			return m_query.status;
 		}
 		
@@ -840,10 +985,12 @@
 			parentRef = m_nodePool->getNodeAtIdx(bestNode->pidx)->id;
 		if (parentRef)
 		{
-			if (m_nav->getTileAndPolyByRef(parentRef, &parentTile, &parentPoly) != DT_SUCCESS)
+			if (dtStatusFailed(m_nav->getTileAndPolyByRef(parentRef, &parentTile, &parentPoly)))
 			{
 				// The polygon has disappeared during the sliced query, fail.
 				m_query.status = DT_FAILURE;
+				if (doneIters)
+					*doneIters = iter;
 				return m_query.status;
 			}
 		}
@@ -867,7 +1014,10 @@
 			
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				m_query.status |= DT_OUT_OF_NODES;
 				continue;
+			}
 			
 			// If the node is visited the first time, calculate node position.
 			if (neighbourNode->flags == 0)
@@ -947,8 +1097,14 @@
 	
 	// Exhausted all nodes, but could not find path.
 	if (m_openList->empty())
-		m_query.status = DT_SUCCESS;
+	{
+		const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
+		m_query.status = DT_SUCCESS | details;
+	}
 
+	if (doneIters)
+		*doneIters = iter;
+
 	return m_query.status;
 }
 
@@ -956,7 +1112,7 @@
 {
 	*pathCount = 0;
 	
-	if (m_query.status != DT_SUCCESS)
+	if (dtStatusFailed(m_query.status))
 	{
 		// Reset query.
 		memset(&m_query, 0, sizeof(dtQueryData));
@@ -974,6 +1130,10 @@
 	{
 		// Reverse the path.
 		ASSERT(m_query.lastBestNode);
+		
+		if (m_query.lastBestNode->id != m_query.endRef)
+			m_query.status |= DT_PARTIAL_RESULT;
+		
 		dtNode* prev = 0;
 		dtNode* node = m_query.lastBestNode;
 		do
@@ -990,17 +1150,24 @@
 		do
 		{
 			path[n++] = node->id;
+			if (n >= maxPath)
+			{
+				m_query.status |= DT_BUFFER_TOO_SMALL;
+				break;
+			}
 			node = m_nodePool->getNodeAtIdx(node->pidx);
 		}
-		while (node && n < maxPath);
+		while (node);
 	}
 	
+	const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
+
 	// Reset query.
 	memset(&m_query, 0, sizeof(dtQueryData));
 	
 	*pathCount = n;
 	
-	return DT_SUCCESS;
+	return DT_SUCCESS | details;
 }
 
 dtStatus dtNavMeshQuery::finalizeSlicedFindPathPartial(const dtPolyRef* existing, const int existingSize,
@@ -1013,7 +1180,7 @@
 		return DT_FAILURE;
 	}
 	
-	if (m_query.status != DT_SUCCESS && m_query.status != DT_IN_PROGRESS)
+	if (dtStatusFailed(m_query.status))
 	{
 		// Reset query.
 		memset(&m_query, 0, sizeof(dtQueryData));
@@ -1059,20 +1226,43 @@
 		do
 		{
 			path[n++] = node->id;
+			if (n >= maxPath)
+			{
+				m_query.status |= DT_BUFFER_TOO_SMALL;
+				break;
+			}
 			node = m_nodePool->getNodeAtIdx(node->pidx);
 		}
-		while (node && n < maxPath);
+		while (node);
 	}
 	
+	const dtStatus details = m_query.status & DT_STATUS_DETAIL_MASK;
+
 	// Reset query.
 	memset(&m_query, 0, sizeof(dtQueryData));
 	
 	*pathCount = n;
 	
-	return DT_SUCCESS;
+	return DT_SUCCESS | details;
 }
 
-
+/// @par
+/// 
+/// This method peforms what is often called 'string pulling'.
+///
+/// The start position is clamped to the first polygon in the path, and the 
+/// end position is clamped to the last. So the start and end positions should 
+/// normally be within or very near the first and last polygons respectively.
+///
+/// The returned polygon references represent the reference id of the polygon 
+/// that is entered at the associated path position. The reference id associated 
+/// with the end point will always be zero.  This allows, for example, matching 
+/// off-mesh link points to their representative polygons.
+///
+/// If the provided result buffers are too small for the entire result set, 
+/// they will be filled as far as possible from the start toward the end 
+/// position.
+///
 dtStatus dtNavMeshQuery::findStraightPath(const float* startPos, const float* endPos,
 										  const dtPolyRef* path, const int pathSize,
 										  float* straightPath, unsigned char* straightPathFlags, dtPolyRef* straightPathRefs,
@@ -1083,17 +1273,17 @@
 	*straightPathCount = 0;
 	
 	if (!maxStraightPath)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	if (!path[0])
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	int n = 0;
 	
 	// TODO: Should this be callers responsibility?
 	float closestStartPos[3];
-	if (closestPointOnPolyBoundary(path[0], startPos, closestStartPos) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(closestPointOnPolyBoundary(path[0], startPos, closestStartPos)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	// Add start point.
 	dtVcopy(&straightPath[n*3], closestStartPos);
@@ -1105,13 +1295,13 @@
 	if (n >= maxStraightPath)
 	{
 		*straightPathCount = n;
-		return DT_SUCCESS;
+		return DT_SUCCESS | DT_BUFFER_TOO_SMALL;
 	}
 	
 	float closestEndPos[3];
-	if (closestPointOnPolyBoundary(path[pathSize-1], endPos, closestEndPos) != DT_SUCCESS)
-		return DT_FAILURE;
-
+	if (dtStatusFailed(closestPointOnPolyBoundary(path[pathSize-1], endPos, closestEndPos)))
+		return DT_FAILURE | DT_INVALID_PARAM;
+	
 	if (pathSize > 1)
 	{
 		float portalApex[3], portalLeft[3], portalRight[3];
@@ -1121,36 +1311,44 @@
 		int apexIndex = 0;
 		int leftIndex = 0;
 		int rightIndex = 0;
-
+		
 		unsigned char leftPolyType = 0;
 		unsigned char rightPolyType = 0;
-
+		
 		dtPolyRef leftPolyRef = path[0];
 		dtPolyRef rightPolyRef = path[0];
-
+		
 		for (int i = 0; i < pathSize; ++i)
 		{
 			float left[3], right[3];
 			unsigned char fromType, toType;
-
+			
 			if (i+1 < pathSize)
 			{
 				// Next portal.
-				if (getPortalPoints(path[i], path[i+1], left, right, fromType, toType) != DT_SUCCESS)
+				if (dtStatusFailed(getPortalPoints(path[i], path[i+1], left, right, fromType, toType)))
 				{
-					if (closestPointOnPolyBoundary(path[i], endPos, closestEndPos) != DT_SUCCESS)
-						return DT_FAILURE;
-
+					// Failed to get portal points, in practice this means that path[i+1] is invalid polygon.
+					// Clamp the end point to path[i], and return the path so far.
+					
+					if (dtStatusFailed(closestPointOnPolyBoundary(path[i], endPos, closestEndPos)))
+					{
+						// This should only happen when the first polygon is invalid.
+						return DT_FAILURE | DT_INVALID_PARAM;
+					}
+					
 					dtVcopy(&straightPath[n*3], closestEndPos);
 					if (straightPathFlags)
 						straightPathFlags[n] = 0;
 					if (straightPathRefs)
 						straightPathRefs[n] = path[i];
 					n++;
-
-					return DT_SUCCESS;
+					
+					*straightPathCount = n;
+					
+					return DT_SUCCESS | DT_PARTIAL_RESULT | ((n >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 				}
-
+				
 				// If starting really close the portal, advance.
 				if (i == 0)
 				{
@@ -1164,10 +1362,10 @@
 				// End of the path.
 				dtVcopy(left, closestEndPos);
 				dtVcopy(right, closestEndPos);
-
+				
 				fromType = toType = DT_POLYTYPE_GROUND;
 			}
-
+			
 			// Right vertex.
 			if (dtTriArea2D(portalApex, portalRight, right) <= 0.0f)
 			{
@@ -1182,14 +1380,14 @@
 				{
 					dtVcopy(portalApex, portalLeft);
 					apexIndex = leftIndex;
-
+					
 					unsigned char flags = 0;
 					if (!leftPolyRef)
 						flags = DT_STRAIGHTPATH_END;
 					else if (leftPolyType == DT_POLYTYPE_OFFMESH_CONNECTION)
 						flags = DT_STRAIGHTPATH_OFFMESH_CONNECTION;
 					dtPolyRef ref = leftPolyRef;
-
+					
 					if (!dtVequal(&straightPath[(n-1)*3], portalApex))
 					{
 						// Append new vertex.
@@ -1203,7 +1401,7 @@
 						if (flags == DT_STRAIGHTPATH_END || n >= maxStraightPath)
 						{
 							*straightPathCount = n;
-							return DT_SUCCESS;
+							return DT_SUCCESS | ((n >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 						}
 					}
 					else
@@ -1214,19 +1412,19 @@
 						if (straightPathRefs)
 							straightPathRefs[n-1] = ref;
 					}
-
+					
 					dtVcopy(portalLeft, portalApex);
 					dtVcopy(portalRight, portalApex);
 					leftIndex = apexIndex;
 					rightIndex = apexIndex;
-
+					
 					// Restart
 					i = apexIndex;
-
+					
 					continue;
 				}
 			}
-
+			
 			// Left vertex.
 			if (dtTriArea2D(portalApex, portalLeft, left) >= 0.0f)
 			{
@@ -1241,14 +1439,14 @@
 				{
 					dtVcopy(portalApex, portalRight);
 					apexIndex = rightIndex;
-
+					
 					unsigned char flags = 0;
 					if (!rightPolyRef)
 						flags = DT_STRAIGHTPATH_END;
 					else if (rightPolyType == DT_POLYTYPE_OFFMESH_CONNECTION)
 						flags = DT_STRAIGHTPATH_OFFMESH_CONNECTION;
 					dtPolyRef ref = rightPolyRef;
-
+					
 					if (!dtVequal(&straightPath[(n-1)*3], portalApex))
 					{
 						// Append new vertex.
@@ -1262,7 +1460,7 @@
 						if (flags == DT_STRAIGHTPATH_END || n >= maxStraightPath)
 						{
 							*straightPathCount = n;
-							return DT_SUCCESS;
+							return DT_SUCCESS | ((n >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 						}
 					}
 					else
@@ -1273,24 +1471,25 @@
 						if (straightPathRefs)
 							straightPathRefs[n-1] = ref;
 					}
-
+					
 					dtVcopy(portalLeft, portalApex);
 					dtVcopy(portalRight, portalApex);
 					leftIndex = apexIndex;
 					rightIndex = apexIndex;
-
+					
 					// Restart
 					i = apexIndex;
+					
 					continue;
 				}
 			}
 		}
 	}
-
+	
 	// If the point already exists, remove it and add reappend the actual end location.  
 	if (n > 0 && dtVequal(&straightPath[(n-1)*3], closestEndPos))
 		n--;
-
+	
 	// Add end point.
 	if (n < maxStraightPath)
 	{
@@ -1301,11 +1500,32 @@
 			straightPathRefs[n] = 0;
 		n++;
 	}
-
+	
 	*straightPathCount = n;
-	return DT_SUCCESS;
+	
+	return DT_SUCCESS | ((n >= maxStraightPath) ? DT_BUFFER_TOO_SMALL : 0);
 }
 
+/// @par
+///
+/// This method is optimized for small delta movement and a small number of 
+/// polygons. If used for too great a distance, the result set will form an 
+/// incomplete path.
+///
+/// @p resultPos will equal the @p endPos if the end is reached. 
+/// Otherwise the closest reachable position will be returned.
+/// 
+/// @p resultPos is not projected onto the surface of the navigation 
+/// mesh. Use #getPolyHeight if this is needed.
+///
+/// This method treats the end position in the same manner as 
+/// the #raycast method. (As a 2D point.) See that method's documentation 
+/// for details.
+/// 
+/// If the @p visited array is too small to hold the entire result set, it will 
+/// be filled as far as possible from the start position toward the end 
+/// position.
+///
 dtStatus dtNavMeshQuery::moveAlongSurface(dtPolyRef startRef, const float* startPos, const float* endPos,
 										  const dtQueryFilter* filter,
 										  float* resultPos, dtPolyRef* visited, int* visitedCount, const int maxVisitedSize) const
@@ -1316,9 +1536,13 @@
 	*visitedCount = 0;
 	
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	if (!startRef)
+		return DT_FAILURE | DT_INVALID_PARAM;
+	if (!m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
+	dtStatus status = DT_SUCCESS;
+	
 	static const int MAX_STACK = 48;
 	dtNode* stack[MAX_STACK];
 	int nstack = 0;
@@ -1482,16 +1706,21 @@
 		do
 		{
 			visited[n++] = node->id;
+			if (n >= maxVisitedSize)
+			{
+				status |= DT_BUFFER_TOO_SMALL;
+				break;
+			}
 			node = m_tinyNodePool->getNodeAtIdx(node->pidx);
 		}
-		while (node && n < maxVisitedSize);
+		while (node);
 	}
 	
 	dtVcopy(resultPos, bestPos);
 	
 	*visitedCount = n;
 	
-	return DT_SUCCESS;
+	return status;
 }
 
 
@@ -1502,14 +1731,14 @@
 	
 	const dtMeshTile* fromTile = 0;
 	const dtPoly* fromPoly = 0;
-	if (m_nav->getTileAndPolyByRef(from, &fromTile, &fromPoly) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(from, &fromTile, &fromPoly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	fromType = fromPoly->getType();
 
 	const dtMeshTile* toTile = 0;
 	const dtPoly* toPoly = 0;
-	if (m_nav->getTileAndPolyByRef(to, &toTile, &toPoly) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(to, &toTile, &toPoly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	toType = toPoly->getType();
 		
 	return getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right);
@@ -1531,7 +1760,7 @@
 		}
 	}
 	if (!link)
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	// Handle off-mesh connections.
 	if (fromPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
@@ -1547,7 +1776,7 @@
 				return DT_SUCCESS;
 			}
 		}
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	}
 	
 	if (toPoly->getType() == DT_POLYTYPE_OFFMESH_CONNECTION)
@@ -1562,9 +1791,9 @@
 				return DT_SUCCESS;
 			}
 		}
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	}
-	
+
 	// Find portal vertices.
 	const int v0 = fromPoly->verts[link->edge];
 	const int v1 = fromPoly->verts[(link->edge+1) % (int)fromPoly->vertCount];
@@ -1594,7 +1823,8 @@
 {
 	float left[3], right[3];
 	unsigned char fromType, toType;
-	if (!getPortalPoints(from, to, left,right, fromType, toType)) return DT_FAILURE;
+	if (dtStatusFailed(getPortalPoints(from, to, left,right, fromType, toType)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	mid[0] = (left[0]+right[0])*0.5f;
 	mid[1] = (left[1]+right[1])*0.5f;
 	mid[2] = (left[2]+right[2])*0.5f;
@@ -1606,14 +1836,52 @@
 										 float* mid) const
 {
 	float left[3], right[3];
-	if (getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(getPortalPoints(from, fromPoly, fromTile, to, toPoly, toTile, left, right)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	mid[0] = (left[0]+right[0])*0.5f;
 	mid[1] = (left[1]+right[1])*0.5f;
 	mid[2] = (left[2]+right[2])*0.5f;
 	return DT_SUCCESS;
 }
 
+/// @par
+///
+/// This method is meant to be used for quick, short distance checks.
+///
+/// If the path array is too small to hold the result, it will be filled as 
+/// far as possible from the start postion toward the end position.
+///
+/// <b>Using the Hit Parameter (t)</b>
+/// 
+/// If the hit parameter is a very high value (FLT_MAX), then the ray has hit 
+/// the end position. In this case the path represents a valid corridor to the 
+/// end position and the value of @p hitNormal is undefined.
+///
+/// If the hit parameter is zero, then the start position is on the wall that 
+/// was hit and the value of @p hitNormal is undefined.
+///
+/// If 0 < t < 1.0 then the following applies:
+///
+/// @code
+/// distanceToHitBorder = distanceToEndPosition * t
+/// hitPoint = startPos + (endPos - startPos) * t
+/// @endcode
+///
+/// <b>Use Case Restriction</b>
+///
+/// The raycast ignores the y-value of the end position. (2D check.) This 
+/// places significant limits on how it can be used. For example:
+///
+/// Consider a scene where there is a main floor with a second floor balcony 
+/// that hangs over the main floor. So the first floor mesh extends below the 
+/// balcony mesh. The start position is somewhere on the first floor. The end 
+/// position is on the balcony.
+///
+/// The raycast will search toward the end position along the first floor mesh. 
+/// If it reaches the end position's xz-coordinates it will indicate FLT_MAX
+/// (no wall hit), meaning it reached the end position. This is one example of why
+/// this method is meant for short distance checks.
+///
 dtStatus dtNavMeshQuery::raycast(dtPolyRef startRef, const float* startPos, const float* endPos,
 								 const dtQueryFilter* filter,
 								 float* t, float* hitNormal, dtPolyRef* path, int* pathCount, const int maxPath) const
@@ -1626,7 +1894,7 @@
 	
 	// Validate input
 	if (!startRef || !m_nav->isValidPolyRef(startRef))
-		return DT_FAILURE;
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	dtPolyRef curRef = startRef;
 	float verts[DT_VERTS_PER_POLYGON*3];	
@@ -1636,6 +1904,8 @@
 	hitNormal[1] = 0;
 	hitNormal[2] = 0;
 	
+	dtStatus status = DT_SUCCESS;
+	
 	while (curRef)
 	{
 		// Cast ray against current polygon.
@@ -1660,7 +1930,7 @@
 			// Could not hit the polygon, keep the old t and report hit.
 			if (pathCount)
 				*pathCount = n;
-			return DT_SUCCESS;
+			return status;
 		}
 		// Keep track of furthest t so far.
 		if (tmax > *t)
@@ -1669,6 +1939,8 @@
 		// Store visited polygons.
 		if (n < maxPath)
 			path[n++] = curRef;
+		else
+			status |= DT_BUFFER_TOO_SMALL;
 		
 		// Ray end is completely inside the polygon.
 		if (segMax == -1)
@@ -1676,7 +1948,7 @@
 			*t = FLT_MAX;
 			if (pathCount)
 				*pathCount = n;
-			return DT_SUCCESS;
+			return status;
 		}
 		
 		// Follow neighbours.
@@ -1778,7 +2050,7 @@
 			
 			if (pathCount)
 				*pathCount = n;
-			return DT_SUCCESS;
+			return status;
 		}
 		
 		// No hit, advance to neighbour polygon.
@@ -1788,9 +2060,38 @@
 	if (pathCount)
 		*pathCount = n;
 	
-	return DT_SUCCESS;
+	return status;
 }
 
+/// @par
+///
+/// At least one result array must be provided.
+///
+/// The order of the result set is from least to highest cost to reach the polygon.
+///
+/// A common use case for this method is to perform Dijkstra searches. 
+/// Candidate polygons are found by searching the graph beginning at the start polygon.
+///
+/// If a polygon is not found via the graph search, even if it intersects the 
+/// search circle, it will not be included in the result set. For example:
+///
+/// polyA is the start polygon.
+/// polyB shares an edge with polyA. (Is adjacent.)
+/// polyC shares an edge with polyB, but not with polyA
+/// Even if the search circle overlaps polyC, it will not be included in the 
+/// result set unless polyB is also in the set.
+/// 
+/// The value of the center point is used as the start position for cost 
+/// calculations. It is not projected onto the surface of the mesh, so its 
+/// y-value will effect the costs.
+///
+/// Intersection tests occur in 2D. All polygons and the search circle are 
+/// projected onto the xz-plane. So the y-value of the center point does not 
+/// effect intersection tests.
+///
+/// If the result arrays are to small to hold the entire result set, they will be 
+/// filled to capacity.
+/// 
 dtStatus dtNavMeshQuery::findPolysAroundCircle(dtPolyRef startRef, const float* centerPos, const float radius,
 											   const dtQueryFilter* filter,
 											   dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
@@ -1803,8 +2104,8 @@
 	*resultCount = 0;
 	
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	if (!startRef || !m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	m_nodePool->clear();
 	m_openList->clear();
@@ -1818,6 +2119,8 @@
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
 	
+	dtStatus status = DT_SUCCESS;
+	
 	int n = 0;
 	if (n < maxResult)
 	{
@@ -1829,6 +2132,10 @@
 			resultCost[n] = 0;
 		++n;
 	}
+	else
+	{
+		status |= DT_BUFFER_TOO_SMALL;
+	}
 	
 	const float radiusSqr = dtSqr(radius);
 	
@@ -1884,7 +2191,10 @@
 			
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				status |= DT_OUT_OF_NODES;
 				continue;
+			}
 				
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
@@ -1920,6 +2230,10 @@
 						resultCost[n] = neighbourNode->total;
 					++n;
 				}
+				else
+				{
+					status |= DT_BUFFER_TOO_SMALL;
+				}
 				neighbourNode->flags = DT_NODE_OPEN;
 				m_openList->push(neighbourNode);
 			}
@@ -1928,9 +2242,31 @@
 	
 	*resultCount = n;
 	
-	return DT_SUCCESS;
+	return status;
 }
 
+/// @par
+///
+/// The order of the result set is from least to highest cost.
+/// 
+/// At least one result array must be provided.
+///
+/// A common use case for this method is to perform Dijkstra searches. 
+/// Candidate polygons are found by searching the graph beginning at the start 
+/// polygon.
+/// 
+/// The same intersection test restrictions that apply to findPolysAroundCircle()
+/// method apply to this method.
+/// 
+/// The 3D centroid of the search polygon is used as the start position for cost 
+/// calculations.
+/// 
+/// Intersection tests occur in 2D. All polygons are projected onto the 
+/// xz-plane. So the y-values of the vertices do not effect intersection tests.
+/// 
+/// If the result arrays are is too small to hold the entire result set, they will 
+/// be filled to capacity.
+///
 dtStatus dtNavMeshQuery::findPolysAroundShape(dtPolyRef startRef, const float* verts, const int nverts,
 											  const dtQueryFilter* filter,
 											  dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
@@ -1943,8 +2279,8 @@
 	*resultCount = 0;
 	
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	if (!startRef || !m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	m_nodePool->clear();
 	m_openList->clear();
@@ -1963,6 +2299,8 @@
 	startNode->flags = DT_NODE_OPEN;
 	m_openList->push(startNode);
 	
+	dtStatus status = DT_SUCCESS;
+
 	int n = 0;
 	if (n < maxResult)
 	{
@@ -1974,6 +2312,10 @@
 			resultCost[n] = 0;
 		++n;
 	}
+	else
+	{
+		status |= DT_BUFFER_TOO_SMALL;
+	}
 	
 	while (!m_openList->empty())
 	{
@@ -2029,7 +2371,10 @@
 			
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				status |= DT_OUT_OF_NODES;
 				continue;
+			}
 			
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
@@ -2065,6 +2410,10 @@
 						resultCost[n] = neighbourNode->total;
 					++n;
 				}
+				else
+				{
+					status |= DT_BUFFER_TOO_SMALL;
+				}
 				neighbourNode->flags = DT_NODE_OPEN;
 				m_openList->push(neighbourNode);
 			}
@@ -2073,9 +2422,31 @@
 	
 	*resultCount = n;
 	
-	return DT_SUCCESS;
+	return status;
 }
 
+/// @par
+///
+/// This method is optimized for a small search radius and small number of result 
+/// polygons.
+///
+/// Candidate polygons are found by searching the navigation graph beginning at 
+/// the start polygon.
+///
+/// The same intersection test restrictions that apply to the findPolysAroundCircle 
+/// mehtod applies to this method.
+///
+/// The value of the center point is used as the start point for cost calculations. 
+/// It is not projected onto the surface of the mesh, so its y-value will effect 
+/// the costs.
+/// 
+/// Intersection tests occur in 2D. All polygons and the search circle are 
+/// projected onto the xz-plane. So the y-value of the center point does not 
+/// effect intersection tests.
+/// 
+/// If the result arrays are is too small to hold the entire result set, they will 
+/// be filled to capacity.
+/// 
 dtStatus dtNavMeshQuery::findLocalNeighbourhood(dtPolyRef startRef, const float* centerPos, const float radius,
 												const dtQueryFilter* filter,
 												dtPolyRef* resultRef, dtPolyRef* resultParent,
@@ -2087,8 +2458,8 @@
 	*resultCount = 0;
 
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	if (!startRef || !m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	static const int MAX_STACK = 48;
 	dtNode* stack[MAX_STACK];
@@ -2107,6 +2478,8 @@
 	float pa[DT_VERTS_PER_POLYGON*3];
 	float pb[DT_VERTS_PER_POLYGON*3];
 	
+	dtStatus status = DT_SUCCESS;
+	
 	int n = 0;
 	if (n < maxResult)
 	{
@@ -2115,6 +2488,10 @@
 			resultParent[n] = 0;
 		++n;
 	}
+	else
+	{
+		status |= DT_BUFFER_TOO_SMALL;
+	}
 	
 	while (nstack)
 	{
@@ -2228,6 +2605,10 @@
 					resultParent[n] = curRef;
 				++n;
 			}
+			else
+			{
+				status |= DT_BUFFER_TOO_SMALL;
+			}
 			
 			if (nstack < MAX_STACK)
 			{
@@ -2238,17 +2619,18 @@
 	
 	*resultCount = n;
 	
-	return DT_SUCCESS;
+	return status;
 }
 
 
 struct dtSegInterval
 {
+	dtPolyRef ref;
 	short tmin, tmax;
 };
 
 static void insertInterval(dtSegInterval* ints, int& nints, const int maxInts,
-						   const short tmin, const short tmax)
+						   const short tmin, const short tmax, const dtPolyRef ref)
 {
 	if (nints+1 > maxInts) return;
 	// Find insertion point.
@@ -2263,13 +2645,26 @@
 	if (nints-idx)
 		memmove(ints+idx+1, ints+idx, sizeof(dtSegInterval)*(nints-idx));
 	// Store
+	ints[idx].ref = ref;
 	ints[idx].tmin = tmin;
 	ints[idx].tmax = tmax;
 	nints++;
 }
 
+/// @par
+///
+/// If the @p segmentRefs parameter is provided, then all polygon segments will be returned. 
+/// Otherwise only the wall segments are returned.
+/// 
+/// A segment that is normally a portal will be included in the result set as a 
+/// wall if the @p filter results in the neighbor polygon becoomming impassable.
+/// 
+/// The @p segmentVerts and @p segmentRefs buffers should normally be sized for the 
+/// maximum segments per polygon of the source navigation mesh.
+/// 
 dtStatus dtNavMeshQuery::getPolyWallSegments(dtPolyRef ref, const dtQueryFilter* filter,
-											 float* segments, int* segmentCount, const int maxSegments) const
+											 float* segmentVerts, dtPolyRef* segmentRefs, int* segmentCount,
+											 const int maxSegments) const
 {
 	ASSERT(m_nav);
 	
@@ -2277,14 +2672,18 @@
 	
 	const dtMeshTile* tile = 0;
 	const dtPoly* poly = 0;
-	if (m_nav->getTileAndPolyByRef(ref, &tile, &poly) != DT_SUCCESS)
-		return DT_FAILURE;
+	if (dtStatusFailed(m_nav->getTileAndPolyByRef(ref, &tile, &poly)))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	int n = 0;
 	static const int MAX_INTERVAL = 16;
 	dtSegInterval ints[MAX_INTERVAL];
 	int nints;
 	
+	const bool storePortals = segmentRefs != 0;
+	
+	dtStatus status = DT_SUCCESS;
+	
 	for (int i = 0, j = (int)poly->vertCount-1; i < (int)poly->vertCount; j = i++)
 	{
 		// Skip non-solid edges.
@@ -2304,64 +2703,115 @@
 						m_nav->getTileAndPolyByRefUnsafe(link->ref, &neiTile, &neiPoly);
 						if (filter->passFilter(link->ref, neiTile, neiPoly))
 						{
-							insertInterval(ints, nints, MAX_INTERVAL, link->bmin, link->bmax);
+							insertInterval(ints, nints, MAX_INTERVAL, link->bmin, link->bmax, link->ref);
 						}
 					}
 				}
 			}
 		}
-		else if (poly->neis[j])
+		else
 		{
 			// Internal edge
-			const unsigned int idx = (unsigned int)(poly->neis[j]-1);
-			const dtPolyRef ref = m_nav->getPolyRefBase(tile) | idx;
-			if (filter->passFilter(ref, tile, &tile->polys[idx]))
+			dtPolyRef ref = 0;
+			if (poly->neis[j])
+			{
+				const unsigned int idx = (unsigned int)(poly->neis[j]-1);
+				ref = m_nav->getPolyRefBase(tile) | idx;
+				if (!filter->passFilter(ref, tile, &tile->polys[idx]))
+					ref = 0;
+			}
+
+			// If the edge leads to another polygon and portals are not stored, skip.
+			if (ref != 0 && !storePortals)
 				continue;
+			
+			if (n < maxSegments)
+			{
+				const float* vj = &tile->verts[poly->verts[j]*3];
+				const float* vi = &tile->verts[poly->verts[i]*3];
+				float* seg = &segmentVerts[n*6];
+				dtVcopy(seg+0, vj);
+				dtVcopy(seg+3, vi);
+				if (segmentRefs)
+					segmentRefs[n] = ref;
+				n++;
+			}
+			else
+			{
+				status |= DT_BUFFER_TOO_SMALL;
+			}
+			
+			continue;
 		}
 		
 		// Add sentinels
-		insertInterval(ints, nints, MAX_INTERVAL, -1, 0);
-		insertInterval(ints, nints, MAX_INTERVAL, 255, 256);
+		insertInterval(ints, nints, MAX_INTERVAL, -1, 0, 0);
+		insertInterval(ints, nints, MAX_INTERVAL, 255, 256, 0);
 		
-		// Store segment.
+		// Store segments.
 		const float* vj = &tile->verts[poly->verts[j]*3];
 		const float* vi = &tile->verts[poly->verts[i]*3];
 		for (int k = 1; k < nints; ++k)
 		{
-			// Find the space inbetween the opening areas.
-			const int imin = ints[k-1].tmax;
-			const int imax = ints[k].tmin;
-			if (imin == imax) continue;
-			if (imin == 0 && imax == 255)
+			// Portal segment.
+			if (storePortals && ints[k].ref)
 			{
+				const float tmin = ints[k].tmin/255.0f; 
+				const float tmax = ints[k].tmax/255.0f; 
 				if (n < maxSegments)
 				{
-					float* seg = &segments[n*6];
+					float* seg = &segmentVerts[n*6];
+					dtVlerp(seg+0, vj,vi, tmin);
+					dtVlerp(seg+3, vj,vi, tmax);
+					if (segmentRefs)
+						segmentRefs[n] = ints[k].ref;
 					n++;
-					dtVcopy(seg+0, vj);
-					dtVcopy(seg+3, vi);
 				}
+				else
+				{
+					status |= DT_BUFFER_TOO_SMALL;
+				}
 			}
-			else
+
+			// Wall segment.
+			const int imin = ints[k-1].tmax;
+			const int imax = ints[k].tmin;
+			if (imin != imax)
 			{
 				const float tmin = imin/255.0f; 
 				const float tmax = imax/255.0f; 
 				if (n < maxSegments)
 				{
-					float* seg = &segments[n*6];
-					n++;
+					float* seg = &segmentVerts[n*6];
 					dtVlerp(seg+0, vj,vi, tmin);
 					dtVlerp(seg+3, vj,vi, tmax);
+					if (segmentRefs)
+						segmentRefs[n] = 0;
+					n++;
 				}
+				else
+				{
+					status |= DT_BUFFER_TOO_SMALL;
+				}
 			}
 		}
 	}
 	
 	*segmentCount = n;
 	
-	return DT_SUCCESS;
+	return status;
 }
 
+/// @par
+///
+/// @p hitPos is not adjusted using the height detail data.
+///
+/// @p hitDist will equal the search radius if there is no wall within the 
+/// radius. In this case the values of @p hitPos and @p hitNormal are
+/// undefined.
+///
+/// The normal will become unpredicable if @p hitDist is a very small number.
+///
 dtStatus dtNavMeshQuery::findDistanceToWall(dtPolyRef startRef, const float* centerPos, const float maxRadius,
 											const dtQueryFilter* filter,
 											float* hitDist, float* hitPos, float* hitNormal) const
@@ -2371,8 +2821,8 @@
 	ASSERT(m_openList);
 	
 	// Validate input
-	if (!startRef) return DT_FAILURE;
-	if (!m_nav->isValidPolyRef(startRef)) return DT_FAILURE;
+	if (!startRef || !m_nav->isValidPolyRef(startRef))
+		return DT_FAILURE | DT_INVALID_PARAM;
 	
 	m_nodePool->clear();
 	m_openList->clear();
@@ -2388,6 +2838,8 @@
 	
 	float radiusSqr = dtSqr(maxRadius);
 	
+	dtStatus status = DT_SUCCESS;
+	
 	while (!m_openList->empty())
 	{
 		dtNode* bestNode = m_openList->pop();
@@ -2495,7 +2947,10 @@
 
 			dtNode* neighbourNode = m_nodePool->getNode(neighbourRef);
 			if (!neighbourNode)
+			{
+				status |= DT_OUT_OF_NODES;
 				continue;
+			}
 			
 			if (neighbourNode->flags & DT_NODE_CLOSED)
 				continue;
@@ -2536,9 +2991,28 @@
 	
 	*hitDist = sqrtf(radiusSqr);
 	
-	return DT_SUCCESS;
+	return status;
 }
 
+bool dtNavMeshQuery::isValidPolyRef(dtPolyRef ref, const dtQueryFilter* filter) const
+{
+	const dtMeshTile* tile = 0;
+	const dtPoly* poly = 0;
+	dtStatus status = m_nav->getTileAndPolyByRef(ref, &tile, &poly);
+	// If cannot get polygon, assume it does not exists and boundary is invalid.
+	if (dtStatusFailed(status))
+		return false;
+	// If cannot pass filter, assume flags has changed and boundary is invalid.
+	if (!filter->passFilter(ref, tile, poly))
+		return false;
+	return true;
+}
+
+/// @par
+///
+/// The closed list is the list of polygons that were fully evaluated during 
+/// the last navigation graph search. (A* or Dijkstra)
+/// 
 bool dtNavMeshQuery::isInClosedList(dtPolyRef ref) const
 {
 	if (!m_nodePool) return false;
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.h	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNavMeshQuery.h	(working copy)
@@ -20,39 +20,31 @@
 #define DETOURNAVMESHQUERY_H
 
 #include "DetourNavMesh.h"
+#include "DetourStatus.h"
 
 
 // Define DT_VIRTUAL_QUERYFILTER if you wish to derive a custom filter from dtQueryFilter.
 // On certain platforms indirect or virtual function call is expensive. The default
-// setting is to use non-virtual functions, the actualy implementations of the functions
+// setting is to use non-virtual functions, the actual implementations of the functions
 // are declared as inline for maximum speed. 
 
 //#define DT_VIRTUAL_QUERYFILTER 1
 
-// Class for polygon filtering and cost calculation during query operations.
-// - It is possible to derive a custom query filter from dtQueryFilter by overriding
-//   the virtual functions passFilter() and getCost().
-// - Both functions should be as fast as possible. Use cached local copy of data
-//   instead of accessing your own objects where possible.
-// - You do not need to adhere to the flags and cost logic provided by the default
-//   implementation.
-// - In order for the A* to work properly, the cost should be proportional to
-//   the travel distance. Using cost modifier less than 1.0 is likely to lead
-//   to problems during pathfinding.
+/// Defines polygon filtering and traversal costs for navigation mesh query operations.
+/// @ingroup detour
 class dtQueryFilter
 {
-	float m_areaCost[DT_MAX_AREAS];		// Array storing cost per area type, used by default implementation.
-	unsigned short m_includeFlags;		// Include poly flags, used by default implementation.
-	unsigned short m_excludeFlags;		// Exclude poly flags, used by default implementation.
+	float m_areaCost[DT_MAX_AREAS];		///< Cost per area type. (Used by default implementation.)
+	unsigned short m_includeFlags;		///< Flags for polygons that can be visited. (Used by default implementation.)
+	unsigned short m_excludeFlags;		///< Flags for polygons that should not be visted. (Used by default implementation.)
 	
 public:
 	dtQueryFilter();
 	
-	// Returns true if the polygon is can visited.
-	// Params:
-	//  ref - (in) reference to the polygon test.
-	//  tile - (in) pointer to the tile of the polygon test.
-	//  poly - (in) pointer to the polygon test.
+	/// Returns true if the polygon can be visited.  (I.e. Is traversable.)
+	///  @param[in]		ref		The reference id of the polygon test.
+	///  @param[in]		tile	The tile containing the polygon.
+	///  @param[in]		poly  The polygon to test.
 #ifdef DT_VIRTUAL_QUERYFILTER
 	virtual bool passFilter(const dtPolyRef ref,
 							const dtMeshTile* tile,
@@ -63,16 +55,19 @@
 					const dtPoly* poly) const;
 #endif
 
-	// Returns cost to travel from 'pa' to 'pb'.'
-	// The segment is fully contained inside 'cur'.
-	// 'pa' lies on the edge between 'prev' and 'cur', 
-	// 'pb' lies on the edge between 'cur' and 'next'.
-	// Params:
-	//  pa - (in) segment start position.
-	//  pb - (in) segment end position.
-	//  prevRef, prevTile, prevPoly - (in) data describing the previous polygon, can be null.
-	//  curRef, curTile, curPoly - (in) data describing the current polygon.
-	//  nextRef, nextTile, nextPoly - (in) data describing the next polygon, can be null.
+	/// Returns cost to move from the beginning to the end of a line segment
+	/// that is fully contained within a polygon.
+	///  @param[in]		pa			The start position on the edge of the previous and current polygon. [(x, y, z)]
+	///  @param[in]		pb			The end position on the edge of the current and next polygon. [(x, y, z)]
+	///  @param[in]		prevRef		The reference id of the previous polygon. [opt]
+	///  @param[in]		prevTile	The tile containing the previous polygon. [opt]
+	///  @param[in]		prevPoly	The previous polygon. [opt]
+	///  @param[in]		curRef		The reference id of the current polygon.
+	///  @param[in]		curTile		The tile containing the current polygon.
+	///  @param[in]		curPoly		The current polygon.
+	///  @param[in]		nextRef		The refernece id of the next polygon. [opt]
+	///  @param[in]		nextTile	The tile containing the next polygon. [opt]
+	///  @param[in]		nextPoly	The next polygon. [opt]
 #ifdef DT_VIRTUAL_QUERYFILTER
 	virtual float getCost(const float* pa, const float* pb,
 						  const dtPolyRef prevRef, const dtMeshTile* prevTile, const dtPoly* prevPoly,
@@ -85,304 +80,349 @@
 				  const dtPolyRef nextRef, const dtMeshTile* nextTile, const dtPoly* nextPoly) const;
 #endif
 
-	// Getters and setters for the default implementation data.
+	/// @name Getters and setters for the default implementation data.
+	///@{
+
+	/// Returns the traversal cost of the area.
+	///  @param[in]		i		The id of the area.
+	/// @returns The traversal cost of the area.
 	inline float getAreaCost(const int i) const { return m_areaCost[i]; }
+
+	/// Sets the traversal cost of the area.
+	///  @param[in]		i		The id of the area.
+	///  @param[in]		cost	The new cost of traversing the area.
 	inline void setAreaCost(const int i, const float cost) { m_areaCost[i] = cost; } 
 
+	/// Returns the include flags for the filter.
+	/// Any polygons that include one or more of these flags will be
+	/// included in the operation.
 	inline unsigned short getIncludeFlags() const { return m_includeFlags; }
+
+	/// Sets the include flags for the filter.
+	/// @param[in]		flags	The new flags.
 	inline void setIncludeFlags(const unsigned short flags) { m_includeFlags = flags; }
 
+	/// Returns the exclude flags for the filter.
+	/// Any polygons that include one ore more of these flags will be
+	/// excluded from the operation.
 	inline unsigned short getExcludeFlags() const { return m_excludeFlags; }
+
+	/// Sets the exclude flags for the filter.
+	/// @param[in]		flags		The new flags.
 	inline void setExcludeFlags(const unsigned short flags) { m_excludeFlags = flags; }	
+
+	///@}
+
 };
 
+/// Provides the ability to perform pathfinding related queries against
+/// a navigation mesh.
+/// @ingroup detour
 class dtNavMeshQuery
 {
 public:
 	dtNavMeshQuery();
 	~dtNavMeshQuery();
 	
-	// Initializes the nav mesh query.
-	// Params:
-	//  nav - (in) pointer to navigation mesh data.
-	//  maxNodes - (in) Maximum number of search nodes to use (max 65536).
-	// Returns: True if succeed, else false.
+	/// Initializes the query object.
+	///  @param[in]		nav			Pointer to the dtNavMesh object to use for all queries.
+	///  @param[in]		maxNodes	Maximum number of search nodes. [Limits: 0 < value <= 65536]
+	/// @returns The status flags for the query.
 	dtStatus init(const dtNavMesh* nav, const int maxNodes);
 	
-	// Finds the nearest navigation polygon around the center location.
-	// Params:
-	//	center[3] - (in) The center of the search box.
-	//	extents[3] - (in) The extents of the search box.
-	//  filter - (in) path polygon filter.
-	//  nearestRef - (out) Reference to the nearest polygon.
-	//  nearestPt[3] - (out, opt) The nearest point on found polygon, null if not needed.
-	// Returns: Reference identifier for the polygon, or 0 if no polygons found.
-	dtStatus findNearestPoly(const float* center, const float* extents,
-							 const dtQueryFilter* filter,
-							 dtPolyRef* nearestRef, float* nearestPt) const;
-	
-	// Returns polygons which overlap the query box.
-	// Params:
-	//	center[3] - (in) the center of the search box.
-	//	extents[3] - (in) the extents of the search box.
-	//  filter - (in) path polygon filter.
-	//	polys - (out) array holding the search result.
-	//  polyCount - (out) Number of polygons in search result array.
-	//	maxPolys - (in) The max number of polygons the polys array can hold.
-	dtStatus queryPolygons(const float* center, const float* extents,
-						   const dtQueryFilter* filter,
-						   dtPolyRef* polys, int* polyCount, const int maxPolys) const;
-	
-	// Finds path from start polygon to end polygon.
-	// If target polygon canno be reached through the navigation graph,
-	// the last node on the array is nearest node to the end polygon.
-	// Start end end positions are needed to calculate more accurate
-	// traversal cost at start end end polygons.
-	// Params:
-	//	startRef - (in) ref to path start polygon.
-	//	endRef - (in) ref to path end polygon.
-	//	startPos[3] - (in) Path start location.
-	//	endPos[3] - (in) Path end location.
-	//  filter - (in) path polygon filter.
-	//	path - (out) array holding the search result.
-	//  pathCount - (out) Number of polygons in search result array.
-	//	maxPath - (in) The max number of polygons the path array can hold. Must be at least 1.
+	/// @name Standard Pathfinding Functions
+	// /@{
+
+	/// Finds a path from the start polygon to the end polygon.
+	///  @param[in]		startRef	The refrence id of the start polygon.
+	///  @param[in]		endRef		The reference id of the end polygon.
+	///  @param[in]		startPos	A position within the start polygon. [(x, y, z)]
+	///  @param[in]		endPos		A position within the end polygon. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	///  @param[out]	path		An ordered list of polygon references representing the path. (Start to end.) 
+	///  							[(polyRef) * @p pathCount]
+	///  @param[out]	pathCount	The number of polygons returned in the @p path array.
+	///  @param[in]		maxPath		The maximum number of polygons the @p path array can hold. [Limit: >= 1]
 	dtStatus findPath(dtPolyRef startRef, dtPolyRef endRef,
 					  const float* startPos, const float* endPos,
 					  const dtQueryFilter* filter,
 					  dtPolyRef* path, int* pathCount, const int maxPath) const;
 	
-	// Intializes sliced path find query.
-	// Note 1: calling any other dtNavMeshQuery method before calling findPathEnd()
-	// may results in corrupted data!
-	// Note 2: The pointer to filter is store, and used in subsequent
-	// calls to updateSlicedFindPath().
-	// Params:
-	//	startRef - (in) ref to path start polygon.
-	//	endRef - (in) ref to path end polygon.
-	//	startPos[3] - (in) Path start location.
-	//	endPos[3] - (in) Path end location.
-	//  filter - (in) path polygon filter.
+	/// Finds the straight path from the start to the end position within the polygon corridor.
+	///  @param[in]		startPos			Path start position. [(x, y, z)]
+	///  @param[in]		endPos				Path end position. [(x, y, z)]
+	///  @param[in]		path				An array of polygon references that represent the path corridor.
+	///  @param[in]		pathSize			The number of polygons in the @p path array.
+	///  @param[out]	straightPath		Points describing the straight path. [(x, y, z) * @p straightPathCount].
+	///  @param[out]	straightPathFlags	Flags describing each point. (See: #dtStraightPathFlags) [opt]
+	///  @param[out]	straightPathRefs	The reference id of the polygon that is being entered at each point. [opt]
+	///  @param[out]	straightPathCount	The number of points in the straight path.
+	///  @param[in]		maxStraightPath		The maximum number of points the straight path arrays can hold.  [Limit: > 0]
+	/// @returns The status flags for the query.
+	dtStatus findStraightPath(const float* startPos, const float* endPos,
+							  const dtPolyRef* path, const int pathSize,
+							  float* straightPath, unsigned char* straightPathFlags, dtPolyRef* straightPathRefs,
+							  int* straightPathCount, const int maxStraightPath) const;
+
+	///@}
+	/// @name Sliced Pathfinding Functions
+	/// Common use case:
+	///	-# Call initSlicedFindPath() to initialize the sliced path query.
+	///	-# Call updateSlicedFindPath() until it returns complete.
+	///	-# Call finalizeSlicedFindPath() to get the path.
+	///@{ 
+
+	/// Intializes a sliced path query.
+	///  @param[in]		startRef	The refrence id of the start polygon.
+	///  @param[in]		endRef		The reference id of the end polygon.
+	///  @param[in]		startPos	A position within the start polygon. [(x, y, z)]
+	///  @param[in]		endPos		A position within the end polygon. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	/// @returns The status flags for the query.
 	dtStatus initSlicedFindPath(dtPolyRef startRef, dtPolyRef endRef,
 								const float* startPos, const float* endPos,
 								const dtQueryFilter* filter);
 
-	// Updates sliced path find query.
-	// Params:
-	//  maxIter - (in) max number of iterations to update.
-	// Returns: Path query state.
-	dtStatus updateSlicedFindPath(const int maxIter);
+	/// Updates an in-progress sliced path query.
+	///  @param[in]		maxIter		The maximum number of iterations to perform.
+	///  @param[out]	doneIters	The actual number of iterations completed. [opt]
+	/// @returns The status flags for the query.
+	dtStatus updateSlicedFindPath(const int maxIter, int* doneIters);
 
-	// Finalizes sliced path find query and returns found path.
-	//	path - (out) array holding the search result.
-	//  pathCount - (out) Number of polygons in search result array.
-	//	maxPath - (in) The max number of polygons the path array can hold.
+	/// Finalizes and returns the results of a sliced path query.
+	///  @param[out]	path		An ordered list of polygon references representing the path. (Start to end.) 
+	///  							[(polyRef) * @p pathCount]
+	///  @param[out]	pathCount	The number of polygons returned in the @p path array.
+	///  @param[in]		maxPath		The max number of polygons the path array can hold. [Limit: >= 1]
+	/// @returns The status flags for the query.
 	dtStatus finalizeSlicedFindPath(dtPolyRef* path, int* pathCount, const int maxPath);
 	
-	// Finalizes partial sliced path find query and returns path to the furthest
-	// polygon on the existing path that was visited during the search.
-	//	existing - (out) Array of polygons in the existing path.
-	//  existingSize - (out) Number of polygons in existing path array.
-	//	path - (out) array holding the search result.
-	//  pathCount - (out) Number of polygons in search result array.
-	//	maxPath - (in) The max number of polygons the path array can hold.
+	/// Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest
+	/// polygon on the existing path that was visited during the search.
+	///  @param[out]	existing		An array of polygon references for the existing path.
+	///  @param[out]	existingSize	The number of polygon in the @p existing array.
+	///  @param[out]	path			An ordered list of polygon references representing the path. (Start to end.) 
+	///  								[(polyRef) * @p pathCount]
+	///  @param[out]	pathCount		The number of polygons returned in the @p path array.
+	///  @param[in]		maxPath			The max number of polygons the @p path array can hold. [Limit: >= 1]
+	/// @returns The status flags for the query.
 	dtStatus finalizeSlicedFindPathPartial(const dtPolyRef* existing, const int existingSize,
 										   dtPolyRef* path, int* pathCount, const int maxPath);
-	
-	// Finds a straight path from start to end locations within the corridor
-	// described by the path polygons.
-	// Start and end locations will be clamped on the corridor.
-	// The returned polygon references are point to polygon which was entered when
-	// a path point was added. For the end point, zero will be returned. This allows
-	// to match for example off-mesh link points to their representative polygons.
-	// Params:
-	//	startPos[3] - (in) Path start location.
-	//	endPo[3] - (in) Path end location.
-	//	path - (in) Array of connected polygons describing the corridor.
-	//	pathSize - (in) Number of polygons in path array.
-	//	straightPath - (out) Points describing the straight path.
-	//  straightPathFlags - (out, opt) Flags describing each point type, see dtStraightPathFlags.
-	//  straightPathRefs - (out, opt) References to polygons at point locations.
-	//  straightPathCount - (out) Number of points in the path.
-	//	maxStraightPath - (in) The max number of points the straight path array can hold. Must be at least 1.
-	dtStatus findStraightPath(const float* startPos, const float* endPos,
-							  const dtPolyRef* path, const int pathSize,
-							  float* straightPath, unsigned char* straightPathFlags, dtPolyRef* straightPathRefs,
-							  int* straightPathCount, const int maxStraightPath) const;
-	
-	// Moves from startPos to endPos constrained to the navmesh.
-	// If the endPos is reachable, the resultPos will be endPos,
-	// or else the resultPos will be the nearest point in navmesh.
-	// Note: The resulting point is not projected to the ground, use getPolyHeight() to get height.
-	// Note: The algorithm is optimized for small delta movement and small number of polygons. 
-	// Params:
-	//  startRef - (in) ref to the polygon where startPos lies.
-	//  startPos[3] - (in) start position of the mover.
-	//  endPos[3] - (in) desired end position of the mover.
-	//  filter - (in) path polygon filter.
-	//  resultPos[3] - (out) new position of the mover.
-	//  visited - (out) array of visited polygons.
-	//  visitedCount - (out) Number of entries in the visited array.
-	//  maxVisitedSize - (in) max number of polygons in the visited array.
-	dtStatus moveAlongSurface(dtPolyRef startRef, const float* startPos, const float* endPos,
-							  const dtQueryFilter* filter,
-							  float* resultPos, dtPolyRef* visited, int* visitedCount, const int maxVisitedSize) const;
-	
-	// Casts 'walkability' ray along the navmesh surface from startPos towards the endPos.
-	// Params:
-	//	startRef - (in) ref to the polygon where the start lies.
-	//	startPos[3] - (in) start position of the query.
-	//	endPos[3] - (in) end position of the query.
-	//	t - (out) hit parameter along the segment, FLT_MAX if no hit.
-	//	hitNormal[3] - (out) normal of the nearest hit.
-	//  filter - (in) path polygon filter.
-	//  path - (out,opt) visited path polygons.
-	//  pathCount - (out,opt) Number of polygons visited.
-	//  maxPath - (in) max number of polygons in the path array.
-	dtStatus raycast(dtPolyRef startRef, const float* startPos, const float* endPos,
-					 const dtQueryFilter* filter,
-					 float* t, float* hitNormal, dtPolyRef* path, int* pathCount, const int maxPath) const;
-	
-	// Returns distance to nearest wall from the specified location.
-	// Params:
-	//	startRef - (in) ref to the polygon where the center lies.
-	//	centerPos[3] - (in) center if the query circle.
-	//	maxRadius - (in) max search radius.
-	//  filter - (in) path polygon filter.
-	//  hitDist - (out) distance to nearest wall from the test location.
-	//	hitPos[3] - (out) location of the nearest hit.
-	//	hitNormal[3] - (out) normal of the nearest hit.
-	dtStatus findDistanceToWall(dtPolyRef startRef, const float* centerPos, const float maxRadius,
-								const dtQueryFilter* filter,
-								float* hitDist, float* hitPos, float* hitNormal) const;
-	
-	// Finds polygons found along the navigation graph which touch the specified circle.
-	// Params:
-	//	startRef - (in) ref to the polygon where the search starts.
-	//	centerPos[3] - (in) center if the query circle.
-	//	radius - (in) radius of the query circle.
-	//  filter - (in) path polygon filter.
-	//	resultRef - (out, opt) refs to the polygons touched by the circle.
-	//	resultParent - (out, opt) parent of each result polygon.
-	//	resultCost - (out, opt) search cost at each result polygon.
-	//  resultCount - (out, opt) Number of results.
-	//	maxResult - (int) maximum capacity of search results.
+
+	///@}
+	/// @name Dijkstra Search Functions
+	/// @{ 
+
+	/// Finds the polygons along the navigation graph that touch the specified circle.
+	///  @param[in]		startRef		The reference id of the polygon where the search starts.
+	///  @param[in]		centerPos		The center of the search circle. [(x, y, z)]
+	///  @param[in]		radius			The radius of the search circle.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	resultRef		The reference ids of the polygons touched by the circle. [opt]
+	///  @param[out]	resultParent	The reference ids of the parent polygons for each result. 
+	///  								Zero if a result polygon has no parent. [opt]
+	///  @param[out]	resultCost		The search cost from @p centerPos to the polygon. [opt]
+	///  @param[out]	resultCount		The number of polygons found. [opt]
+	///  @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
+	/// @returns The status flags for the query.
 	dtStatus findPolysAroundCircle(dtPolyRef startRef, const float* centerPos, const float radius,
 								   const dtQueryFilter* filter,
 								   dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
 								   int* resultCount, const int maxResult) const;
 	
-	// Finds polygons found along the navigation graph which touch the convex polygon shape.
-	// Params:
-	//	startRef - (in) ref to the polygon where the search starts.
-	//	verts[3*n] - (in) vertices describing convex polygon shape (CCW).
-	//	nverts - (in) number of vertices in the polygon.
-	//  filter - (in) path polygon filter.
-	//	resultRef - (out, opt) refs to the polygons touched by the circle.
-	//	resultParent - (out, opt) parent of each result polygon.
-	//	resultCost - (out, opt) search cost at each result polygon.
-	//  resultCount - (out) number of results.
-	//	maxResult - (int) maximum capacity of search results.
+	/// Finds the polygons along the naviation graph that touch the specified convex polygon.
+	///  @param[in]		startRef		The reference id of the polygon where the search starts.
+	///  @param[in]		verts			The vertices describing the convex polygon. (CCW) 
+	///  								[(x, y, z) * @p nverts]
+	///  @param[in]		nverts			The number of vertices in the polygon.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	resultRef		The reference ids of the polygons touched by the search polygon. [opt]
+	///  @param[out]	resultParent	The reference ids of the parent polygons for each result. Zero if a 
+	///  								result polygon has no parent. [opt]
+	///  @param[out]	resultCost		The search cost from the centroid point to the polygon. [opt]
+	///  @param[out]	resultCount		The number of polygons found.
+	///  @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
+	/// @returns The status flags for the query.
 	dtStatus findPolysAroundShape(dtPolyRef startRef, const float* verts, const int nverts,
 								  const dtQueryFilter* filter,
 								  dtPolyRef* resultRef, dtPolyRef* resultParent, float* resultCost,
 								  int* resultCount, const int maxResult) const;
 	
-	// Finds non-overlapping local neighbourhood around center location.
-	// Note: The algorithm is optimized for small query radius and small number of polygons. 
-	// Params:
-	//	startRef - (in) ref to the polygon where the search starts.
-	//	centerPos[3] - (in) center if the query circle.
-	//	radius - (in) radius of the query circle.
-	//  filter - (in) path polygon filter.
-	//	resultRef - (out) refs to the polygons touched by the circle.
-	//	resultParent - (out, opt) parent of each result polygon.
-	//  resultCount - (out) number of results.
-	//	maxResult - (int) maximum capacity of search results.
+	/// @}
+	/// @name Local Query Functions
+	///@{
+
+	/// Finds the polygon nearest to the specified center point.
+	///  @param[in]		center		The center of the search box. [(x, y, z)]
+	///  @param[in]		extents		The search distance along each axis. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	///  @param[out]	nearestRef	The reference id of the nearest polygon.
+	///  @param[out]	nearestPt	The nearest point on the polygon. [opt] [(x, y, z)]
+	/// @returns The status flags for the query.
+	dtStatus findNearestPoly(const float* center, const float* extents,
+							 const dtQueryFilter* filter,
+							 dtPolyRef* nearestRef, float* nearestPt) const;
+	
+	/// Finds polygons that overlap the search box.
+	///  @param[in]		center		The center of the search box. [(x, y, z)]
+	///  @param[in]		extents		The search distance along each axis. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	///  @param[out]	polys		The reference ids of the polygons that overlap the query box.
+	///  @param[out]	polyCount	The number of polygons in the search result.
+	///  @param[in]		maxPolys	The maximum number of polygons the search result can hold.
+	/// @returns The status flags for the query.
+	dtStatus queryPolygons(const float* center, const float* extents,
+						   const dtQueryFilter* filter,
+						   dtPolyRef* polys, int* polyCount, const int maxPolys) const;
+
+	/// Finds the non-overlapping navigation polygons in the local neighbourhood around the center position.
+	///  @param[in]		startRef		The reference id of the polygon where the search starts.
+	///  @param[in]		centerPos		The center of the query circle. [(x, y, z)]
+	///  @param[in]		radius			The radius of the query circle.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	resultRef		The reference ids of the polygons touched by the circle.
+	///  @param[out]	resultParent	The reference ids of the parent polygons for each result. 
+	///  								Zero if a result polygon has no parent. [opt]
+	///  @param[out]	resultCount		The number of polygons found.
+	///  @param[in]		maxResult		The maximum number of polygons the result arrays can hold.
+	/// @returns The status flags for the query.
 	dtStatus findLocalNeighbourhood(dtPolyRef startRef, const float* centerPos, const float radius,
 									const dtQueryFilter* filter,
 									dtPolyRef* resultRef, dtPolyRef* resultParent,
 									int* resultCount, const int maxResult) const;
+
+	/// Moves from the start to the end position constrained to the navigation mesh.
+	///  @param[in]		startRef		The reference id of the start polygon.
+	///  @param[in]		startPos		A position of the mover within the start polygon. [(x, y, x)]
+	///  @param[in]		endPos			The desired end position of the mover. [(x, y, z)]
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	resultPos		The result position of the mover. [(x, y, z)]
+	///  @param[out]	visited			The reference ids of the polygons visited during the move.
+	///  @param[out]	visitedCount	The number of polygons visited during the move.
+	///  @param[in]		maxVisitedSize	The maximum number of polygons the @p visited array can hold.
+	/// @returns The status flags for the query.
+	dtStatus moveAlongSurface(dtPolyRef startRef, const float* startPos, const float* endPos,
+							  const dtQueryFilter* filter,
+							  float* resultPos, dtPolyRef* visited, int* visitedCount, const int maxVisitedSize) const;
 	
-	// Returns wall segments of specified polygon.
-	// Params:
-	//  ref - (in) ref to the polygon.
-	//  filter - (in) path polygon filter.
-	//  segments[6*maxSegments] - (out) wall segments (2 endpoints per segment).
-	//  segmentCount - (out) number of wall segments.
-	//  maxSegments - (in) max number of segments that can be stored in 'segments'.
+	/// Casts a 'walkability' ray along the surface of the navigation mesh from 
+	/// the start position toward the end position.
+	///  @param[in]		startRef	The reference id of the start polygon.
+	///  @param[in]		startPos	A position within the start polygon representing 
+	///  							the start of the ray. [(x, y, z)]
+	///  @param[in]		endPos		The position to cast the ray toward. [(x, y, z)]
+	///  @param[out]	t			The hit parameter. (FLT_MAX if no wall hit.)
+	///  @param[out]	hitNormal	The normal of the nearest wall hit. [(x, y, z)]
+	///  @param[in]		filter		The polygon filter to apply to the query.
+	///  @param[out]	path		The reference ids of the visited polygons. [opt]
+	///  @param[out]	pathCount	The number of visited polygons. [opt]
+	///  @param[in]		maxPath		The maximum number of polygons the @p path array can hold.
+	/// @returns The status flags for the query.
+	dtStatus raycast(dtPolyRef startRef, const float* startPos, const float* endPos,
+					 const dtQueryFilter* filter,
+					 float* t, float* hitNormal, dtPolyRef* path, int* pathCount, const int maxPath) const;
+	
+	/// Finds the distance from the specified position to the nearest polygon wall.
+	///  @param[in]		startRef		The reference id of the polygon containing @p centerPos.
+	///  @param[in]		centerPos		The center of the search circle. [(x, y, z)]
+	///  @param[in]		maxRadius		The radius of the search circle.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	hitDist			The distance to the nearest wall from @p centerPos.
+	///  @param[out]	hitPos			The nearest position on the wall that was hit. [(x, y, z)]
+	///  @param[out]	hitNormal		The normalized ray formed from the wall point to the 
+	///  								source point. [(x, y, z)]
+	/// @returns The status flags for the query.
+	dtStatus findDistanceToWall(dtPolyRef startRef, const float* centerPos, const float maxRadius,
+								const dtQueryFilter* filter,
+								float* hitDist, float* hitPos, float* hitNormal) const;
+	
+	/// Returns the segments for the specified polygon, optionally including portals.
+	///  @param[in]		ref				The reference id of the polygon.
+	///  @param[in]		filter			The polygon filter to apply to the query.
+	///  @param[out]	segmentVerts	The segments. [(ax, ay, az, bx, by, bz) * segmentCount]
+	///  @param[out]	segmentRefs		The reference ids of each segment's neighbor polygon. 
+	///  								Or zero if the segment is a wall. [opt] [(parentRef) * @p segmentCount] 
+	///  @param[out]	segmentCount	The number of segments returned.
+	///  @param[in]		maxSegments		The maximum number of segments the result arrays can hold.
+	/// @returns The status flags for the query.
 	dtStatus getPolyWallSegments(dtPolyRef ref, const dtQueryFilter* filter,
-								 float* segments, int* segmentCount, const int maxSegments) const;
+								 float* segmentVerts, dtPolyRef* segmentRefs, int* segmentCount,
+								 const int maxSegments) const;
 	
-	// Returns closest point on navigation polygon.
-	// Uses detail polygons to find the closest point to the navigation polygon surface. 
-	// Params:
-	//	ref - (in) ref to the polygon.
-	//	pos[3] - (in) the point to check.
-	//	closest[3] - (out) closest point.
-	// Returns: true if closest point found.
+	/// Finds the closest point on the specified polygon.
+	///  @param[in]		ref			The reference id of the polygon.
+	///  @param[in]		pos			The position to check. [(x, y, z)]
+	///  @param[out]	closest		The closest point on the polygon. [(x, y, z)]
+	/// @returns The status flags for the query.
 	dtStatus closestPointOnPoly(dtPolyRef ref, const float* pos, float* closest) const;
 	
-	// Returns closest point on navigation polygon boundary.
-	// Uses the navigation polygon boundary to snap the point to poly boundary
-	// if it is outside the polygon. Much faster than closestPointToPoly. Does not affect height.
-	// Params:
-	//	ref - (in) ref to the polygon.
-	//	pos[3] - (in) the point to check.
-	//	closest[3] - (out) closest point.
-	// Returns: true if closest point found.
+	/// Returns a point on the boundary closest to the source point if the source point is outside the 
+	/// polygon's xz-bounds.
+	///  @param[in]		ref			The reference id to the polygon.
+	///  @param[in]		pos			The position to check. [(x, y, z)]
+	///  @param[out]	closest		The closest point. [(x, y, z)]
+	/// @returns The status flags for the query.
 	dtStatus closestPointOnPolyBoundary(dtPolyRef ref, const float* pos, float* closest) const;
 	
-	// Returns start and end location of an off-mesh link polygon.
-	// Params:
-	//	prevRef - (in) ref to the polygon before the link (used to select direction).
-	//	polyRef - (in) ref to the off-mesh link polygon.
-	//	startPos[3] - (out) start point of the link.
-	//	endPos[3] - (out) end point of the link.
-	// Returns: true if link is found.
-	dtStatus getOffMeshConnectionPolyEndPoints(dtPolyRef prevRef, dtPolyRef polyRef, float* startPos, float* endPos) const;
-	
-	// Returns height of the polygon at specified location.
-	// Params:
-	//	ref - (in) ref to the polygon.
-	//	pos[3] - (in) the point where to locate the height.
-	//	height - (out) height at the location.
-	// Returns: true if over polygon.
+	/// Gets the height of the polygon at the provided position using the height detail. (Most accurate.)
+	///  @param[in]		ref			The reference id of the polygon.
+	///  @param[in]		pos			A position within the xz-bounds of the polygon. [(x, y, z)]
+	///  @param[out]	height		The height at the surface of the polygon.
+	/// @returns The status flags for the query.
 	dtStatus getPolyHeight(dtPolyRef ref, const float* pos, float* height) const;
-		
-	// Returns true if poly reference ins in closed list.
+
+	/// @}
+	/// @name Miscellaneous Functions
+	/// @{
+
+	/// Returns true if the polygon reference is valid and passes the filter restrictions.
+	///  @param[in]		ref			The polygon reference to check.
+	///  @param[in]		filter		The filter to apply.
+	bool isValidPolyRef(dtPolyRef ref, const dtQueryFilter* filter) const;
+
+	/// Returns true if the polygon reference is in the closed list. 
+	///  @param[in]		ref		The reference id of the polygon to check.
+	/// @returns True if the polygon is in closed list.
 	bool isInClosedList(dtPolyRef ref) const;
 	
+	/// Gets the node pool.
+	/// @returns The node pool.
 	class dtNodePool* getNodePool() const { return m_nodePool; }
 	
+	/// Gets the navigation mesh the query object is using.
+	/// @return The navigation mesh the query object is using.
+	const dtNavMesh* getAttachedNavMesh() const { return m_nav; }
+
+	/// @}
+	
 private:
 	
-	// Returns neighbour tile based on side. 
+	/// Returns neighbour tile based on side.
 	dtMeshTile* getNeighbourTileAt(int x, int y, int side) const;
 
-	// Queries polygons within a tile.
+	/// Queries polygons within a tile.
 	int queryPolygonsInTile(const dtMeshTile* tile, const float* qmin, const float* qmax, const dtQueryFilter* filter,
 							dtPolyRef* polys, const int maxPolys) const;
-	// Find nearest polygon within a tile.
+	/// Find nearest polygon within a tile.
 	dtPolyRef findNearestPolyInTile(const dtMeshTile* tile, const float* center, const float* extents,
 									const dtQueryFilter* filter, float* nearestPt) const;
-	// Returns closest point on polygon.
-	dtStatus closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly, const float* pos, float* closest) const;
+	/// Returns closest point on polygon.
+	void closestPointOnPolyInTile(const dtMeshTile* tile, const dtPoly* poly, const float* pos, float* closest) const;
 	
-	// Returns portal points between two polygons.
+	/// Returns portal points between two polygons.
 	dtStatus getPortalPoints(dtPolyRef from, dtPolyRef to, float* left, float* right,
 							 unsigned char& fromType, unsigned char& toType) const;
 	dtStatus getPortalPoints(dtPolyRef from, const dtPoly* fromPoly, const dtMeshTile* fromTile,
 							 dtPolyRef to, const dtPoly* toPoly, const dtMeshTile* toTile,
 							 float* left, float* right) const;
 	
-	// Returns edge mid point between two polygons.
+	/// Returns edge mid point between two polygons.
 	dtStatus getEdgeMidPoint(dtPolyRef from, dtPolyRef to, float* mid) const;
 	dtStatus getEdgeMidPoint(dtPolyRef from, const dtPoly* fromPoly, const dtMeshTile* fromTile,
 							 dtPolyRef to, const dtPoly* toPoly, const dtMeshTile* toTile,
 							 float* mid) const;
 	
-	const dtNavMesh* m_nav;				// Pointer to navmesh data.
+	const dtNavMesh* m_nav;				///< Pointer to navmesh data.
 
 	struct dtQueryData
 	{
@@ -393,15 +433,21 @@
 		float startPos[3], endPos[3];
 		const dtQueryFilter* filter;
 	};
-	dtQueryData m_query;				// Sliced query state.
+	dtQueryData m_query;				///< Sliced query state.
 
-	class dtNodePool* m_tinyNodePool;	// Pointer to small node pool.
-	class dtNodePool* m_nodePool;		// Pointer to node pool.
-	class dtNodeQueue* m_openList;		// Pointer to open list queue.
+	class dtNodePool* m_tinyNodePool;	///< Pointer to small node pool.
+	class dtNodePool* m_nodePool;		///< Pointer to node pool.
+	class dtNodeQueue* m_openList;		///< Pointer to open list queue.
 };
 
-// Helper function to allocate navmesh query class using Detour allocator.
+/// Allocates a query object using the Detour allocator.
+/// @return An allocated query object, or null on failure.
+/// @ingroup detour
 dtNavMeshQuery* mallocNavMeshQuery();
+
+/// Frees the specified query object using the Detour allocator.
+///  @param[in]		query		A query object allocated using #mallocNavMeshQuery
+/// @ingroup detour
 void freeNavMeshQuery(dtNavMeshQuery* query);
 
 #endif // DETOURNAVMESHQUERY_H
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNode.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNode.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNode.cpp	(working copy)
@@ -23,13 +23,13 @@
 
 inline unsigned int dtHashRef(dtPolyRef a)
 {
-    a = (~a) + (a << 18);
-    a = a ^ (a >> 31);
-    a = a * 21;
-    a = a ^ (a >> 11);
-    a = a + (a << 6);
-    a = a ^ (a >> 22);
-    return (unsigned int)a;
+	a += ~(a<<15);
+	a ^=  (a>>10);
+	a +=  (a<<3);
+	a ^=  (a>>6);
+	a += ~(a<<11);
+	a ^=  (a>>16);
+	return (unsigned int)a;
 }
 
 //////////////////////////////////////////////////////////////////////////////////////////
@@ -45,15 +45,15 @@
 	ASSERT(m_maxNodes > 0);
 
 	m_nodes = (dtNode*)malloc(sizeof(dtNode)*m_maxNodes);
-	m_next = (unsigned short*)malloc(sizeof(unsigned short)*m_maxNodes);
-	m_first = (unsigned short*)malloc(sizeof(unsigned short)*hashSize);
+	m_next = (dtNodeIndex*)malloc(sizeof(dtNodeIndex)*m_maxNodes);
+	m_first = (dtNodeIndex*)malloc(sizeof(dtNodeIndex)*hashSize);
 
 	ASSERT(m_nodes);
 	ASSERT(m_next);
 	ASSERT(m_first);
 
-	memset(m_first, 0xff, sizeof(unsigned short)*m_hashSize);
-	memset(m_next, 0xff, sizeof(unsigned short)*m_maxNodes);
+	memset(m_first, 0xff, sizeof(dtNodeIndex)*m_hashSize);
+	memset(m_next, 0xff, sizeof(dtNodeIndex)*m_maxNodes);
 }
 
 dtNodePool::~dtNodePool()
@@ -65,14 +65,14 @@
 
 void dtNodePool::clear()
 {
-	memset(m_first, 0xff, sizeof(unsigned short)*m_hashSize);
+	memset(m_first, 0xff, sizeof(dtNodeIndex)*m_hashSize);
 	m_nodeCount = 0;
 }
 
 dtNode* dtNodePool::findNode(dtPolyRef id)
 {
 	unsigned int bucket = dtHashRef(id) & (m_hashSize-1);
-	unsigned short i = m_first[bucket];
+	dtNodeIndex i = m_first[bucket];
 	while (i != DT_NULL_IDX)
 	{
 		if (m_nodes[i].id == id)
@@ -85,7 +85,7 @@
 dtNode* dtNodePool::getNode(dtPolyRef id)
 {
 	unsigned int bucket = dtHashRef(id) & (m_hashSize-1);
-	unsigned short i = m_first[bucket];
+	dtNodeIndex i = m_first[bucket];
 	dtNode* node = 0;
 	while (i != DT_NULL_IDX)
 	{
@@ -97,7 +97,7 @@
 	if (m_nodeCount >= m_maxNodes)
 		return 0;
 	
-	i = (unsigned short)m_nodeCount;
+	i = (dtNodeIndex)m_nodeCount;
 	m_nodeCount++;
 	
 	// Init node
Index: src/hearthstone-shared/Pathfinding/Detour/DetourNode.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Detour/DetourNode.h	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Detour/DetourNode.h	(working copy)
@@ -27,18 +27,20 @@
 	DT_NODE_CLOSED = 0x02,
 };
 
-static const unsigned short DT_NULL_IDX = 0xffff;
+typedef unsigned short dtNodeIndex;
+static const dtNodeIndex DT_NULL_IDX = (dtNodeIndex)~0;
 
 struct dtNode
 {
-	float pos[3];				// Position of the node.
-	float cost;					// Cost from previous node to current node.
-	float total;				// Cost up to the node.
-	unsigned int pidx : 30;		// Index to parent node.
-	unsigned int flags : 2;		// Node flags 0/open/closed.
-	dtPolyRef id;				// Polygon ref the node corresponds to.
+	float pos[3];				///< Position of the node.
+	float cost;					///< Cost from previous node to current node.
+	float total;				///< Cost up to the node.
+	unsigned int pidx : 30;		///< Index to parent node.
+	unsigned int flags : 2;		///< Node flags 0/open/closed.
+	dtPolyRef id;				///< Polygon ref the node corresponds to.
 };
 
+
 class dtNodePool
 {
 public:
@@ -70,22 +72,22 @@
 	inline int getMemUsed() const
 	{
 		return sizeof(*this) +
-		sizeof(dtNode)*m_maxNodes +
-		sizeof(unsigned short)*m_maxNodes +
-		sizeof(unsigned short)*m_hashSize;
+			sizeof(dtNode)*m_maxNodes +
+			sizeof(dtNodeIndex)*m_maxNodes +
+			sizeof(dtNodeIndex)*m_hashSize;
 	}
 	
 	inline int getMaxNodes() const { return m_maxNodes; }
 	
 	inline int getHashSize() const { return m_hashSize; }
-	inline unsigned short getFirst(int bucket) const { return m_first[bucket]; }
-	inline unsigned short getNext(int i) const { return m_next[i]; }
+	inline dtNodeIndex getFirst(int bucket) const { return m_first[bucket]; }
+	inline dtNodeIndex getNext(int i) const { return m_next[i]; }
 	
 private:
 	
 	dtNode* m_nodes;
-	unsigned short* m_first;
-	unsigned short* m_next;
+	dtNodeIndex* m_first;
+	dtNodeIndex* m_next;
 	const int m_maxNodes;
 	const int m_hashSize;
 	int m_nodeCount;
@@ -154,4 +156,4 @@
 };		
 
 
-#endif // DETOURNODE_H
\ No newline at end of file
+#endif // DETOURNODE_H
Index: src/hearthstone-shared/Pathfinding/Recast/Recast.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/Recast.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Recast/Recast.cpp	(working copy)
@@ -37,6 +37,26 @@
 	m_size = n;
 }
 
+/// @class rcContext
+/// @par
+///
+/// This class does not provide logging or timer functionality on its 
+/// own.  Both must be provided by a concrete implementation 
+/// by overriding the protected member functions.  Also, this class does not 
+/// provide an interface for extracting log messages. (Only adding them.) 
+/// So concrete implementations must provide one.
+///
+/// If no logging or timers are required, just pass an instance of this 
+/// class through the Recast build process.
+///
+
+/// @par
+///
+/// Example:
+/// @code
+/// // Where ctx is an instance of rcContext and filepath is a char array.
+/// ctx->log(RC_LOG_ERROR, "buildTiledNavigation: Could not load '%s'", filepath);
+/// @endcode
 void rcContext::log(const rcLogCategory category, const char* format, ...)
 {
 	if (!m_logEnabled)
@@ -94,6 +114,28 @@
 	free(chf);
 }
 
+
+rcHeightfieldLayerSet* mallocHeightfieldLayerSet()
+{
+	rcHeightfieldLayerSet* lset = (rcHeightfieldLayerSet*)malloc(sizeof(rcHeightfieldLayerSet));
+	memset(lset, 0, sizeof(rcHeightfieldLayerSet));
+	return lset;
+}
+
+void freeHeightfieldLayerSet(rcHeightfieldLayerSet* lset)
+{
+	if (!lset) return;
+	for (int i = 0; i < lset->nlayers; ++i)
+	{
+		free(lset->layers[i].heights);
+		free(lset->layers[i].areas);
+		free(lset->layers[i].cons);
+	}
+	free(lset->layers);
+	free(lset);
+}
+
+
 rcContourSet* mallocContourSet()
 {
 	rcContourSet* cset = (rcContourSet*)malloc(sizeof(rcContourSet));
@@ -147,7 +189,6 @@
 	free(dmesh);
 }
 
-
 void rcCalcBounds(const float* verts, int nv, float* bmin, float* bmax)
 {
 	// Calculate bounding box.
@@ -167,6 +208,11 @@
 	*h = (int)((bmax[2] - bmin[2])/cs+0.5f);
 }
 
+/// @par
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+/// 
+/// @see mallocHeightfield, rcHeightfield 
 bool rcCreateHeightfield(rcContext* /*ctx*/, rcHeightfield& hf, int width, int height,
 						 const float* bmin, const float* bmax,
 						 float cs, float ch)
@@ -196,6 +242,14 @@
 	rcVnormalize(norm);
 }
 
+/// @par
+///
+/// Only sets the aread id's for the walkable triangles.  Does not alter the
+/// area id's for unwalkable triangles.
+/// 
+/// See the #rcConfig documentation for more information on the configuration parameters.
+/// 
+/// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
 void rcMarkWalkableTriangles(rcContext* /*ctx*/, const float walkableSlopeAngle,
 							 const float* verts, int /*nv*/,
 							 const int* tris, int nt,
@@ -218,6 +272,14 @@
 	}
 }
 
+/// @par
+///
+/// Only sets the aread id's for the unwalkable triangles.  Does not alter the
+/// area id's for walkable triangles.
+/// 
+/// See the #rcConfig documentation for more information on the configuration parameters.
+/// 
+/// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
 void rcClearUnwalkableTriangles(rcContext* /*ctx*/, const float walkableSlopeAngle,
 								const float* verts, int /*nv*/,
 								const int* tris, int nt,
@@ -262,6 +324,15 @@
 	return spanCount;
 }
 
+/// @par
+///
+/// This is just the beginning of the process of fully building a compact heightfield.
+/// Various filters may be applied applied, then the distance field and regions built.
+/// E.g: #rcBuildDistanceField and #rcBuildRegions
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// @see mallocCompactHeightfield, rcHeightfield, rcCompactHeightfield, rcConfig
 bool rcBuildCompactHeightfield(rcContext* ctx, const int walkableHeight, const int walkableClimb,
 							   rcHeightfield& hf, rcCompactHeightfield& chf)
 {
Index: src/hearthstone-shared/Pathfinding/Recast/Recast.h
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/Recast.h	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Recast/Recast.h	(working copy)
@@ -19,48 +19,83 @@
 #ifndef RECAST_H
 #define RECAST_H
 
-// Some math headers don't have PI defined.
+/// The value of PI used by Recast.
 static const float RC_PI = 3.14159265f;
 
+/// Recast log categories.
+/// @see rcContext
 enum rcLogCategory
 {
-	RC_LOG_PROGRESS = 1,
-	RC_LOG_WARNING,
-	RC_LOG_ERROR,
+	RC_LOG_PROGRESS = 1,	///< A progress log entry.
+	RC_LOG_WARNING,			///< A warning log entry.
+	RC_LOG_ERROR,			///< An error log entry.
 };
 
+/// Recast performance timer categories.
+/// @see rcContext
 enum rcTimerLabel
 {
+	/// The user defined total time of the build.
 	RC_TIMER_TOTAL,
+	/// A user defined build time.
 	RC_TIMER_TEMP,
+	/// The time to rasterize the triangles. (See: #rcRasterizeTriangle)
 	RC_TIMER_RASTERIZE_TRIANGLES,
+	/// The time to build the compact heightfield. (See: #rcBuildCompactHeightfield)
 	RC_TIMER_BUILD_COMPACTHEIGHTFIELD,
+	/// The total time to build the contours. (See: #rcBuildContours)
 	RC_TIMER_BUILD_CONTOURS,
+	/// The time to trace the boundaries of the contours. (See: #rcBuildContours)
 	RC_TIMER_BUILD_CONTOURS_TRACE,
+	/// The time to simplify the contours. (See: #rcBuildContours)
 	RC_TIMER_BUILD_CONTOURS_SIMPLIFY,
+	/// The time to filter ledge spans. (See: #rcFilterLedgeSpans)
 	RC_TIMER_FILTER_BORDER,
+	/// The time to filter low height spans. (See: #rcFilterWalkableLowHeightSpans)
 	RC_TIMER_FILTER_WALKABLE,
+	/// The time to apply the median filter. (See: #rcMedianFilterWalkableArea)
 	RC_TIMER_MEDIAN_AREA,
+	/// The time to filter low obstacles. (See: #rcFilterLowHangingWalkableObstacles)
 	RC_TIMER_FILTER_LOW_OBSTACLES,
+	/// The time to build the polygon mesh. (See: #rcBuildPolyMesh)
 	RC_TIMER_BUILD_POLYMESH,
+	/// The time to merge polygon meshes. (See: #rcMergePolyMeshes)
 	RC_TIMER_MERGE_POLYMESH,
+	/// The time to erode the walkable area. (See: #rcErodeWalkableArea)
 	RC_TIMER_ERODE_AREA,
+	/// The time to mark a box area. (See: #rcMarkBoxArea)
 	RC_TIMER_MARK_BOX_AREA,
+	/// The time to mark a cylinder area. (See: #rcMarkCylinderArea)
+	RC_TIMER_MARK_CYLINDER_AREA,
+	/// The time to mark a convex polygon area. (See: #rcMarkConvexPolyArea)
 	RC_TIMER_MARK_CONVEXPOLY_AREA,
+	/// The total time to build the distance field. (See: #rcBuildDistanceField)
 	RC_TIMER_BUILD_DISTANCEFIELD,
+	/// The time to build the distances of the distance field. (See: #rcBuildDistanceField)
 	RC_TIMER_BUILD_DISTANCEFIELD_DIST,
+	/// The time to blur the distance field. (See: #rcBuildDistanceField)
 	RC_TIMER_BUILD_DISTANCEFIELD_BLUR,
+	/// The total time to build the regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
 	RC_TIMER_BUILD_REGIONS,
+	/// The total time to apply the watershed algorithm. (See: #rcBuildRegions)
 	RC_TIMER_BUILD_REGIONS_WATERSHED,
+	/// The time to expand regions while applying the watershed algorithm. (See: #rcBuildRegions)
 	RC_TIMER_BUILD_REGIONS_EXPAND,
+	/// The time to flood regions while applying the watershed algorithm. (See: #rcBuildRegions)
 	RC_TIMER_BUILD_REGIONS_FLOOD,
+	/// The time to filter out small regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
 	RC_TIMER_BUILD_REGIONS_FILTER,
+	/// The time to build heightfield layers. (See: #rcBuildHeightfieldLayers)
+	RC_TIMER_BUILD_LAYERS, 
+	/// The time to build the polygon mesh detail. (See: #rcBuildPolyMeshDetail)
 	RC_TIMER_BUILD_POLYMESHDETAIL,
+	/// The time to merge polygon mesh details. (See: #rcMergePolyMeshDetails)
 	RC_TIMER_MERGE_POLYMESHDETAIL,
+	/// The maximum number of timers.  (Used for iterating timers.)
 	RC_MAX_TIMERS
 };
 
-// Simple dynamic array ints.
+/// A simple dynamic array of integers.
 class rcIntArray
 {
 	int* m_data;
@@ -68,309 +103,563 @@
 	inline rcIntArray(const rcIntArray&);
 	inline rcIntArray& operator=(const rcIntArray&);
 public:
+
+	/// Constructs an instance with an initial array size of zero.
 	inline rcIntArray() : m_data(0), m_size(0), m_cap(0) {}
+
+	/// Constructs an instance initialized to the specified size.
+	///  @param[in]		n	The initial size of the integer array.
 	inline rcIntArray(int n) : m_data(0), m_size(0), m_cap(0) { resize(n); }
 	inline ~rcIntArray() { free(m_data); }
+
+	/// Specifies the new size of the integer array.
+	///  @param[in]		n	The new size of the integer array.
 	void resize(int n);
+
+	/// Push the specified integer onto the end of the array and increases the size by one.
+	///  @param[in]		item	The new value.
 	inline void push(int item) { resize(m_size+1); m_data[m_size-1] = item; }
+
+	/// Returns the value at the end of the array and reduces the size by one.
+	///  @return The value at the end of the array.
 	inline int pop() { if (m_size > 0) m_size--; return m_data[m_size]; }
+
+	/// The value at the specified array index.
+	/// @warning Does not provide overflow protection.
+	///  @param[in]		i	The index of the value.
 	inline const int& operator[](int i) const { return m_data[i]; }
+
+	/// The value at the specified array index.
+	/// @warning Does not provide overflow protection.
+	///  @param[in]		i	The index of the value.
 	inline int& operator[](int i) { return m_data[i]; }
+
+	/// The current size of the integer array.
 	inline int size() const { return m_size; }
 };
 
-// Simple internal helper class to delete array in scope
+/// A simple helper class used to delete an array when it goes out of scope.
+/// @note This class is rarely if ever used by the end user.
 template<class T> class rcScopedDelete
 {
 	T* ptr;
 	inline T* operator=(T* p);
 public:
+
+	/// Constructs an instance with a null pointer.
 	inline rcScopedDelete() : ptr(0) {}
+
+	/// Constructs an instance with the specified pointer.
+	///  @param[in]		p	An pointer to an allocated array.
 	inline rcScopedDelete(T* p) : ptr(p) {}
 	inline ~rcScopedDelete() { free(ptr); }
+
+	/// The root array pointer.
+	///  @return The root array pointer.
 	inline operator T*() { return ptr; }
 };
 
-// Build context provides several optional utilities needed for the build process,
-// such as timing, logging, and build time collecting. 
+/// Provides an interface for optional logging and performance tracking of the Recast 
+/// build process.
+/// @ingroup recast
 class rcContext
 {
 public:
+
+	/// Contructor.
+	///  @param[in]		state	TRUE if the logging and performance timers should be enabled.  [Default: true]
 	inline rcContext(bool state = true) : m_logEnabled(state), m_timerEnabled(state) {}
 	virtual ~rcContext() {}
 
-	// Enables or disables logging.
+	/// Enables or disables logging.
+	///  @param[in]		state	TRUE if logging should be enabled.
 	inline void enableLog(bool state) { m_logEnabled = state; }
-	// Resets log.
+
+	/// Clears all log entries.
 	inline void resetLog() { if (m_logEnabled) doResetLog(); }
-	// Logs a message.
+
+	/// Logs a message.
+	///  @param[in]		category	The category of the message.
+	///  @param[in]		format		The message.
 	void log(const rcLogCategory category, const char* format, ...);
 
-	// Enables or disables timer.
+	/// Enables or disables the performance timers.
+	///  @param[in]		state	TRUE if timers should be enabled.
 	inline void enableTimer(bool state) { m_timerEnabled = state; }
-	// Resets all timers.
+
+	/// Clears all peformance timers. (Resets all to unused.)
 	inline void resetTimers() { if (m_timerEnabled) doResetTimers(); }
-	// Starts timer, used for performance timing.
+
+	/// Starts the specified performance timer.
+	///  @param	label	The category of timer.
 	inline void startTimer(const rcTimerLabel label) { if (m_timerEnabled) doStartTimer(label); }
-	// Stops timer, used for performance timing.
+
+	/// Stops the specified performance timer.
+	///  @param	label	The category of the timer.
 	inline void stopTimer(const rcTimerLabel label) { if (m_timerEnabled) doStopTimer(label); }
-	// Returns time accumulated between timer start/stop.
+
+	/// Returns the total accumulated time of the specified performance timer.
+	///  @param	label	The category of the timer.
+	///  @return The accumulated time of the timer, or -1 if timers are disabled or the timer has never been started.
 	inline int getAccumulatedTime(const rcTimerLabel label) const { return m_timerEnabled ? doGetAccumulatedTime(label) : -1; }
 
 protected:
-	// Virtual functions to override for custom implementations.
+
+	/// Clears all log entries.
 	virtual void doResetLog() {}
+
+	/// Logs a message.
+	///  @param[in]		category	The category of the message.
+	///  @param[in]		msg			The formatted message.
+	///  @param[in]		len			The length of the formatted message.
 	virtual void doLog(const rcLogCategory /*category*/, const char* /*msg*/, const int /*len*/) {}
+
+	/// Clears all timers. (Resets all to unused.)
 	virtual void doResetTimers() {}
+
+	/// Starts the specified performance timer.
+	///  @param[in]		label	The category of timer.
 	virtual void doStartTimer(const rcTimerLabel /*label*/) {}
+
+	/// Stops the specified performance timer.
+	///  @param[in]		label	The category of the timer.
 	virtual void doStopTimer(const rcTimerLabel /*label*/) {}
+
+	/// Returns the total accumulated time of the specified performance timer.
+	///  @param[in]		label	The category of the timer.
+	///  @return The accumulated time of the timer, or -1 if timers are disabled or the timer has never been started.
 	virtual int doGetAccumulatedTime(const rcTimerLabel /*label*/) const { return -1; }
 	
+	/// True if logging is enabled.
 	bool m_logEnabled;
+
+	/// True if the performance timers are enabled.
 	bool m_timerEnabled;
 };
 
-
-// The units of the parameters are specified in parenthesis as follows:
-// (vx) voxels, (wu) world units
+/// Specifies a configuration to use when performing Recast builds.
+/// @ingroup recast
 struct rcConfig
 {
-	int width, height;				// Dimensions of the rasterized heightfield (vx)
-	int tileSize;					// Width and Height of a tile (vx)
-	int borderSize;					// Non-navigable Border around the heightfield (vx)
-	float cs, ch;					// Grid cell size and height (wu)
-	float bmin[3], bmax[3];			// Grid bounds (wu)
-	float walkableSlopeAngle;		// Maximum walkable slope angle in degrees.
-	int walkableHeight;				// Minimum height where the agent can still walk (vx)
-	int walkableClimb;				// Maximum height between grid cells the agent can climb (vx)
-	int walkableRadius;				// Radius of the agent in cells (vx)
-	int maxEdgeLen;					// Maximum contour edge length (vx)
-	float maxSimplificationError;	// Maximum distance error from contour to cells (vx)
-	int minRegionArea;				// Regions whose area is smaller than this threshold will be removed. (vx)
-	int mergeRegionArea;			// Regions whose area is smaller than this threshold will be merged (vx)
-	int maxVertsPerPoly;			// Max number of vertices per polygon
-	float detailSampleDist;			// Detail mesh sample spacing.
-	float detailSampleMaxError;		// Detail mesh simplification max sample error.
+	/// The width of the field along the x-axis. [Limit: >= 0] [Units: vx]
+	int width;
+
+	/// The height of the field along the z-axis. [Limit: >= 0] [Units: vx]
+	int height;
+	
+	/// The width/height size of tile's on the xz-plane. [Limit: >= 0] [Units: vx]
+	int tileSize;
+	
+	/// The size of the non-navigable border around the heightfield. [Limit: >=0] [Units: vx]
+	int borderSize;
+
+	/// The xz-plane cell size to use for fields. [Limit: > 0] [Units: wu] 
+	float cs;
+
+	/// The y-axis cell size to use for fields. [Limit: > 0] [Units: wu]
+	float ch;
+
+	/// The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu]
+	float bmin[3]; 
+
+	/// The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
+	float bmax[3];
+
+	/// The maximum slope that is considered walkable. [Limits: 0 <= value < 90] [Units: Degrees] 
+	float walkableSlopeAngle;
+
+	/// Minimum floor to 'ceiling' height that will still allow the floor area to 
+	/// be considered walkable. [Limit: >= 3] [Units: vx] 
+	int walkableHeight;
+	
+	/// Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx] 
+	int walkableClimb;
+	
+	/// The distance to erode/shrink the walkable area of the heightfield away from 
+	/// obstructions.  [Limit: >=0] [Units: vx] 
+	int walkableRadius;
+	
+	/// The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0] [Units: vx] 
+	int maxEdgeLen;
+	
+	/// The maximum distance a simplfied contour's border edges should deviate 
+	/// the original raw contour. [Limit: >=0] [Units: wu]
+	float maxSimplificationError;
+	
+	/// The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx] 
+	int minRegionArea;
+	
+	/// Any regions with a span count smaller than this value will, if possible, 
+	/// be merged with larger regions. [Limit: >=0] [Units: vx] 
+	int mergeRegionArea;
+	
+	/// The maximum number of vertices allowed for polygons generated during the 
+	/// contour to polygon conversion process. [Limit: >= 3] 
+	int maxVertsPerPoly;
+	
+	/// Sets the sampling distance to use when generating the detail mesh.
+	/// (For height detail only.) [Limits: 0 or >= 0.9] [Units: wu] 
+	float detailSampleDist;
+	
+	/// The maximum distance the detail mesh surface should deviate from heightfield
+	/// data. (For height detail only.) [Limit: >=0] [Units: wu] 
+	float detailSampleMaxError;
 };
 
-// Define number of bits in the above structure for smin/smax.
-// The max height is used for clamping rasterized values.
-static const int RC_SPAN_HEIGHT_BITS = 16;
+/// Defines the number of bits allocated to rcSpan::smin and rcSpan::smax.
+static const int RC_SPAN_HEIGHT_BITS = 13;
+/// Defines the maximum value for rcSpan::smin and rcSpan::smax.
 static const int RC_SPAN_MAX_HEIGHT = (1<<RC_SPAN_HEIGHT_BITS)-1;
 
-// Heightfield span.
+/// The number of spans allocated per span spool.
+/// @see rcSpanPool
+static const int RC_SPANS_PER_POOL = 2048;
+
+/// Represents a span in a heightfield.
+/// @see rcHeightfield
 struct rcSpan
 {
-	unsigned int smin : 16;			// Span min height.
-	unsigned int smax : 16;			// Span max height.
-    unsigned char area;				// Span area type.
-	rcSpan* next;					// Next span in column.
+	unsigned int smin : 13;			///< The lower limit of the span. [Limit: < #smax]
+	unsigned int smax : 13;			///< The upper limit of the span. [Limit: <= #RC_SPAN_MAX_HEIGHT]
+	unsigned int area : 6;			///< The area id assigned to the span.
+	rcSpan* next;					///< The next span higher up in column.
 };
 
-// Number of spans allocated per pool.
-static const int RC_SPANS_PER_POOL = 2048;
-
-// Memory pool used for quick span allocation.
+/// A memory pool used for quick allocation of spans within a heightfield.
+/// @see rcHeightfield
 struct rcSpanPool
 {
-	rcSpanPool* next;					// Pointer to next pool.
-	rcSpan items[RC_SPANS_PER_POOL];	// Array of spans.
+	rcSpanPool* next;					///< The next span pool.
+	rcSpan items[RC_SPANS_PER_POOL];	///< Array of spans in the pool.
 };
 
-// Dynamic span-heightfield.
+/// A dynamic heightfield representing obstructed space.
+/// @ingroup recast
 struct rcHeightfield
 {
-	int width, height;			// Dimension of the heightfield.
-	float bmin[3], bmax[3];		// Bounding box of the heightfield
-	float cs, ch;				// Cell size and height.
-	rcSpan** spans;				// Heightfield of spans (width*height).
-	rcSpanPool* pools;			// Linked list of span pools.
-	rcSpan* freelist;			// Pointer to next free span.
+	int width;			///< The width of the heightfield. (Along the x-axis in cell units.)
+	int height;			///< The height of the heightfield. (Along the z-axis in cell units.)
+	float bmin[3];  	///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];		///< The maximum bounds in world space. [(x, y, z)]
+	float cs;			///< The size of each cell. (On the xz-plane.)
+	float ch;			///< The height of each cell. (The minimum increment along the y-axis.)
+	rcSpan** spans;		///< Heightfield of spans (width*height).
+	rcSpanPool* pools;	///< Linked list of span pools.
+	rcSpan* freelist;	///< The next free span.
 };
 
-rcHeightfield* mallocHeightfield();
-void freeHeightField(rcHeightfield* hf);
-
-
+/// Provides information on the content of a cell column in a compact heightfield. 
 struct rcCompactCell
 {
-	unsigned int index : 24;	// Index to first span in column.
-	unsigned int count : 8;		// Number of spans in this column.
+	unsigned int index : 24;	///< Index to the first span in the column.
+	unsigned int count : 8;		///< Number of spans in the column.
 };
 
+/// Represents a span of unobstructed space within a compact heightfield.
 struct rcCompactSpan
 {
-	unsigned short y;			// Bottom coordinate of the span.
-	unsigned short reg;
-	unsigned int con : 24;		// Connections to neighbour cells.
-	unsigned int h : 8;			// Height of the span.
+	unsigned short y;			///< The lower extent of the span. (Measured from the heightfield's base.)
+	unsigned short reg;			///< The id of the region the span belongs to. (Or zero if not in a region.)
+	unsigned int con : 24;		///< Packed neighbor connection data.
+	unsigned int h : 8;			///< The height of the span.  (Measured from #y.)
 };
 
-// Compact static heightfield. 
+/// A compact, static heightfield representing unobstructed space.
+/// @ingroup recast
 struct rcCompactHeightfield
 {
-	int width, height;					// Width and height of the heightfield.
-	int spanCount;						// Number of spans in the heightfield.
-	int walkableHeight, walkableClimb;	// Agent properties.
-	unsigned short maxDistance;			// Maximum distance value stored in heightfield.
-	unsigned short maxRegions;			// Maximum Region Id stored in heightfield.
-	float bmin[3], bmax[3];				// Bounding box of the heightfield.
-	float cs, ch;						// Cell size and height.
-	rcCompactCell* cells;				// Pointer to width*height cells.
-	rcCompactSpan* spans;				// Pointer to spans.
-	unsigned short* dist;				// Pointer to per span distance to border.
-	unsigned char* areas;				// Pointer to per span area ID.
+	int width;					///< The width of the heightfield. (Along the x-axis in cell units.)
+	int height;					///< The height of the heightfield. (Along the z-axis in cell units.)
+	int spanCount;				///< The number of spans in the heightfield.
+	int walkableHeight;			///< The walkable height used during the build of the field.  (See: rcConfig::walkableHeight)
+	int walkableClimb;			///< The walkable climb used during the build of the field. (See: rcConfig::walkableClimb)
+	int borderSize;				///< The AABB border size used during the build of the field. (See: rcConfig::borderSize)
+	unsigned short maxDistance;	///< The maximum distance value of any span within the field. 
+	unsigned short maxRegions;	///< The maximum region id of any span within the field. 
+	float bmin[3];				///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];				///< The maximum bounds in world space. [(x, y, z)]
+	float cs;					///< The size of each cell. (On the xz-plane.)
+	float ch;					///< The height of each cell. (The minimum increment along the y-axis.)
+	rcCompactCell* cells;		///< Array of cells. [Size: #width*#height]
+	rcCompactSpan* spans;		///< Array of spans. [Size: #spanCount]
+	unsigned short* dist;		///< Array containing border distance data. [Size: #spanCount]
+	unsigned char* areas;		///< Array containing area id data. [Size: #spanCount]
 };
 
-rcCompactHeightfield* mallocCompactHeightfield();
-void freeCompactHeightfield(rcCompactHeightfield* chf);
+/// Represents a heightfield layer within a layer set.
+/// @see rcHeightfieldLayerSet
+struct rcHeightfieldLayer
+{
+	float bmin[3];				///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];				///< The maximum bounds in world space. [(x, y, z)]
+	float cs;					///< The size of each cell. (On the xz-plane.)
+	float ch;					///< The height of each cell. (The minimum increment along the y-axis.)
+	int width;					///< The width of the heightfield. (Along the x-axis in cell units.)
+	int height;					///< The height of the heightfield. (Along the z-axis in cell units.)
+	int minx;					///< The minimum x-bounds of usable data.
+	int maxx;					///< The maximum x-bounds of usable data.
+	int miny;					///< The minimum y-bounds of usable data. (Along the z-axis.)
+	int maxy;					///< The maximum y-bounds of usable data. (Along the z-axis.)
+	int hmin;					///< The minimum height bounds of usable data. (Along the y-axis.)
+	int hmax;					///< The maximum height bounds of usable data. (Along the y-axis.)
+	unsigned char* heights;		///< The heightfield. [Size: (width - borderSize*2) * (h - borderSize*2)]
+	unsigned char* areas;		///< Area ids. [Size: Same as #heights]
+	unsigned char* cons;		///< Packed neighbor connection information. [Size: Same as #heights]
+};
 
+/// Represents a set of heightfield layers.
+/// @ingroup recast
+/// @see mallocHeightfieldLayerSet, freeHeightfieldLayerSet 
+struct rcHeightfieldLayerSet
+{
+	rcHeightfieldLayer* layers;			///< The layers in the set. [Size: #nlayers]
+	int nlayers;						///< The number of layers in the set.
+};
 
+/// Represents a simple, non-overlapping contour in field space.
 struct rcContour
 {
-	int* verts;			// Vertex coordinates, each vertex contains 4 components.
-	int nverts;			// Number of vertices.
-	int* rverts;		// Raw vertex coordinates, each vertex contains 4 components.
-	int nrverts;		// Number of raw vertices.
-	unsigned short reg;	// Region ID of the contour.
-	unsigned char area;	// Area ID of the contour.
+	int* verts;			///< Simplified contour vertex and connection data. [Size: 4 * #nverts]
+	int nverts;			///< The number of vertices in the simplified contour. 
+	int* rverts;		///< Raw contour vertex and connection data. [Size: 4 * #nrverts]
+	int nrverts;		///< The number of vertices in the raw contour. 
+	unsigned short reg;	///< The region id of the contour.
+	unsigned char area;	///< The area id of the contour.
 };
 
+/// Represents a group of related contours.
+/// @ingroup recast
 struct rcContourSet
 {
-	rcContour* conts;		// Pointer to all contours.
-	int nconts;				// Number of contours.
-	float bmin[3], bmax[3];	// Bounding box of the heightfield.
-	float cs, ch;			// Cell size and height.
+	rcContour* conts;	///< An array of the contours in the set. [Size: #nconts]
+	int nconts;			///< The number of contours in the set.
+	float bmin[3];  	///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];		///< The maximum bounds in world space. [(x, y, z)]
+	float cs;			///< The size of each cell. (On the xz-plane.)
+	float ch;			///< The height of each cell. (The minimum increment along the y-axis.)
+	int width;			///< The width of the set. (Along the x-axis in cell units.) 
+	int height;			///< The height of the set. (Along the z-axis in cell units.) 
+	int borderSize;		///< The AABB border size used to generate the source data from which the contours were derived.
 };
 
-rcContourSet* mallocContourSet();
-void freeContourSet(rcContourSet* cset);
-
-
-// Polymesh store a connected mesh of polygons.
-// The polygons are store in an array where each polygons takes
-// 'nvp*2' elements. The first 'nvp' elements are indices to vertices
-// and the second 'nvp' elements are indices to neighbour polygons.
-// If a polygon has less than 'bvp' vertices, the remaining indices
-// are set to RC_MESH_NULL_IDX. If an polygon edge does not have a neighbour
-// the neighbour index is set to RC_MESH_NULL_IDX.
-// Vertices can be transformed into world space as follows:
-//   x = bmin[0] + verts[i*3+0]*cs;
-//   y = bmin[1] + verts[i*3+1]*ch;
-//   z = bmin[2] + verts[i*3+2]*cs;
+/// Represents a polygon mesh suitable for use in building a navigation mesh. 
+/// @ingroup recast
 struct rcPolyMesh
-{	
-	unsigned short* verts;	// Vertices of the mesh, 3 elements per vertex.
-	unsigned short* polys;	// Polygons of the mesh, nvp*2 elements per polygon.
-	unsigned short* regs;	// Region ID of the polygons.
-	unsigned short* flags;	// Per polygon flags.
-	unsigned char* areas;	// Area ID of polygons.
-	int nverts;				// Number of vertices.
-	int npolys;				// Number of polygons.
-	int maxpolys;			// Number of allocated polygons.
-	int nvp;				// Max number of vertices per polygon.
-	float bmin[3], bmax[3];	// Bounding box of the mesh.
-	float cs, ch;			// Cell size and height.
+{
+	unsigned short* verts;	///< The mesh vertices. [Form: (x, y, z) * #nverts]
+	unsigned short* polys;	///< Polygon and neighbor data. [Length: #maxpolys * 2 * #nvp]
+	unsigned short* regs;	///< The region id assigned to each polygon. [Length: #maxpolys]
+	unsigned short* flags;	///< The user defined flags for each polygon. [Length: #maxpolys]
+	unsigned char* areas;	///< The area id assigned to each polygon. [Length: #maxpolys]
+	int nverts;				///< The number of vertices.
+	int npolys;				///< The number of polygons.
+	int maxpolys;			///< The number of allocated polygons.
+	int nvp;				///< The maximum number of vertices per polygon.
+	float bmin[3];			///< The minimum bounds in world space. [(x, y, z)]
+	float bmax[3];			///< The maximum bounds in world space. [(x, y, z)]
+	float cs;				///< The size of each cell. (On the xz-plane.)
+	float ch;				///< The height of each cell. (The minimum increment along the y-axis.)
+	int borderSize;			///< The AABB border size used to generate the source data from which the mesh was derived.
 };
 
-rcPolyMesh* mallocPolyMesh();
-void freePolyMesh(rcPolyMesh* pmesh);
-
-
-// Detail mesh generated from a rcPolyMesh.
-// Each submesh represents a polygon in the polymesh and they are stored in
-// exactly same order. Each submesh is described as 4 values:
-// base vertex, vertex count, base triangle, triangle count. That is,
-//   const unsigned char* t = &dmesh.tris[(tbase+i)*3]; and
-//   const float* v = &dmesh.verts[(vbase+t[j])*3];
-// If the input polygon has 'n' vertices, those vertices are first in the
-// submesh vertex list. This allows to compres the mesh by not storing the
-// first vertices and using the polymesh vertices instead.
-// Max number of vertices per submesh is 127 and
-// max number of triangles per submesh is 255.
-
+/// Contains triangle meshes that represent detailed height data associated 
+/// with the polygons in its associated polygon mesh object.
+/// @ingroup recast
 struct rcPolyMeshDetail
 {
-	unsigned int* meshes;	// Pointer to all mesh data.
-	float* verts;			// Pointer to all vertex data.
-	unsigned char* tris;	// Pointer to all triangle data.
-	int nmeshes;			// Number of meshes.
-	int nverts;				// Number of total vertices.
-	int ntris;				// Number of triangles.
+	unsigned int* meshes;	///< The sub-mesh data. [Size: 4*#nmeshes] 
+	float* verts;			///< The mesh vertices. [Size: 3*#nverts] 
+	unsigned char* tris;	///< The mesh triangles. [Size: 4*#ntris] 
+	int nmeshes;			///< The number of sub-meshes defined by #meshes.
+	int nverts;				///< The number of vertices in #verts.
+	int ntris;				///< The number of triangles in #tris.
 };
 
+/// @name Allocation Functions
+/// Functions used to allocate and de-allocate Recast objects.
+/// @see mallocSetCustom
+/// @{
+
+/// Allocates a heightfield object using the Recast allocator.
+///  @return A heightfield that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcCreateHeightfield, freeHeightField
+rcHeightfield* mallocHeightfield();
+
+/// Frees the specified heightfield object using the Recast allocator.
+///  @param[in]		hf	A heightfield allocated using #mallocHeightfield
+///  @ingroup recast
+///  @see mallocHeightfield
+void freeHeightField(rcHeightfield* hf);
+
+/// Allocates a compact heightfield object using the Recast allocator.
+///  @return A compact heightfield that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildCompactHeightfield, freeCompactHeightfield
+rcCompactHeightfield* mallocCompactHeightfield();
+
+/// Frees the specified compact heightfield object using the Recast allocator.
+///  @param[in]		chf		A compact heightfield allocated using #mallocCompactHeightfield
+///  @ingroup recast
+///  @see mallocCompactHeightfield
+void freeCompactHeightfield(rcCompactHeightfield* chf);
+
+/// Allocates a heightfield layer set using the Recast allocator.
+///  @return A heightfield layer set that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildHeightfieldLayers, freeHeightfieldLayerSet
+rcHeightfieldLayerSet* mallocHeightfieldLayerSet();
+
+/// Frees the specified heightfield layer set using the Recast allocator.
+///  @param[in]		lset	A heightfield layer set allocated using #mallocHeightfieldLayerSet
+///  @ingroup recast
+///  @see mallocHeightfieldLayerSet
+void freeHeightfieldLayerSet(rcHeightfieldLayerSet* lset);
+
+/// Allocates a contour set object using the Recast allocator.
+///  @return A contour set that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildContours, freeContourSet
+rcContourSet* mallocContourSet();
+
+/// Frees the specified contour set using the Recast allocator.
+///  @param[in]		cset	A contour set allocated using #mallocContourSet
+///  @ingroup recast
+///  @see mallocContourSet
+void freeContourSet(rcContourSet* cset);
+
+/// Allocates a polygon mesh object using the Recast allocator.
+///  @return A polygon mesh that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildPolyMesh, freePolyMesh
+rcPolyMesh* mallocPolyMesh();
+
+/// Frees the specified polygon mesh using the Recast allocator.
+///  @param[in]		pmesh	A polygon mesh allocated using #mallocPolyMesh
+///  @ingroup recast
+///  @see mallocPolyMesh
+void freePolyMesh(rcPolyMesh* pmesh);
+
+/// Allocates a detail mesh object using the Recast allocator.
+///  @return A detail mesh that is ready for initialization, or null on failure.
+///  @ingroup recast
+///  @see rcBuildPolyMeshDetail, freePolyMeshDetail
 rcPolyMeshDetail* mallocPolyMeshDetail();
+
+/// Frees the specified detail mesh using the Recast allocator.
+///  @param[in]		dmesh	A detail mesh allocated using #mallocPolyMeshDetail
+///  @ingroup recast
+///  @see mallocPolyMeshDetail
 void freePolyMeshDetail(rcPolyMeshDetail* dmesh);
 
+/// @}
 
-// If heightfield region ID has the following bit set, the region is on border area
-// and excluded from many calculations.
+/// Heighfield border flag.
+/// If a heightfield region ID has this bit set, then the region is a border 
+/// region and its spans are considered unwalkable.
+/// (Used during the region and contour build process.)
+/// @see rcCompactSpan::reg
 static const unsigned short RC_BORDER_REG = 0x8000;
 
-// If contour region ID has the following bit set, the vertex will be later
-// removed in order to match the segments and vertices at tile boundaries.
+/// Border vertex flag.
+/// If a region ID has this bit set, then the associated element lies on
+/// a tile border. If a contour vertex's region ID has this bit set, the 
+/// vertex will later be removed in order to match the segments and vertices 
+/// at tile boundaries.
+/// (Used during the build process.)
+/// @see rcCompactSpan::reg, #rcContour::verts, #rcContour::rverts
 static const int RC_BORDER_VERTEX = 0x10000;
 
+/// Area border flag.
+/// If a region ID has this bit set, then the associated element lies on
+/// the border of an area.
+/// (Used during the region and contour build process.)
+/// @see rcCompactSpan::reg, #rcContour::verts, #rcContour::rverts
 static const int RC_AREA_BORDER = 0x20000;
 
+/// Contour build flags.
+/// @see rcBuildContours
 enum rcBuildContoursFlags
 {
-	RC_CONTOUR_TESS_WALL_EDGES = 0x01,	// Tessellate wall edges
-	RC_CONTOUR_TESS_AREA_EDGES = 0x02,	// Tessellate edges between areas.
+	RC_CONTOUR_TESS_WALL_EDGES = 0x01,	///< Tessellate solid (impassable) edges during contour simplification.
+	RC_CONTOUR_TESS_AREA_EDGES = 0x02,	///< Tessellate edges between areas during contour simplification.
 };
 
-// Mask used with contours to extract region id.
+/// Applied to the region id field of contour vertices in order to extract the region id.
+/// The region id field of a vertex may have several flags applied to it.  So the
+/// fields value can't be used directly.
+/// @see rcContour::verts, rcContour::rverts
 static const int RC_CONTOUR_REG_MASK = 0xffff;
 
-// Null index which is used with meshes to mark unset or invalid indices.
+/// An value which indicates an invalid index within a mesh.
+/// @note This does not necessarily indicate an error.
+/// @see rcPolyMesh::polys
 static const unsigned short RC_MESH_NULL_IDX = 0xffff;
 
-// Area ID that is considered empty.
+/// Represents the null area.
+/// When a data element is given this value it is considered to no longer be 
+/// assigned to a usable area.  (E.g. It is unwalkable.)
 static const unsigned char RC_NULL_AREA = 0;
 
-// Area ID that is considered generally walkable.
+/// The default area id used to indicate a walkable polygon. 
+/// This is also the maximum allowed area id, and the only non-null area id 
+/// recognized by some steps in the build process. 
 static const unsigned char RC_WALKABLE_AREA = 63;
 
-// Value returned by rcGetCon() if the direction is not connected.
+/// The value returned by #rcGetCon if the specified direction is not connected
+/// to another span. (Has no neighbor.)
 static const int RC_NOT_CONNECTED = 0x3f;
 
-// Compact span neighbour helpers.
-inline void rcSetCon(rcCompactSpan& s, int dir, int i)
-{
-	const unsigned int shift = (unsigned int)dir*6;
-	unsigned int con = s.con;
-	s.con = (con & ~(0x3f << shift)) | (((unsigned int)i & 0x3f) << shift);
-}
+/// @name General helper functions
+/// @{
 
-inline int rcGetCon(const rcCompactSpan& s, int dir)
-{
-	const unsigned int shift = (unsigned int)dir*6;
-	return (s.con >> shift) & 0x3f;
-}
+/// Swaps the values of the two parameters.
+///  @param[in,out]	a	Value A
+///  @param[in,out]	b	Value B
+template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }
 
-inline int rcGetDirOffsetX(int dir)
-{
-	const int offset[4] = { -1, 0, 1, 0, };
-	return offset[dir&0x03];
-}
+/// Returns the minimum of two values.
+///  @param[in]		a	Value A
+///  @param[in]		b	Value B
+///  @return The minimum of the two values.
+template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }
 
-inline int rcGetDirOffsetY(int dir)
-{
-	const int offset[4] = { 0, 1, 0, -1 };
-	return offset[dir&0x03];
-}
+/// Returns the maximum of two values.
+///  @param[in]		a	Value A
+///  @param[in]		b	Value B
+///  @return The maximum of the two values.
+template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }
 
-// Common helper functions
-template<class T> inline void rcSwap(T& a, T& b) { T t = a; a = b; b = t; }
-template<class T> inline T rcMin(T a, T b) { return a < b ? a : b; }
-template<class T> inline T rcMax(T a, T b) { return a > b ? a : b; }
+/// Returns the absolute value.
+///  @param[in]		a	The value.
+///  @return The absolute value of the specified value.
 template<class T> inline T rcAbs(T a) { return a < 0 ? -a : a; }
+
+/// Returns the square of the value.
+///  @param[in]		a	The value.
+///  @return The square of the value.
 template<class T> inline T rcSqr(T a) { return a*a; }
+
+/// Clamps the value to the specified range.
+///  @param[in]		v	The value to clamp.
+///  @param[in]		mn	The minimum permitted return value.
+///  @param[in]		mx	The maximum permitted return value.
+///  @return The value, clamped to the specified range.
 template<class T> inline T rcClamp(T v, T mn, T mx) { return v < mn ? mn : (v > mx ? mx : v); }
+
+/// Returns the square root of the value.
+///  @param[in]		x	The value.
+///  @return The square root of the vlaue.
 float rcSqrt(float x);
 
-// Common vector helper functions.
+/// @}
+/// @name Vector helper functions.
+/// @{
+
+/// Derives the cross product of two vectors. (@p v1 x @p v2)
+///  @param[out]	dest	The cross product. [(x, y, z)]
+///  @param[in]		v1		A Vector [(x, y, z)]
+///  @param[in]		v2		A vector [(x, y, z)]
 inline void rcVcross(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[1]*v2[2] - v1[2]*v2[1];
@@ -378,11 +667,20 @@
 	dest[2] = v1[0]*v2[1] - v1[1]*v2[0];
 }
 
+/// Derives the dot product of two vectors. (@p v1 . @p v2)
+///  @param[in]		v1	A Vector [(x, y, z)]
+///  @param[in]		v2	A vector [(x, y, z)]
+/// @return The dot product.
 inline float rcVdot(const float* v1, const float* v2)
 {
 	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
 }
 
+/// Performs a scaled vector addition. (@p v1 + (@p v2 * @p s))
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to scale and add to @p v1. [(x, y, z)]
+///  @param[in]		s		The amount to scale @p v2 by before adding to @p v1.
 inline void rcVmad(float* dest, const float* v1, const float* v2, const float s)
 {
 	dest[0] = v1[0]+v2[0]*s;
@@ -390,6 +688,10 @@
 	dest[2] = v1[2]+v2[2]*s;
 }
 
+/// Performs a vector addition. (@p v1 + @p v2)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to add to @p v1. [(x, y, z)]
 inline void rcVadd(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[0]+v2[0];
@@ -397,6 +699,10 @@
 	dest[2] = v1[2]+v2[2];
 }
 
+/// Performs a vector subtraction. (@p v1 - @p v2)
+///  @param[out]	dest	The result vector. [(x, y, z)]
+///  @param[in]		v1		The base vector. [(x, y, z)]
+///  @param[in]		v2		The vector to subtract from @p v1. [(x, y, z)]
 inline void rcVsub(float* dest, const float* v1, const float* v2)
 {
 	dest[0] = v1[0]-v2[0];
@@ -404,6 +710,9 @@
 	dest[2] = v1[2]-v2[2];
 }
 
+/// Selects the minimum value of each element from the specified vectors.
+///  @param[in,out]	mn	A vector.  (Will be updated with the result.) [(x, y, z)]
+///  @param[in]		v	A vector. [(x, y, z)]
 inline void rcVmin(float* mn, const float* v)
 {
 	mn[0] = rcMin(mn[0], v[0]);
@@ -411,6 +720,9 @@
 	mn[2] = rcMin(mn[2], v[2]);
 }
 
+/// Selects the maximum value of each element from the specified vectors.
+///  @param[in,out]	mx	A vector.  (Will be updated with the result.) [(x, y, z)]
+///  @param[in]		v	A vector. [(x, y, z)]
 inline void rcVmax(float* mx, const float* v)
 {
 	mx[0] = rcMax(mx[0], v[0]);
@@ -418,6 +730,9 @@
 	mx[2] = rcMax(mx[2], v[2]);
 }
 
+/// Performs a vector copy.
+///  @param[out]	dest	The result. [(x, y, z)]
+///  @param[in]		v		The vector to copy. [(x, y, z)]
 inline void rcVcopy(float* dest, const float* v)
 {
 	dest[0] = v[0];
@@ -425,6 +740,10 @@
 	dest[2] = v[2];
 }
 
+/// Returns the distance between two points.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The distance between the two points.
 inline float rcVdist(const float* v1, const float* v2)
 {
 	float dx = v2[0] - v1[0];
@@ -433,6 +752,10 @@
 	return rcSqrt(dx*dx + dy*dy + dz*dz);
 }
 
+/// Returns the square of the distance between two points.
+///  @param[in]		v1	A point. [(x, y, z)]
+///  @param[in]		v2	A point. [(x, y, z)]
+/// @return The square of the distance between the two points.
 inline float rcVdistSqr(const float* v1, const float* v2)
 {
 	float dx = v2[0] - v1[0];
@@ -441,6 +764,8 @@
 	return dx*dx + dy*dy + dz*dz;
 }
 
+/// Normalizes the vector.
+///  @param[in,out]	v	The vector to normalize. [(x, y, z)]
 inline void rcVnormalize(float* v)
 {
 	float d = 1.0f / rcSqrt(rcSqr(v[0]) + rcSqr(v[1]) + rcSqr(v[2]));
@@ -449,271 +774,403 @@
 	v[2] *= d;
 }
 
-inline bool rcVequal(const float* p0, const float* p1)
-{
-	static const float thr = rcSqr(1.0f/16384.0f);
-	const float d = rcVdistSqr(p0, p1);
-	return d < thr;
-}
+/// @}
+/// @name Heightfield Functions
+/// @see rcHeightfield
+/// @{
 
-// Calculated bounding box of array of vertices.
-// Params:
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	bmin, bmax - (out) bounding box
+/// Calculates the bounding box of an array of vertices.
+///  @ingroup recast
+///  @param[in]		verts	An array of vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv		The number of vertices in the @p verts array.
+///  @param[out]	bmin	The minimum bounds of the AABB. [(x, y, z)] [Units: wu]
+///  @param[out]	bmax	The maximum bounds of the AABB. [(x, y, z)] [Units: wu]
 void rcCalcBounds(const float* verts, int nv, float* bmin, float* bmax);
 
-// Calculates grid size based on bounding box and grid cell size.
-// Params:
-//	bmin, bmax - (in) bounding box
-//	cs - (in) grid cell size
-//	w - (out) grid width
-//	h - (out) grid height
+/// Calculates the grid size based on the bounding box and grid cell size.
+///  @ingroup recast
+///  @param[in]		bmin	The minimum bounds of the AABB. [(x, y, z)] [Units: wu]
+///  @param[in]		bmax	The maximum bounds of the AABB. [(x, y, z)] [Units: wu]
+///  @param[in]		cs		The xz-plane cell size. [Limit: > 0] [Units: wu]
+///  @param[out]	w		The width along the x-axis. [Limit: >= 0] [Units: vx]
+///  @param[out]	h		The height along the z-axis. [Limit: >= 0] [Units: vx]
 void rcCalcGridSize(const float* bmin, const float* bmax, float cs, int* w, int* h);
 
-// Creates and initializes new heightfield.
-// Params:
-//	hf - (in/out) heightfield to initialize.
-//	width - (in) width of the heightfield.
-//	height - (in) height of the heightfield.
-//	bmin, bmax - (in) bounding box of the heightfield
-//	cs - (in) grid cell size
-//	ch - (in) grid cell height
+/// Initializes a new heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in,out]	hf		The allocated heightfield to initialize.
+///  @param[in]		width	The width of the field along the x-axis. [Limit: >= 0] [Units: vx]
+///  @param[in]		height	The height of the field along the z-axis. [Limit: >= 0] [Units: vx]
+///  @param[in]		bmin	The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu]
+///  @param[in]		bmax	The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
+///  @param[in]		cs		The xz-plane cell size to use for the field. [Limit: > 0] [Units: wu]
+///  @param[in]		ch		The y-axis cell size to use for field. [Limit: > 0] [Units: wu]
 bool rcCreateHeightfield(rcContext* ctx, rcHeightfield& hf, int width, int height,
 						 const float* bmin, const float* bmax,
 						 float cs, float ch);
 
-// Sets the RC_WALKABLE_AREA for every triangle whose slope is below
-// the maximum walkable slope angle.
-// Params:
-//	walkableSlopeAngle - (in) maximum slope angle in degrees.
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	tris - (in) array of triangle vertex indices
-//	nt - (in) triangle count
-//	areas - (out) array of triangle area types
+/// Sets the area id of all triangles with a slope below the specified value
+/// to #RC_WALKABLE_AREA.
+///  @ingroup recast
+///  @param[in,out]	ctx					The build context to use during the operation.
+///  @param[in]		walkableSlopeAngle	The maximum slope that is considered walkable.
+///  									[Limits: 0 <= value < 90] [Units: Degrees]
+///  @param[in]		verts				The vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv					The number of vertices.
+///  @param[in]		tris				The triangle vertex indices. [(vertA, vertB, vertC) * @p nt]
+///  @param[in]		nt					The number of triangles.
+///  @param[out]	areas				The triangle area ids. [Length: >= @p nt]
 void rcMarkWalkableTriangles(rcContext* ctx, const float walkableSlopeAngle, const float* verts, int nv,
 							 const int* tris, int nt, unsigned char* areas); 
 
-// Sets the RC_NULL_AREA for every triangle whose slope is steeper than
-// the maximum walkable slope angle.
-// Params:
-//	walkableSlopeAngle - (in) maximum slope angle in degrees.
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	tris - (in) array of triangle vertex indices
-//	nt - (in) triangle count
-//	areas - (out) array of triangle are types
+/// Sets the area id of all triangles with a slope greater than or equal to the specified value to #RC_NULL_AREA.
+///  @ingroup recast
+///  @param[in,out]	ctx					The build context to use during the operation.
+///  @param[in]		walkableSlopeAngle	The maximum slope that is considered walkable.
+///  									[Limits: 0 <= value < 90] [Units: Degrees]
+///  @param[in]		verts				The vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv					The number of vertices.
+///  @param[in]		tris				The triangle vertex indices. [(vertA, vertB, vertC) * @p nt]
+///  @param[in]		nt					The number of triangles.
+///  @param[out]	areas				The triangle area ids. [Length: >= @p nt]
 void rcClearUnwalkableTriangles(rcContext* ctx, const float walkableSlopeAngle, const float* verts, int nv,
 								const int* tris, int nt, unsigned char* areas); 
 
-// Adds span to heightfield.
-// The span addition can set to favor flags. If the span is merged to
-// another span and the new smax is within 'flagMergeThr' units away
-// from the existing span the span flags are merged and stored.
-// Params:
-//	solid - (in) heightfield where the spans is added to
-//  x,y - (in) location on the heightfield where the span is added
-//  smin,smax - (in) spans min/max height
-//  flags - (in) span flags (zero or WALKABLE)
-//  flagMergeThr - (in) merge threshold.
-void rcAddSpan(rcContext* ctx, rcHeightfield& solid, const int x, const int y,
+/// Adds a span to the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in,out]	hf				An initialized heightfield.
+///  @param[in]		x				The width index where the span is to be added.
+///  								[Limits: 0 <= value < rcHeightfield::width]
+///  @param[in]		y				The height index where the span is to be added.
+///  								[Limits: 0 <= value < rcHeightfield::height]
+///  @param[in]		smin			The minimum height of the span. [Limit: < @p smax] [Units: vx]
+///  @param[in]		smax			The maximum height of the span. [Limit: <= #RC_SPAN_MAX_HEIGHT] [Units: vx]
+///  @param[in]		area			The area id of the span. [Limit: <= #RC_WALKABLE_AREA)
+///  @param[in]		flagMergeThr	The merge theshold. [Limit: >= 0] [Units: vx]
+void rcAddSpan(rcContext* ctx, rcHeightfield& hf, const int x, const int y,
 			   const unsigned short smin, const unsigned short smax,
-			   const unsigned short area, const int flagMergeThr);
+			   const unsigned char area, const int flagMergeThr);
 
-// Rasterizes a triangle into heightfield spans.
-// Params:
-//	v0,v1,v2 - (in) the vertices of the triangle.
-//	area - (in) area type of the triangle.
-//	solid - (in) heightfield where the triangle is rasterized
-//  flagMergeThr - (in) distance in voxel where walkable flag is favored over non-walkable.
+/// Rasterizes a triangle into the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		v0				Triangle vertex 0 [(x, y, z)]
+///  @param[in]		v1				Triangle vertex 1 [(x, y, z)]
+///  @param[in]		v2				Triangle vertex 2 [(x, y, z)]
+///  @param[in]		area			The area id of the triangle. [Limit: <= #RC_WALKABLE_AREA]
+///  @param[in,out]	solid			An initialized heightfield.
+///  @param[in]		flagMergeThr	The distance where the walkable flag is favored over the non-walkable flag.
+///  								[Limit: >= 0] [Units: vx]
 void rcRasterizeTriangle(rcContext* ctx, const float* v0, const float* v1, const float* v2,
 						 const unsigned char area, rcHeightfield& solid,
 						 const int flagMergeThr = 1);
 
-// Rasterizes indexed triangle mesh into heightfield spans.
-// Params:
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	tris - (in) array of triangle vertex indices
-//	area - (in) array of triangle area types.
-//	nt - (in) triangle count
-//	solid - (in) heightfield where the triangles are rasterized
-//  flagMergeThr - (in) distance in voxel where walkable flag is favored over non-walkable.
+/// Rasterizes an indexed triangle mesh into the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		verts			The vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv				The number of vertices.
+///  @param[in]		tris			The triangle indices. [(vertA, vertB, vertC) * @p nt]
+///  @param[in]		areas			The area id's of the triangles. [Limit: <= #RC_WALKABLE_AREA] [Size: @p nt]
+///  @param[in]		nt				The number of triangles.
+///  @param[in,out]	solid			An initialized heightfield.
+///  @param[in]		flagMergeThr	The distance where the walkable flag is favored over the non-walkable flag. 
+///  								[Limit: >= 0] [Units: vx]
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int nv,
 						  const int* tris, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr = 1);
 
-// Rasterizes indexed triangle mesh into heightfield spans.
-// Params:
-//	verts - (in) array of vertices
-//	nv - (in) vertex count
-//	tris - (in) array of triangle vertex indices
-//	area - (in) array of triangle area types.
-//	nt - (in) triangle count
-//	solid - (in) heightfield where the triangles are rasterized
-//  flagMergeThr - (in) distance in voxel where walkable flag is favored over non-walkable.
+/// Rasterizes an indexed triangle mesh into the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx			The build context to use during the operation.
+///  @param[in]		verts		The vertices. [(x, y, z) * @p nv]
+///  @param[in]		nv			The number of vertices.
+///  @param[in]		tris		The triangle indices. [(vertA, vertB, vertC) * @p nt]
+///  @param[in]		areas		The area id's of the triangles. [Limit: <= #RC_WALKABLE_AREA] [Size: @p nt]
+///  @param[in]		nt			The number of triangles.
+///  @param[in,out]	solid		An initialized heightfield.
+///  @param[in]		flagMergeThr	The distance where the walkable flag is favored over the non-walkable flag. 
+///  							[Limit: >= 0] [Units: vx]
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int nv,
 						  const unsigned short* tris, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr = 1);
 
-// Rasterizes the triangles into heightfield spans.
-// Params:
-//	verts - (in) array of vertices
-//	area - (in) array of triangle area types.
-//	nt - (in) triangle count
-//	solid - (in) heightfield where the triangles are rasterized
+/// Rasterizes triangles into the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		verts			The triangle vertices. [(ax, ay, az, bx, by, bz, cx, by, cx) * @p nt]
+///  @param[in]		areas			The area id's of the triangles. [Limit: <= #RC_WALKABLE_AREA] [Size: @p nt]
+///  @param[in]		nt				The number of triangles.
+///  @param[in,out]	solid			An initialized heightfield.
+///  @param[in]		flagMergeThr	The distance where the walkable flag is favored over the non-walkable flag. 
+///  								[Limit: >= 0] [Units: vx]
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr = 1);
 
-// Marks non-walkable low obstacles as walkable if they are closer than walkableClimb
-// from a walkable surface. Applying this filter allows to step over low hanging
-// low obstacles.
-// Params:
-//	walkableHeight - (in) minimum height where the agent can still walk
-//	solid - (in/out) heightfield describing the solid space
-// TODO: Missuses ledge flag, must be called before rcFilterLedgeSpans!
+/// Marks non-walkable spans as walkable if their maximum is within @p walkableClimp of a walkable neihbor. 
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		walkableClimb	Maximum ledge height that is considered to still be traversable. 
+///  								[Limit: >=0] [Units: vx]
+///  @param[in,out]	solid			A fully built heightfield.  (All spans have been added.)
 void rcFilterLowHangingWalkableObstacles(rcContext* ctx, const int walkableClimb, rcHeightfield& solid);
 
-// Removes WALKABLE flag from all spans that are at ledges. This filtering
-// removes possible overestimation of the conservative voxelization so that
-// the resulting mesh will not have regions hanging in air over ledges.
-// Params:
-//	walkableHeight - (in) minimum height where the agent can still walk
-//	walkableClimb - (in) maximum height between grid cells the agent can climb
-//	solid - (in/out) heightfield describing the solid space
+/// Marks spans that are ledges as not-walkable. 
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area to 
+///  								be considered walkable. [Limit: >= 3] [Units: vx]
+///  @param[in]		walkableClimb	Maximum ledge height that is considered to still be traversable. 
+///  								[Limit: >=0] [Units: vx]
+///  @param[in,out]	solid			A fully built heightfield.  (All spans have been added.)
 void rcFilterLedgeSpans(rcContext* ctx, const int walkableHeight,
 						const int walkableClimb, rcHeightfield& solid);
 
-// Removes WALKABLE flag from all spans which have smaller than
-// 'walkableHeight' clearance above them.
-// Params:
-//	walkableHeight - (in) minimum height where the agent can still walk
-//	solid - (in/out) heightfield describing the solid space
+/// Marks walkable spans as not walkable if the clearence above the span is less than the specified height. 
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area to 
+///  								be considered walkable. [Limit: >= 3] [Units: vx]
+///  @param[in,out]	solid			A fully built heightfield.  (All spans have been added.)
 void rcFilterWalkableLowHeightSpans(rcContext* ctx, int walkableHeight, rcHeightfield& solid);
 
-// Returns number of spans contained in a heightfield.
-// Params:
-//	hf - (in) heightfield to be compacted
-// Returns number of spans.
+/// Returns the number of spans contained in the specified heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		hf		An initialized heightfield.
+///  @returns The number of spans in the heightfield.
 int rcGetHeightFieldSpanCount(rcContext* ctx, rcHeightfield& hf);
 
-// Builds compact representation of the heightfield.
-// Params:
-//	walkableHeight - (in) minimum height where the agent can still walk
-//	walkableClimb - (in) maximum height between grid cells the agent can climb
-//  flags - (in) require flags for a cell to be included in the compact heightfield.
-//	hf - (in) heightfield to be compacted
-//	chf - (out) compact heightfield representing the open space.
-// Returns false if operation ran out of memory.
+/// @}
+/// @name Compact Heightfield Functions
+/// @see rcCompactHeightfield
+/// @{
+
+/// Builds a compact heightfield representing open space, from a heightfield representing solid space.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area 
+///  								to be considered walkable. [Limit: >= 3] [Units: vx]
+///  @param[in]		walkableClimb	Maximum ledge height that is considered to still be traversable. 
+///  								[Limit: >=0] [Units: vx]
+///  @param[in]		hf				The heightfield to be compacted.
+///  @param[out]	chf				The resulting compact heightfield. (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
 bool rcBuildCompactHeightfield(rcContext* ctx, const int walkableHeight, const int walkableClimb,
 							   rcHeightfield& hf, rcCompactHeightfield& chf);
 
-// Erodes walkable area.
-// Params:
-//  radius - (in) radius of erosion (max 255).
-//	chf - (in/out) compact heightfield to erode.
-// Returns false if operation ran out of memory.
+/// Erodes the walkable area within the heightfield by the specified radius. 
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		radius	The radius of erosion. [Limits: 0 < value < 255] [Units: vx]
+///  @param[in,out]	chf		The populated compact heightfield to erode.
+///  @returns True if the operation completed successfully.
 bool rcErodeWalkableArea(rcContext* ctx, int radius, rcCompactHeightfield& chf);
 
-// Applies median filter to walkable area types, removing noise.
-// Params:
-//	chf - (in/out) compact heightfield to erode.
-// Returns false if operation ran out of memory.
+/// Applies a median filter to walkable area types (based on area id), removing noise.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in,out]	chf		A populated compact heightfield.
+///  @returns True if the operation completed successfully.
 bool rcMedianFilterWalkableArea(rcContext* ctx, rcCompactHeightfield& chf);
 
-// Marks the area of the convex polygon into the area type of the compact heightfield.
-// Params:
-//  bmin/bmax - (in) bounds of the axis aligned box.
-//  areaId - (in) area ID to mark.
-//	chf - (in/out) compact heightfield to mark.
+/// Applies an area id to all spans within the specified bounding box. (AABB) 
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		bmin	The minimum of the bounding box. [(x, y, z)]
+///  @param[in]		bmax	The maximum of the bounding box. [(x, y, z)]
+///  @param[in]		areaId	The area id to apply. [Limit: <= #RC_WALKABLE_AREA]
+///  @param[in,out]	chf		A populated compact heightfield.
 void rcMarkBoxArea(rcContext* ctx, const float* bmin, const float* bmax, unsigned char areaId,
 				   rcCompactHeightfield& chf);
 
-// Marks the area of the convex polygon into the area type of the compact heightfield.
-// Params:
-//  verts - (in) vertices of the convex polygon.
-//  nverts - (in) number of vertices in the polygon.
-//  hmin/hmax - (in) min and max height of the polygon.
-//  areaId - (in) area ID to mark.
-//	chf - (in/out) compact heightfield to mark.
+/// Applies the area id to the all spans within the specified convex polygon. 
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		verts	The vertices of the polygon [Fomr: (x, y, z) * @p nverts]
+///  @param[in]		nverts	The number of vertices in the polygon.
+///  @param[in]		hmin	The height of the base of the polygon.
+///  @param[in]		hmax	The height of the top of the polygon.
+///  @param[in]		areaId	The area id to apply. [Limit: <= #RC_WALKABLE_AREA]
+///  @param[in,out]	chf		A populated compact heightfield.
 void rcMarkConvexPolyArea(rcContext* ctx, const float* verts, const int nverts,
 						  const float hmin, const float hmax, unsigned char areaId,
 						  rcCompactHeightfield& chf);
 
-// Builds distance field and stores it into the combat heightfield.
-// Params:
-//	chf - (in/out) compact heightfield representing the open space.
-// Returns false if operation ran out of memory.
+/// Applies the area id to all spans within the specified cylinder.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		pos		The center of the base of the cylinder. [Form: (x, y, z)] 
+///  @param[in]		r		The radius of the cylinder.
+///  @param[in]		h		The height of the cylinder.
+///  @param[in]		areaId	The area id to apply. [Limit: <= #RC_WALKABLE_AREA]
+///  @param[in,out]	chf	A populated compact heightfield.
+void rcMarkCylinderArea(rcContext* ctx, const float* pos,
+						const float r, const float h, unsigned char areaId,
+						rcCompactHeightfield& chf);
+
+/// Builds the distance field for the specified compact heightfield. 
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in,out]	chf		A populated compact heightfield.
+///  @returns True if the operation completed successfully.
 bool rcBuildDistanceField(rcContext* ctx, rcCompactHeightfield& chf);
 
-// Divides the walkable heighfied into simple regions using watershed partitioning.
-// Each region has only one contour and no overlaps.
-// The regions are stored in the compact heightfield 'reg' field.
-// The process sometimes creates small regions. If the area of a regions is
-// smaller than 'mergeRegionArea' then the region will be merged with a neighbour
-// region if possible. If multiple regions form an area which is smaller than
-// 'minRegionArea' all the regions belonging to that area will be removed.
-// Here area means the count of spans in an area.
-// Params:
-//	chf - (in/out) compact heightfield representing the open space.
-//	minRegionArea - (in) the smallest allowed region area.
-//	maxMergeRegionArea - (in) the largest allowed region area which can be merged.
-// Returns false if operation ran out of memory.
+/// Builds region data for the heightfield using watershed partitioning. 
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in,out]	chf				A populated compact heightfield.
+///  @param[in]		borderSize		The size of the non-navigable border around the heightfield.
+///  								[Limit: >=0] [Units: vx]
+///  @param[in]		minRegionArea	The minimum number of cells allowed to form isolated island areas.
+///  								[Limit: >=0] [Units: vx].
+///  @param[in]		mergeRegionArea		Any regions with a span count smaller than this value will, if possible,
+///  								be merged with larger regions. [Limit: >=0] [Units: vx] 
+///  @returns True if the operation completed successfully.
 bool rcBuildRegions(rcContext* ctx, rcCompactHeightfield& chf,
 					const int borderSize, const int minRegionArea, const int mergeRegionArea);
 
-// Divides the walkable heighfied into simple regions using simple monotone partitioning.
-// Each region has only one contour and no overlaps.
-// The regions are stored in the compact heightfield 'reg' field.
-// The process sometimes creates small regions. If the area of a regions is
-// smaller than 'mergeRegionArea' then the region will be merged with a neighbour
-// region if possible. If multiple regions form an area which is smaller than
-// 'minRegionArea' all the regions belonging to that area will be removed.
-// Here area means the count of spans in an area.
-// Params:
-//	chf - (in/out) compact heightfield representing the open space.
-//	minRegionArea - (in) the smallest allowed regions size.
-//	maxMergeRegionArea - (in) the largest allowed regions size which can be merged.
-// Returns false if operation ran out of memory.
+/// Builds region data for the heightfield using simple monotone partitioning.
+///  @ingroup recast 
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in,out]	chf				A populated compact heightfield.
+///  @param[in]		borderSize		The size of the non-navigable border around the heightfield.
+///  								[Limit: >=0] [Units: vx]
+///  @param[in]		minRegionArea	The minimum number of cells allowed to form isolated island areas.
+///  								[Limit: >=0] [Units: vx].
+///  @param[in]		mergeRegionArea	Any regions with a span count smaller than this value will, if possible, 
+///  								be merged with larger regions. [Limit: >=0] [Units: vx] 
+///  @returns True if the operation completed successfully.
 bool rcBuildRegionsMonotone(rcContext* ctx, rcCompactHeightfield& chf,
 							const int borderSize, const int minRegionArea, const int mergeRegionArea);
 
-// Builds simplified contours from the regions outlines.
-// Params:
-//	chf - (in) compact heightfield which has regions set.
-//	maxError - (in) maximum allowed distance between simplified contour and cells.
-//	maxEdgeLen - (in) maximum allowed contour edge length in cells.
-//	cset - (out) Resulting contour set.
-//	flags - (in) build flags, see rcBuildContoursFlags.
-// Returns false if operation ran out of memory.
+
+/// Sets the neighbor connection data for the specified direction.
+///  @param[in]		s		The span to update.
+///  @param[in]		dir		The direction to set. [Limits: 0 <= value < 4]
+///  @param[in]		i		The index of the neighbor span.
+inline void rcSetCon(rcCompactSpan& s, int dir, int i)
+{
+	const unsigned int shift = (unsigned int)dir*6;
+	unsigned int con = s.con;
+	s.con = (con & ~(0x3f << shift)) | (((unsigned int)i & 0x3f) << shift);
+}
+
+/// Gets neighbor connection data for the specified direction.
+///  @param[in]		s		The span to check.
+///  @param[in]		dir		The direction to check. [Limits: 0 <= value < 4]
+///  @return The neighbor connection data for the specified direction,
+///  	or #RC_NOT_CONNECTED if there is no connection.
+inline int rcGetCon(const rcCompactSpan& s, int dir)
+{
+	const unsigned int shift = (unsigned int)dir*6;
+	return (s.con >> shift) & 0x3f;
+}
+
+/// Gets the standard width (x-axis) offset for the specified direction.
+///  @param[in]		dir		The direction. [Limits: 0 <= value < 4]
+///  @return The width offset to apply to the current cell position to move
+///  	in the direction.
+inline int rcGetDirOffsetX(int dir)
+{
+	const int offset[4] = { -1, 0, 1, 0, };
+	return offset[dir&0x03];
+}
+
+/// Gets the standard height (z-axis) offset for the specified direction.
+///  @param[in]		dir		The direction. [Limits: 0 <= value < 4]
+///  @return The height offset to apply to the current cell position to move
+///  	in the direction.
+inline int rcGetDirOffsetY(int dir)
+{
+	const int offset[4] = { 0, 1, 0, -1 };
+	return offset[dir&0x03];
+}
+
+/// @}
+/// @name Layer, Contour, Polymesh, and Detail Mesh Functions
+/// @see rcHeightfieldLayer, rcContourSet, rcPolyMesh, rcPolyMeshDetail
+/// @{
+
+/// Builds a layer set from the specified compact heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx			The build context to use during the operation.
+///  @param[in]		chf			A fully built compact heightfield.
+///  @param[in]		borderSize	The size of the non-navigable border around the heightfield. [Limit: >=0] 
+///  							[Units: vx]
+///  @param[in]		walkableHeight	Minimum floor to 'ceiling' height that will still allow the floor area 
+///  							to be considered walkable. [Limit: >= 3] [Units: vx]
+///  @param[out]	lset		The resulting layer set. (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
+bool rcBuildHeightfieldLayers(rcContext* ctx, rcCompactHeightfield& chf, 
+							  const int borderSize, const int walkableHeight,
+							  rcHeightfieldLayerSet& lset);
+
+/// Builds a contour set from the region outlines in the provided compact heightfield.
+///  @ingroup recast
+///  @param[in,out]	ctx			The build context to use during the operation.
+///  @param[in]		chf			A fully built compact heightfield.
+///  @param[in]		maxError	The maximum distance a simplfied contour's border edges should deviate 
+///  							the original raw contour. [Limit: >=0] [Units: wu]
+///  @param[in]		maxEdgeLen	The maximum allowed length for contour edges along the border of the mesh. 
+///  							[Limit: >=0] [Units: vx]
+///  @param[out]	cset		The resulting contour set. (Must be pre-allocated.)
+///  @param[in]		buildFlags	The build flags. (See: #rcBuildContoursFlags)
+///  @returns True if the operation completed successfully.
 bool rcBuildContours(rcContext* ctx, rcCompactHeightfield& chf,
 					 const float maxError, const int maxEdgeLen,
 					 rcContourSet& cset, const int flags = RC_CONTOUR_TESS_WALL_EDGES);
 
-// Builds connected convex polygon mesh from contour polygons.
-// Params:
-//	cset - (in) contour set.
-//	nvp - (in) maximum number of vertices per polygon.
-//	mesh - (out) poly mesh.
-// Returns false if operation ran out of memory.
-bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, int nvp, rcPolyMesh& mesh);
+/// Builds a polygon mesh from the provided contours.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		cset	A fully built contour set.
+///  @param[in]		nvp		The maximum number of vertices allowed for polygons generated during the 
+///  						contour to polygon conversion process. [Limit: >= 3] 
+///  @param[out]	mesh	The resulting polygon mesh. (Must be re-allocated.)
+///  @returns True if the operation completed successfully.
+bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, const int nvp, rcPolyMesh& mesh);
 
+/// Merges multiple polygon meshes into a single mesh.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		meshes	An array of polygon meshes to merge. [Size: @p nmeshes]
+///  @param[in]		nmeshes	The number of polygon meshes in the meshes array.
+///  @param[in]		mesh	The resulting polygon mesh. (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
 bool rcMergePolyMeshes(rcContext* ctx, rcPolyMesh** meshes, const int nmeshes, rcPolyMesh& mesh);
 
-// Builds detail triangle mesh for each polygon in the poly mesh.
-// Params:
-//	mesh - (in) poly mesh to detail.
-//	chf - (in) compact height field, used to query height for new vertices.
-//  sampleDist - (in) spacing between height samples used to generate more detail into mesh.
-//  sampleMaxError - (in) maximum allowed distance between simplified detail mesh and height sample.
-//	pmdtl - (out) detail mesh.
-// Returns false if operation ran out of memory.
+/// Builds a detail mesh from the provided polygon mesh.
+///  @ingroup recast
+///  @param[in,out]	ctx				The build context to use during the operation.
+///  @param[in]		mesh			A fully built polygon mesh.
+///  @param[in]		chf				The compact heightfield used to build the polygon mesh.
+///  @param[in]		sampleDist		Sets the distance to use when samping the heightfield. [Limit: >=0] [Units: wu]
+///  @param[in]		sampleMaxError	The maximum distance the detail mesh surface should deviate from 
+///  								heightfield data. [Limit: >=0] [Units: wu]
+///  @param[out]	dmesh			The resulting detail mesh.  (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
 bool rcBuildPolyMeshDetail(rcContext* ctx, const rcPolyMesh& mesh, const rcCompactHeightfield& chf,
 						   const float sampleDist, const float sampleMaxError,
 						   rcPolyMeshDetail& dmesh);
 
+/// Merges multiple detail meshes into a single detail mesh.
+///  @ingroup recast
+///  @param[in,out]	ctx		The build context to use during the operation.
+///  @param[in]		meshes	An array of detail meshes to merge. [Size: @p nmeshes]
+///  @param[in]		nmeshes	The number of detail meshes in the meshes array.
+///  @param[out]	mesh	The resulting detail mesh. (Must be pre-allocated.)
+///  @returns True if the operation completed successfully.
 bool rcMergePolyMeshDetails(rcContext* ctx, rcPolyMeshDetail** meshes, const int nmeshes, rcPolyMeshDetail& mesh);
 
+/// @}
 
 #endif // RECAST_H
+
+///////////////////////////////////////////////////////////////////////////
+
+// Due to the large amount of detail documentation for this file, 
+// the content normally located at the end of the header file has been separated
+// out to a file in /Docs/Extern.
Index: src/hearthstone-shared/Pathfinding/Recast/RecastArea.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastArea.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastArea.cpp	(working copy)
@@ -18,6 +18,14 @@
 
 #include "../../Common.h"
 
+/// @par 
+/// 
+/// Basically, any spans that are closer to a boundary or obstruction than the specified radius 
+/// are marked as unwalkable.
+///
+/// This method is usually called immediately after the heightfield has been built.
+///
+/// @see rcCompactHeightfield, rcBuildCompactHeightfield, rcConfig::walkableRadius
 bool rcErodeWalkableArea(rcContext* ctx, int radius, rcCompactHeightfield& chf)
 {
 	ASSERT(ctx);
@@ -45,14 +53,26 @@
 			const rcCompactCell& c = chf.cells[x+y*w];
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
-				if (chf.areas[i] != RC_NULL_AREA)
+				if (chf.areas[i] == RC_NULL_AREA)
 				{
+					dist[i] = 0;
+				}
+				else
+				{
 					const rcCompactSpan& s = chf.spans[i];
 					int nc = 0;
 					for (int dir = 0; dir < 4; ++dir)
 					{
 						if (rcGetCon(s, dir) != RC_NOT_CONNECTED)
-							nc++;
+						{
+							const int nx = x + rcGetDirOffsetX(dir);
+							const int ny = y + rcGetDirOffsetY(dir);
+							const int ni = (int)chf.cells[nx+ny*w].index + rcGetCon(s, dir);
+							if (chf.areas[ni] != RC_NULL_AREA)
+							{
+								nc++;
+							}
+						}
 					}
 					// At least one missing neighbour.
 					if (nc != 4)
@@ -204,7 +224,12 @@
 	}
 }
 
-
+/// @par
+///
+/// This filter is usually applied after applying area id's using functions
+/// such as #rcMarkBoxArea, #rcMarkConvexPolyArea, and #rcMarkCylinderArea.
+/// 
+/// @see rcCompactHeightfield
 bool rcMedianFilterWalkableArea(rcContext* ctx, rcCompactHeightfield& chf)
 {
 	ASSERT(ctx);
@@ -279,6 +304,11 @@
 	return true;
 }
 
+/// @par
+///
+/// The value of spacial parameters are in world units.
+/// 
+/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
 void rcMarkBoxArea(rcContext* ctx, const float* bmin, const float* bmax, unsigned char areaId,
 				   rcCompactHeightfield& chf)
 {
@@ -313,7 +343,8 @@
 				rcCompactSpan& s = chf.spans[i];
 				if ((int)s.y >= miny && (int)s.y <= maxy)
 				{
-					chf.areas[i] = areaId;
+					if (chf.areas[i] != RC_NULL_AREA)
+						chf.areas[i] = areaId;
 				}
 			}
 		}
@@ -338,6 +369,14 @@
 	return c;
 }
 
+/// @par
+///
+/// The value of spacial parameters are in world units.
+/// 
+/// The y-values of the polygon vertices are ignored. So the polygon is effectively 
+/// projected onto the xz-plane at @p hmin, then extruded to @p hmax.
+/// 
+/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
 void rcMarkConvexPolyArea(rcContext* ctx, const float* verts, const int nverts,
 						  const float hmin, const float hmax, unsigned char areaId,
 						  rcCompactHeightfield& chf)
@@ -384,6 +423,8 @@
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				rcCompactSpan& s = chf.spans[i];
+				if (chf.areas[i] == RC_NULL_AREA)
+					continue;
 				if ((int)s.y >= miny && (int)s.y <= maxy)
 				{
 					float p[3];
@@ -402,3 +443,74 @@
 
 	ctx->stopTimer(RC_TIMER_MARK_CONVEXPOLY_AREA);
 }
+
+/// @par
+///
+/// The value of spacial parameters are in world units.
+/// 
+/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
+void rcMarkCylinderArea(rcContext* ctx, const float* pos,
+						const float r, const float h, unsigned char areaId,
+						rcCompactHeightfield& chf)
+{
+	ASSERT(ctx);
+	
+	ctx->startTimer(RC_TIMER_MARK_CYLINDER_AREA);
+	
+	float bmin[3], bmax[3];
+	bmin[0] = pos[0] - r;
+	bmin[1] = pos[1];
+	bmin[2] = pos[2] - r;
+	bmax[0] = pos[0] + r;
+	bmax[1] = pos[1] + h;
+	bmax[2] = pos[2] + r;
+	const float r2 = r*r;
+	
+	int minx = (int)((bmin[0]-chf.bmin[0])/chf.cs);
+	int miny = (int)((bmin[1]-chf.bmin[1])/chf.ch);
+	int minz = (int)((bmin[2]-chf.bmin[2])/chf.cs);
+	int maxx = (int)((bmax[0]-chf.bmin[0])/chf.cs);
+	int maxy = (int)((bmax[1]-chf.bmin[1])/chf.ch);
+	int maxz = (int)((bmax[2]-chf.bmin[2])/chf.cs);
+	
+	if (maxx < 0) return;
+	if (minx >= chf.width) return;
+	if (maxz < 0) return;
+	if (minz >= chf.height) return;
+	
+	if (minx < 0) minx = 0;
+	if (maxx >= chf.width) maxx = chf.width-1;
+	if (minz < 0) minz = 0;
+	if (maxz >= chf.height) maxz = chf.height-1;	
+	
+	
+	for (int z = minz; z <= maxz; ++z)
+	{
+		for (int x = minx; x <= maxx; ++x)
+		{
+			const rcCompactCell& c = chf.cells[x+z*chf.width];
+			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
+			{
+				rcCompactSpan& s = chf.spans[i];
+				
+				if (chf.areas[i] == RC_NULL_AREA)
+					continue;
+				
+				if ((int)s.y >= miny && (int)s.y <= maxy)
+				{
+					const float sx = chf.bmin[0] + (x+0.5f)*chf.cs; 
+					const float sz = chf.bmin[2] + (z+0.5f)*chf.cs; 
+					const float dx = sx - pos[0];
+					const float dz = sz - pos[2];
+					
+					if (dx*dx + dz*dz < r2)
+					{
+						chf.areas[i] = areaId;
+					}
+				}
+			}
+		}
+	}
+	
+	ctx->stopTimer(RC_TIMER_MARK_CYLINDER_AREA);
+}
Index: src/hearthstone-shared/Pathfinding/Recast/RecastContour.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastContour.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastContour.cpp	(working copy)
@@ -333,7 +333,7 @@
 			endi = ai;
 		}
 		
-		// Tessellate only outer edges oredges between areas.
+		// Tessellate only outer edges or edges between areas.
 		if ((points[ci*4+3] & RC_CONTOUR_REG_MASK) == 0 ||
 			(points[ci*4+3] & RC_AREA_BORDER))
 		{
@@ -585,6 +585,19 @@
 	return true;
 }
 
+/// @par
+///
+/// The raw contours will match the region outlines exactly. The @p maxError and @p maxEdgeLen
+/// parameters control how closely the simplified contours will match the raw contours.
+///
+/// Simplified contours are generated such that the vertices for portals between areas match up. 
+/// (They are considered mandatory vertices.)
+///
+/// Setting @p maxEdgeLength to zero will disabled the edge length feature.
+/// 
+/// See the #rcConfig documentation for more information on the configuration parameters.
+/// 
+/// @see mallocContourSet, rcCompactHeightfield, rcContourSet, rcConfig
 bool rcBuildContours(rcContext* ctx, rcCompactHeightfield& chf,
 					 const float maxError, const int maxEdgeLen,
 					 rcContourSet& cset, const int buildFlags)
@@ -593,13 +606,26 @@
 	
 	const int w = chf.width;
 	const int h = chf.height;
+	const int borderSize = chf.borderSize;
 	
 	ctx->startTimer(RC_TIMER_BUILD_CONTOURS);
 	
 	rcVcopy(cset.bmin, chf.bmin);
 	rcVcopy(cset.bmax, chf.bmax);
+	if (borderSize > 0)
+	{
+		// If the heightfield was build with bordersize, remove the offset.
+		const float pad = borderSize*chf.cs;
+		cset.bmin[0] += pad;
+		cset.bmin[2] += pad;
+		cset.bmax[0] -= pad;
+		cset.bmax[2] -= pad;
+	}
 	cset.cs = chf.cs;
 	cset.ch = chf.ch;
+	cset.width = chf.width - chf.borderSize*2;
+	cset.height = chf.height - chf.borderSize*2;
+	cset.borderSize = chf.borderSize;
 	
 	int maxContours = rcMax((int)chf.maxRegions, 8);
 	cset.conts = (rcContour*)malloc(sizeof(rcContour)*maxContours);
@@ -651,8 +677,6 @@
 	
 	ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
 	
-	ctx->startTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
-	
 	rcIntArray verts(256);
 	rcIntArray simplified(64);
 	
@@ -675,10 +699,17 @@
 				
 				verts.resize(0);
 				simplified.resize(0);
+
+				ctx->startTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
 				walkContour(x, y, i, chf, flags, verts);
+				ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_TRACE);
+
+				ctx->startTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
 				simplifyContour(verts, simplified, maxError, maxEdgeLen, buildFlags);
 				removeDegenerateSegments(simplified);
+				ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
 				
+
 				// Store region->contour remap info.
 				// Create contour.
 				if (simplified.size()/4 >= 3)
@@ -713,6 +744,16 @@
 						return false;
 					}
 					memcpy(cont->verts, &simplified[0], sizeof(int)*cont->nverts*4);
+					if (borderSize > 0)
+					{
+						// If the heightfield was build with bordersize, remove the offset.
+						for (int i = 0; i < cont->nverts; ++i)
+						{
+							int* v = &cont->verts[i*4];
+							v[0] -= borderSize;
+							v[2] -= borderSize;
+						}
+					}
 					
 					cont->nrverts = verts.size()/4;
 					cont->rverts = (int*)malloc(sizeof(int)*cont->nrverts*4);
@@ -722,6 +763,16 @@
 						return false;
 					}
 					memcpy(cont->rverts, &verts[0], sizeof(int)*cont->nrverts*4);
+					if (borderSize > 0)
+					{
+						// If the heightfield was build with bordersize, remove the offset.
+						for (int i = 0; i < cont->nrverts; ++i)
+						{
+							int* v = &cont->rverts[i*4];
+							v[0] -= borderSize;
+							v[2] -= borderSize;
+						}
+					}
 					
 /*					cont->cx = cont->cy = cont->cz = 0;
 					for (int i = 0; i < cont->nverts; ++i)
@@ -789,8 +840,6 @@
 		}
 	}
 	
-	ctx->stopTimer(RC_TIMER_BUILD_CONTOURS_SIMPLIFY);
-	
 	ctx->stopTimer(RC_TIMER_BUILD_CONTOURS);
 	
 	return true;
Index: src/hearthstone-shared/Pathfinding/Recast/RecastFilter.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastFilter.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastFilter.cpp	(working copy)
@@ -18,6 +18,17 @@
 
 #include "../../Common.h"
 
+/// @par
+///
+/// Allows the formation of walkable regions that will flow over low lying 
+/// objects such as curbs, and up structures such as stairways. 
+/// 
+/// Two neighboring spans are walkable if: <tt>rcAbs(currentSpan.smax - neighborSpan.smax) < waklableClimb</tt>
+/// 
+/// @warning Will override the effect of #rcFilterLedgeSpans.  So if both filters are used, call
+/// #rcFilterLedgeSpans after calling this filter. 
+///
+/// @see rcHeightfield, rcConfig
 void rcFilterLowHangingWalkableObstacles(rcContext* ctx, const int walkableClimb, rcHeightfield& solid)
 {
 	ASSERT(ctx);
@@ -33,6 +44,7 @@
 		{
 			rcSpan* ps = 0;
 			bool previousWalkable = false;
+			unsigned char previousArea = RC_NULL_AREA;
 			
 			for (rcSpan* s = solid.spans[x + y*w]; s; ps = s, s = s->next)
 			{
@@ -42,18 +54,29 @@
 				if (!walkable && previousWalkable)
 				{
 					if (rcAbs((int)s->smax - (int)ps->smax) <= walkableClimb)
-						s->area = RC_NULL_AREA;
+						s->area = previousArea;
 				}
 				// Copy walkable flag so that it cannot propagate
 				// past multiple non-walkable objects.
 				previousWalkable = walkable;
+				previousArea = s->area;
 			}
 		}
 	}
 
 	ctx->stopTimer(RC_TIMER_FILTER_LOW_OBSTACLES);
 }
-	
+
+/// @par
+///
+/// A ledge is a span with one or more neighbors whose maximum is further away than @p walkableClimb
+/// from the current span's maximum.
+/// This method removes the impact of the overestimation of conservative voxelization 
+/// so the resulting mesh will not have regions hanging in the air over ledges.
+/// 
+/// A span is a ledge if: <tt>rcAbs(currentSpan.smax - neighborSpan.smax) > walkableClimb</tt>
+/// 
+/// @see rcHeightfield, rcConfig
 void rcFilterLedgeSpans(rcContext* ctx, const int walkableHeight, const int walkableClimb,
 						rcHeightfield& solid)
 {
@@ -144,6 +167,12 @@
 	ctx->stopTimer(RC_TIMER_FILTER_BORDER);
 }	
 
+/// @par
+///
+/// For this filter, the clearance above the span is the distance from the span's 
+/// maximum to the next higher span's minimum. (Same grid column.)
+/// 
+/// @see rcHeightfield, rcConfig
 void rcFilterWalkableLowHeightSpans(rcContext* ctx, int walkableHeight, rcHeightfield& solid)
 {
 	ASSERT(ctx);
Index: src/hearthstone-shared/Pathfinding/Recast/RecastMesh.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastMesh.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastMesh.cpp	(working copy)
@@ -53,6 +53,9 @@
 		unsigned short* t = &polys[i*vertsPerPoly*2];
 		for (int j = 0; j < vertsPerPoly; ++j)
 		{
+			if (t[j] == RC_MESH_NULL_IDX)
+				break;
+
 			unsigned short v0 = t[j];
 			unsigned short v1 = (j+1 >= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];
 			if (v0 < v1)
@@ -77,6 +80,9 @@
 		unsigned short* t = &polys[i*vertsPerPoly*2];
 		for (int j = 0; j < vertsPerPoly; ++j)
 		{
+			if (t[j] == RC_MESH_NULL_IDX)
+				break;
+
 			unsigned short v0 = t[j];
 			unsigned short v1 = (j+1 >= vertsPerPoly || t[j+1] == RC_MESH_NULL_IDX) ? t[0] : t[j+1];
 			if (v0 > v1)
@@ -189,7 +195,7 @@
 //	Returns true iff ab properly intersects cd: they share
 //	a point interior to both segments.  The properness of the
 //	intersection is ensured by using strict leftness.
-bool intersectProp(const int* a, const int* b, const int* c, const int* d)
+static bool intersectProp(const int* a, const int* b, const int* c, const int* d)
 {
 	// Eliminate improper cases.
 	if (collinear(a,b,c) || collinear(a,b,d) ||
@@ -464,6 +470,7 @@
 	memcpy(pa, tmp, sizeof(unsigned short)*nvp);
 }
 
+
 static void pushFront(int v, int* arr, int& an)
 {
 	an++;
@@ -886,8 +893,13 @@
 	return true;
 }
 
-
-bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, int nvp, rcPolyMesh& mesh)
+/// @par
+///
+/// @note If the mesh data is to be used to construct a Detour navigation mesh, then the upper 
+/// limit must be retricted to <= #DT_VERTS_PER_POLYGON.
+///
+/// @see mallocPolyMesh, rcContourSet, rcPolyMesh, rcConfig
+bool rcBuildPolyMesh(rcContext* ctx, rcContourSet& cset, const int nvp, rcPolyMesh& mesh)
 {
 	ASSERT(ctx);
 	
@@ -897,6 +909,7 @@
 	rcVcopy(mesh.bmax, cset.bmax);
 	mesh.cs = cset.cs;
 	mesh.ch = cset.ch;
+	mesh.borderSize = cset.borderSize;
 	
 	int maxVertices = 0;
 	int maxTris = 0;
@@ -930,7 +943,7 @@
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.verts' (%d).", maxVertices);
 		return false;
 	}
-	mesh.polys = (unsigned short*)malloc(sizeof(unsigned short)*maxTris*nvp*2*2);
+	mesh.polys = (unsigned short*)malloc(sizeof(unsigned short)*maxTris*nvp*2);
 	if (!mesh.polys)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Out of memory 'mesh.polys' (%d).", maxTris*nvp*2);
@@ -1147,7 +1160,38 @@
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: Adjacency failed.");
 		return false;
 	}
+	
+	// Find portal edges
+	if (mesh.borderSize > 0)
+	{
+		const int w = cset.width;
+		const int h = cset.height;
+		for (int i = 0; i < mesh.npolys; ++i)
+		{
+			unsigned short* p = &mesh.polys[i*2*nvp];
+			for (int j = 0; j < nvp; ++j)
+			{
+				if (p[j] == RC_MESH_NULL_IDX) break;
+				// Skip connected edges.
+				if (p[nvp+j] != RC_MESH_NULL_IDX)
+					continue;
+				int nj = j+1;
+				if (nj >= nvp || p[nj] == RC_MESH_NULL_IDX) nj = 0;
+				const unsigned short* va = &mesh.verts[p[j]*3];
+				const unsigned short* vb = &mesh.verts[p[nj]*3];
 
+				if ((int)va[0] == 0 && (int)vb[0] == 0)
+					p[nvp+j] = 0x8000 | 0;
+				else if ((int)va[2] == h && (int)vb[2] == h)
+					p[nvp+j] = 0x8000 | 1;
+				else if ((int)va[0] == w && (int)vb[0] == w)
+					p[nvp+j] = 0x8000 | 2;
+				else if ((int)va[2] == 0 && (int)vb[2] == 0)
+					p[nvp+j] = 0x8000 | 3;
+			}
+		}
+	}
+
 	// Just allocate the mesh flags array. The user is resposible to fill it.
 	mesh.flags = (unsigned short*)malloc(sizeof(unsigned short)*mesh.npolys);
 	if (!mesh.flags)
@@ -1159,11 +1203,11 @@
 	
 	if (mesh.nverts > 0xffff)
 	{
-		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: The resulting mesh has too many vertices %d (max %d). Data can be corrupted.", mesh.nverts, 0xffff);
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: The resulting mesh has too many vertices %d (max %d). Data can be corrupted.", mesh.nverts, 0xffff);
 	}
 	if (mesh.npolys > 0xffff)
 	{
-		ctx->log(RC_LOG_ERROR, "rcMergePolyMeshes: The resulting mesh has too many polygons %d (max %d). Data can be corrupted.", mesh.npolys, 0xffff);
+		ctx->log(RC_LOG_ERROR, "rcBuildPolyMesh: The resulting mesh has too many polygons %d (max %d). Data can be corrupted.", mesh.npolys, 0xffff);
 	}
 	
 	ctx->stopTimer(RC_TIMER_BUILD_POLYMESH);
@@ -1171,6 +1215,7 @@
 	return true;
 }
 
+/// @see mallocPolyMesh, rcPolyMesh
 bool rcMergePolyMeshes(rcContext* ctx, rcPolyMesh** meshes, const int nmeshes, rcPolyMesh& mesh)
 {
 	ASSERT(ctx);
Index: src/hearthstone-shared/Pathfinding/Recast/RecastMeshDetail.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastMeshDetail.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastMeshDetail.cpp	(working copy)
@@ -734,12 +734,15 @@
 
 static void getHeightData(const rcCompactHeightfield& chf,
 						  const unsigned short* poly, const int npoly,
-						  const unsigned short* verts,
+						  const unsigned short* verts, const int bs,
 						  rcHeightPatch& hp, rcIntArray& stack)
 {
 	// Floodfill the heightfield to get 2D height data,
 	// starting at vertex locations as seeds.
-	
+
+	// Note: Reads to the compact heightfield are offset by border size (bs)
+	// since border size offset is already removed from the polymesh vertices.
+
 	memset(hp.data, 0, sizeof(unsigned short)*hp.width*hp.height);
 	
 	stack.resize(0);
@@ -763,7 +766,7 @@
 				az < hp.ymin || az >= hp.ymin+hp.height)
 				continue;
 			
-			const rcCompactCell& c = chf.cells[ax+az*chf.width];
+			const rcCompactCell& c = chf.cells[(ax+bs)+(az+bs)*chf.width];
 			for (int i = (int)c.index, ni = (int)(c.index+c.count); i < ni; ++i)
 			{
 				const rcCompactSpan& s = chf.spans[i];
@@ -835,7 +838,7 @@
 			if (hp.data[ax-hp.xmin+(ay-hp.ymin)*hp.width] != 0)
 				continue;
 			
-			const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(cs, dir);
+			const int ai = (int)chf.cells[(ax+bs)+(ay+bs)*chf.width].index + rcGetCon(cs, dir);
 
 			int idx = ax-hp.xmin+(ay-hp.ymin)*hp.width;
 			hp.data[idx] = 1;
@@ -891,7 +894,7 @@
 			if (hp.data[ax-hp.xmin+(ay-hp.ymin)*hp.width] != RC_UNSET_HEIGHT)
 				continue;
 			
-			const int ai = (int)chf.cells[ax+ay*chf.width].index + rcGetCon(cs, dir);
+			const int ai = (int)chf.cells[(ax+bs)+(ay+bs)*chf.width].index + rcGetCon(cs, dir);
 			
 			const rcCompactSpan& as = chf.spans[ai];
 			int idx = ax-hp.xmin+(ay-hp.ymin)*hp.width;
@@ -929,8 +932,11 @@
 	return flags;
 }
 
-
-
+/// @par
+///
+/// See the #rcConfig documentation for more information on the configuration parameters.
+///
+/// @see mallocPolyMeshDetail, rcPolyMesh, rcCompactHeightfield, rcPolyMeshDetail, rcConfig
 bool rcBuildPolyMeshDetail(rcContext* ctx, const rcPolyMesh& mesh, const rcCompactHeightfield& chf,
 						   const float sampleDist, const float sampleMaxError,
 						   rcPolyMeshDetail& dmesh)
@@ -946,7 +952,8 @@
 	const float cs = mesh.cs;
 	const float ch = mesh.ch;
 	const float* orig = mesh.bmin;
-	
+	const int borderSize = mesh.borderSize;
+
 	rcIntArray edges(64);
 	rcIntArray tris(512);
 	rcIntArray stack(512);
@@ -955,7 +962,7 @@
 	rcHeightPatch hp;
 	int nPolyVerts = 0;
 	int maxhw = 0, maxhh = 0;
-	
+
 	rcScopedDelete<int> bounds = (int*)malloc(sizeof(int)*mesh.npolys*4);
 	if (!bounds)
 	{
@@ -968,7 +975,7 @@
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'poly' (%d).", nvp*3);
 		return false;
 	}
-	
+
 	// Find max size for a polygon area.
 	for (int i = 0; i < mesh.npolys; ++i)
 	{
@@ -999,14 +1006,14 @@
 		maxhw = rcMax(maxhw, xmax-xmin);
 		maxhh = rcMax(maxhh, ymax-ymin);
 	}
-	
+
 	hp.data = (unsigned short*)malloc(sizeof(unsigned short)*maxhw*maxhh);
 	if (!hp.data)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildPolyMeshDetail: Out of memory 'hp.data' (%d).", maxhw*maxhh);
 		return false;
 	}
-	
+
 	dmesh.nmeshes = mesh.npolys;
 	dmesh.nverts = 0;
 	dmesh.ntris = 0;
@@ -1038,7 +1045,7 @@
 	for (int i = 0; i < mesh.npolys; ++i)
 	{
 		const unsigned short* p = &mesh.polys[i*nvp*2];
-		
+
 		// Store polygon vertices for processing.
 		int npoly = 0;
 		for (int j = 0; j < nvp; ++j)
@@ -1050,13 +1057,13 @@
 			poly[j*3+2] = v[2]*cs;
 			npoly++;
 		}
-		
+
 		// Get the height data from the area of the polygon.
 		hp.xmin = bounds[i*4+0];
 		hp.ymin = bounds[i*4+2];
 		hp.width = bounds[i*4+1]-bounds[i*4+0];
 		hp.height = bounds[i*4+3]-bounds[i*4+2];
-		getHeightData(chf, p, npoly, mesh.verts, hp, stack);
+		getHeightData(chf, p, npoly, mesh.verts, borderSize, hp, stack);
 		
 		// Build detail mesh.
 		int nverts = 0;
@@ -1148,6 +1155,7 @@
 	return true;
 }
 
+/// @see mallocPolyMeshDetail, rcPolyMeshDetail
 bool rcMergePolyMeshDetails(rcContext* ctx, rcPolyMeshDetail** meshes, const int nmeshes, rcPolyMeshDetail& mesh)
 {
 	ASSERT(ctx);
Index: src/hearthstone-shared/Pathfinding/Recast/RecastRasterization.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastRasterization.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastRasterization.cpp	(working copy)
@@ -149,6 +149,13 @@
 	}
 }
 
+/// @par
+///
+/// The span addition can be set to favor flags. If the span is merged to
+/// another span and the new @p smax is within @p flagMergeThr units
+/// from the existing span, the span flags are merged.
+///
+/// @see rcHeightfield, rcSpan.
 void rcAddSpan(rcContext* /*ctx*/, rcHeightfield& hf, const int x, const int y,
 			   const unsigned short smin, const unsigned short smax,
 			   const unsigned char area, const int flagMergeThr)
@@ -271,6 +278,11 @@
 	}
 }
 
+/// @par
+///
+/// No spans will be added if the triangle does not overlap the heightfield grid.
+///
+/// @see rcHeightfield
 void rcRasterizeTriangle(rcContext* ctx, const float* v0, const float* v1, const float* v2,
 						 const unsigned char area, rcHeightfield& solid,
 						 const int flagMergeThr)
@@ -286,6 +298,11 @@
 	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
 }
 
+/// @par
+///
+/// Spans will only be added for triangles that overlap the heightfield grid.
+///
+/// @see rcHeightfield
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int /*nv*/,
 						  const int* tris, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr)
@@ -309,6 +326,11 @@
 	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
 }
 
+/// @par
+///
+/// Spans will only be added for triangles that overlap the heightfield grid.
+///
+/// @see rcHeightfield
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const int /*nv*/,
 						  const unsigned short* tris, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr)
@@ -332,6 +354,11 @@
 	ctx->stopTimer(RC_TIMER_RASTERIZE_TRIANGLES);
 }
 
+/// @par
+///
+/// Spans will only be added for triangles that overlap the heightfield grid.
+///
+/// @see rcHeightfield
 void rcRasterizeTriangles(rcContext* ctx, const float* verts, const unsigned char* areas, const int nt,
 						  rcHeightfield& solid, const int flagMergeThr)
 {
Index: src/hearthstone-shared/Pathfinding/Recast/RecastRegion.cpp
===================================================================
--- src/hearthstone-shared/Pathfinding/Recast/RecastRegion.cpp	(revision 1488)
+++ src/hearthstone-shared/Pathfinding/Recast/RecastRegion.cpp	(working copy)
@@ -273,6 +273,8 @@
 				if (chf.areas[ai] != area)
 					continue;
 				unsigned short nr = srcReg[ai];
+				if (nr & RC_BORDER_REG) // Do not take borders into account.
+					continue;
 				if (nr != 0 && nr != r)
 					ar = nr;
 				
@@ -309,16 +311,13 @@
 				const int ai = (int)chf.cells[ax+ay*w].index + rcGetCon(cs, dir);
 				if (chf.areas[ai] != area)
 					continue;
-				if (chf.dist[ai] >= lev)
+				if (chf.dist[ai] >= lev && srcReg[ai] == 0)
 				{
-					if (srcReg[ai] == 0)
-					{
-						srcReg[ai] = r;
-						srcDist[ai] = 0;
-						stack.push(ax);
-						stack.push(ay);
-						stack.push(ai);
-					}
+					srcReg[ai] = r;
+					srcDist[ai] = 0;
+					stack.push(ax);
+					stack.push(ay);
+					stack.push(ai);
 				}
 			}
 		}
@@ -927,7 +926,16 @@
 	return true;
 }
 
-
+/// @par
+/// 
+/// This is usually the second to the last step in creating a fully built
+/// compact heightfield.  This step is required before regions are built
+/// using #rcBuildRegions or #rcBuildRegionsMonotone.
+/// 
+/// After this step, the distance data is available via the rcCompactHeightfield::maxDistance
+/// and rcCompactHeightfield::dist fields.
+///
+/// @see rcCompactHeightfield, rcBuildRegions, rcBuildRegionsMonotone
 bool rcBuildDistanceField(rcContext* ctx, rcCompactHeightfield& chf)
 {
 	ASSERT(ctx);
@@ -1010,6 +1018,25 @@
 	unsigned short nei;	// neighbour id
 };
 
+/// @par
+/// 
+/// Non-null regions will consist of connected, non-overlapping walkable spans that form a single contour.
+/// Contours will form simple polygons.
+/// 
+/// If multiple regions form an area that is smaller than @p minRegionArea, then all spans will be
+/// re-assigned to the zero (null) region.
+/// 
+/// Partitioning can result in smaller than necessary regions. @p mergeRegionArea helps 
+/// reduce unecessarily small regions.
+/// 
+/// See the #rcConfig documentation for more information on the configuration parameters.
+/// 
+/// The region data will be available via the rcCompactHeightfield::maxRegions
+/// and rcCompactSpan::reg fields.
+/// 
+/// @warning The distance field must be created using #rcBuildDistanceField before attempting to build regions.
+/// 
+/// @see rcCompactHeightfield, rcCompactSpan, rcBuildDistanceField, rcBuildRegionsMonotone, rcConfig
 bool rcBuildRegionsMonotone(rcContext* ctx, rcCompactHeightfield& chf,
 							const int borderSize, const int minRegionArea, const int mergeRegionArea)
 {
@@ -1049,6 +1076,8 @@
 		paintRectRegion(w-bw, w, 0, h, id|RC_BORDER_REG, chf, srcReg); id++;
 		paintRectRegion(0, w, 0, bh, id|RC_BORDER_REG, chf, srcReg); id++;
 		paintRectRegion(0, w, h-bh, h, id|RC_BORDER_REG, chf, srcReg); id++;
+
+		chf.borderSize = borderSize;
 	}
 	
 	rcIntArray prev(256);
@@ -1160,36 +1189,55 @@
 	return true;
 }
 
+/// @par
+/// 
+/// Non-null regions will consist of connected, non-overlapping walkable spans that form a single contour.
+/// Contours will form simple polygons.
+/// 
+/// If multiple regions form an area that is smaller than @p minRegionArea, then all spans will be
+/// re-assigned to the zero (null) region.
+/// 
+/// Watershed partitioning can result in smaller than necessary regions, especially in diagonal corridors. 
+/// @p mergeRegionArea helps reduce unecessarily small regions.
+/// 
+/// See the #rcConfig documentation for more information on the configuration parameters.
+/// 
+/// The region data will be available via the rcCompactHeightfield::maxRegions
+/// and rcCompactSpan::reg fields.
+/// 
+/// @warning The distance field must be created using #rcBuildDistanceField before attempting to build regions.
+/// 
+/// @see rcCompactHeightfield, rcCompactSpan, rcBuildDistanceField, rcBuildRegionsMonotone, rcConfig
 bool rcBuildRegions(rcContext* ctx, rcCompactHeightfield& chf,
 					const int borderSize, const int minRegionArea, const int mergeRegionArea)
 {
 	ASSERT(ctx);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_REGIONS);
-	
+
 	const int w = chf.width;
 	const int h = chf.height;
-	
+
 	rcScopedDelete<unsigned short> buf = (unsigned short*)malloc(sizeof(unsigned short)*chf.spanCount*4);
 	if (!buf)
 	{
 		ctx->log(RC_LOG_ERROR, "rcBuildRegions: Out of memory 'tmp' (%d).", chf.spanCount*4);
 		return false;
 	}
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_REGIONS_WATERSHED);
-	
+
 	rcIntArray stack(1024);
 	rcIntArray visited(1024);
-	
+
 	unsigned short* srcReg = buf;
 	unsigned short* srcDist = buf+chf.spanCount;
 	unsigned short* dstReg = buf+chf.spanCount*2;
 	unsigned short* dstDist = buf+chf.spanCount*3;
-	
+
 	memset(srcReg, 0, sizeof(unsigned short)*chf.spanCount);
 	memset(srcDist, 0, sizeof(unsigned short)*chf.spanCount);
-	
+
 	unsigned short regionId = 1;
 	unsigned short level = (chf.maxDistance+1) & ~1;
 
@@ -1199,29 +1247,37 @@
 //	const int expandIters = 4 + walkableRadius * 2;
 	const int expandIters = 8;
 
-	// Mark border regions.
-	paintRectRegion(0, borderSize, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
-	paintRectRegion(w-borderSize, w, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
-	paintRectRegion(0, w, 0, borderSize, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
-	paintRectRegion(0, w, h-borderSize, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
-	
+	if (borderSize > 0)
+	{
+		// Make sure border will not overflow.
+		const int bw = rcMin(w, borderSize);
+		const int bh = rcMin(h, borderSize);
+		// Paint regions
+		paintRectRegion(0, bw, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+		paintRectRegion(w-bw, w, 0, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+		paintRectRegion(0, w, 0, bh, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+		paintRectRegion(0, w, h-bh, h, regionId|RC_BORDER_REG, chf, srcReg); regionId++;
+
+		chf.borderSize = borderSize;
+	}
+
 	while (level > 0)
 	{
 		level = level >= 2 ? level-2 : 0;
-		
+
 		ctx->startTimer(RC_TIMER_BUILD_REGIONS_EXPAND);
-		
+
 		// Expand current regions until no empty connected cells found.
 		if (expandRegions(expandIters, level, chf, srcReg, srcDist, dstReg, dstDist, stack) != srcReg)
 		{
 			rcSwap(srcReg, dstReg);
 			rcSwap(srcDist, dstDist);
 		}
-		
+
 		ctx->stopTimer(RC_TIMER_BUILD_REGIONS_EXPAND);
-		
+
 		ctx->startTimer(RC_TIMER_BUILD_REGIONS_FLOOD);
-		
+
 		// Mark new regions with IDs.
 		for (int y = 0; y < h; ++y)
 		{
@@ -1232,41 +1288,39 @@
 				{
 					if (chf.dist[i] < level || srcReg[i] != 0 || chf.areas[i] == RC_NULL_AREA)
 						continue;
-					
 					if (floodRegion(x, y, i, level, regionId, chf, srcReg, srcDist, stack))
 						regionId++;
 				}
 			}
 		}
-		
+
 		ctx->stopTimer(RC_TIMER_BUILD_REGIONS_FLOOD);
-		
 	}
-	
+
 	// Expand current regions until no empty connected cells found.
 	if (expandRegions(expandIters*8, 0, chf, srcReg, srcDist, dstReg, dstDist, stack) != srcReg)
 	{
 		rcSwap(srcReg, dstReg);
 		rcSwap(srcDist, dstDist);
 	}
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_REGIONS_WATERSHED);
-	
+
 	ctx->startTimer(RC_TIMER_BUILD_REGIONS_FILTER);
-	
+
 	// Filter out small regions.
 	chf.maxRegions = regionId;
 	if (!filterSmallRegions(ctx, minRegionArea, mergeRegionArea, chf.maxRegions, chf, srcReg))
 		return false;
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_REGIONS_FILTER);
-		
+
 	// Write the result out.
 	for (int i = 0; i < chf.spanCount; ++i)
 		chf.spans[i].reg = srcReg[i];
-	
+
 	ctx->stopTimer(RC_TIMER_BUILD_REGIONS);
-	
+
 	return true;
 }
 
Index: src/hearthstone-world/AIInterface.cpp
===================================================================
--- src/hearthstone-world/AIInterface.cpp	(revision 1488)
+++ src/hearthstone-world/AIInterface.cpp	(working copy)
@@ -1937,9 +1937,7 @@
 
 	if(pathfinding)
 	{
-		LocationVector PathLocation = NavMeshInterface.getBestPositionOnPathToLocation(m_Unit->GetMapId(),
-			m_sourceX, m_sourceY, m_sourceZ, m_destinationX, m_destinationY, m_destinationZ);
-
+		LocationVector PathLocation = NavMeshInterface.BuildPath(m_Unit->GetMapId(), m_sourceX, m_sourceY, m_sourceZ, m_destinationX, m_destinationY, m_destinationZ);
 		m_nextPosX = PathLocation.x;
 		m_nextPosY = PathLocation.y;
 		m_nextPosZ = PathLocation.z;
Index: src/hearthstone-world/CharacterHandler.cpp
===================================================================
--- src/hearthstone-world/CharacterHandler.cpp	(revision 1488)
+++ src/hearthstone-world/CharacterHandler.cpp	(working copy)
@@ -918,21 +918,23 @@
 	// Login time, will be used for played time calc
 	plr->m_playedtime[2] = (uint32)UNIXTIME;
 
+	// Send revision
+//	plr->BroadcastMessage("%sServer:|r%s Sandshroud Hearthstone|r %s r%u-%s-%s", MSG_COLOR_GOLD,
+//		MSG_COLOR_ORANGEY, MSG_COLOR_TORQUISEBLUE, BUILD_REVISION, ARCH, CONFIG);
+//	plr->BroadcastMessage("%sPlease report all bugs to |r%shttp://mantis.sandshroud.org|r", MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE);
+//	plr->BroadcastMessage("%sOnline Players:|r%s %u |r%sPeak:|r%s %u |r%sAccepted Connections:|r%s %u |r", MSG_COLOR_GOLD,
+//		MSG_COLOR_TORQUISEBLUE, sWorld.GetSessionCount(), MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE,
+//		sWorld.PeakSessionCount, MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE, sWorld.mAcceptedConnections);
+
+//	plr->BroadcastMessage("%sServer Uptime:|r%s %s|r", MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE, sWorld.GetUptimeString().c_str());
+
 	//Issue a message telling all guild members that this player has signed on
 	if(plr->IsInGuild())
 	{
 		Guild *pGuild = plr->m_playerInfo->guild;
 		if(pGuild)
 		{
-			WorldPacket data(SMSG_GUILD_EVENT, 50);
-			data << uint8(GUILD_EVENT_MOTD);
-			data << uint8(0x01);
-			if(pGuild->GetMOTD())
-				data << pGuild->GetMOTD();
-			else
-				data << uint8(0);
-			SendPacket(&data);
-
+			pGuild->LogGuildEventToPlr(plr, GUILD_EVENT_MOTD, 1, pGuild->GetMOTD());
 			pGuild->LogGuildEvent(GUILD_EVENT_HASCOMEONLINE, 1, plr->GetName());
 		}
 	}
@@ -944,16 +946,6 @@
 	// send friend list (for ignores)
 	plr->Social_SendFriendList(7);
 
-	// Send revision
-	plr->BroadcastMessage("%sServer:|r%s Sandshroud Hearthstone|r %s r%u-%s-%s", MSG_COLOR_GOLD,
-		MSG_COLOR_ORANGEY, MSG_COLOR_TORQUISEBLUE, BUILD_REVISION, ARCH, CONFIG);
-	plr->BroadcastMessage("%sPlease report all bugs to |r%shttp://mantis.sandshroud.org|r", MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE);
-	plr->BroadcastMessage("%sOnline Players:|r%s %u |r%sPeak:|r%s %u |r%sAccepted Connections:|r%s %u |r", MSG_COLOR_GOLD,
-		MSG_COLOR_TORQUISEBLUE, sWorld.GetSessionCount(), MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE,
-		sWorld.PeakSessionCount, MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE, sWorld.mAcceptedConnections);
-
-	plr->BroadcastMessage("%sServer Uptime:|r%s %s|r", MSG_COLOR_GOLD, MSG_COLOR_TORQUISEBLUE, sWorld.GetUptimeString().c_str());
-
 	// send to gms
 	if(HasGMPermissions())
 		sWorld.SendMessageToGMs(this, "%s%s %s (%s) is now online.|r", MSG_COLOR_GOLD, CanUseCommand('z') ? "Admin" : "GameMaster", plr->GetName(), GetAccountNameS(), GetPermissions());
Index: src/hearthstone-world/Guild.cpp
===================================================================
--- src/hearthstone-world/Guild.cpp	(revision 1488)
+++ src/hearthstone-world/Guild.cpp	(working copy)
@@ -150,20 +150,43 @@
 	ASSERT(iStringCount <= 4);
 
 	WorldPacket data(SMSG_GUILD_EVENT, 100);
-	uint32 i;
 	data << iEvent;
 	data << iStringCount;
 
-	for(i = 0; i < iStringCount; i++)
+	for(uint32 i = 0; i < iStringCount; i++)
 	{
 		strs[i] = va_arg(ap, char*);
 		data << strs[i];
 	}
 
 	va_end(ap);
-	SendPacket(&data);
 }
 
+void Guild::LogGuildEventToPlr(Player* plr, uint8 iEvent, uint8 iStringCount, ...)
+{
+	if(!m_commandLogging || plr == NULL)
+		return;
+
+	va_list ap;
+	char * strs[4] = {NULL,NULL,NULL,NULL};
+
+	va_start(ap, iStringCount);
+	ASSERT(iStringCount <= 4);
+
+	WorldPacket data(SMSG_GUILD_EVENT, 100);
+	data << iEvent;
+	data << iStringCount;
+
+	for(uint32 i = 0; i < iStringCount; i++)
+	{
+		strs[i] = va_arg(ap, char*);
+		data << strs[i];
+	}
+
+	va_end(ap);
+	plr->GetSession()->SendPacket(&data);
+}
+
 void Guild::AddGuildLogEntry(uint8 iEvent, uint8 iParamCount, ...)
 {
 	if(!m_commandLogging)
@@ -759,10 +782,10 @@
 	else
 		r = (ForcedRank<0) ? FindLowestRank() : m_ranks[ForcedRank];
 
-	if(r== NULL)
-		r=FindLowestRank();
+	if(r == NULL)
+		r = FindLowestRank();
 
-	if(r== NULL)
+	if(r == NULL)
 	{
 		// shouldn't happen
 		m_lock.Release();
@@ -776,14 +799,15 @@
 	pm->szOfficerNote = pm->szPublicNote = NULL;
 	m_members.insert(make_pair(pMember, pm));
 
-	pMember->guild=this;
-	pMember->guildRank=r;
-	pMember->guildMember=pm;
+	pMember->guild = this;
+	pMember->guildRank = r;
+	pMember->guildMember = pm;
 
 	if(pMember->m_loggedInPlayer)
 	{
 		pMember->m_loggedInPlayer->SetGuildId(m_guildId);
 		pMember->m_loggedInPlayer->SetGuildRank(r->iId);
+		LogGuildEventToPlr(pMember->m_loggedInPlayer, GUILD_EVENT_MOTD, 1, GetMOTD());
 	}
 
 	CharacterDatabase.Execute("REPLACE INTO guild_data VALUES(%u, %u, %u, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)", m_guildId, pMember->guid, r->iId);
Index: src/hearthstone-world/Guild.h
===================================================================
--- src/hearthstone-world/Guild.h	(revision 1488)
+++ src/hearthstone-world/Guild.h	(working copy)
@@ -360,6 +360,10 @@
 	 */
 	void LogGuildEvent(uint8 iEvent, uint8 iStringCount, ...);
 
+	/** Logs a guild event and sends it to all online players.
+	 */
+	void LogGuildEventToPlr(Player* plr, uint8 iEvent, uint8 iStringCount, ...);
+
 	/** Guild event logging.
 	 */
 	void AddGuildLogEntry(uint8 iEvent, uint8 iParamCount, ...);
Index: src/hearthstone-world/GuildHandler.cpp
===================================================================
--- src/hearthstone-world/GuildHandler.cpp	(revision 1488)
+++ src/hearthstone-world/GuildHandler.cpp	(working copy)
@@ -109,9 +109,7 @@
 	plyr->UnSetGuildInvitersGuid();
 
 	if(!inviter)
-	{
 		return;
-	}
 
 	Guild *pGuild = inviter->m_playerInfo->guild;
 	if(!pGuild)
Index: src/hearthstone-world/Level3.cpp
===================================================================
--- src/hearthstone-world/Level3.cpp	(revision 1488)
+++ src/hearthstone-world/Level3.cpp	(working copy)
@@ -1877,8 +1877,8 @@
  	BlueSystemMessage(m_session, "%s uses %s (build %u)", (plr->getGender()?"She":"He"),
 		client, sess->GetClientBuild());
 
-	BlueSystemMessage(m_session, "%s IP is '%s', and has a latency of %ums", (plr->getGender()?"Her":"His"),
-		sess->GetSocket()->GetIP(), sess->GetLatency());
+	BlueSystemMessage(m_session, "%s IP is '%s:%u', and has a latency of %ums", (plr->getGender()?"Her":"His"),
+		sess->GetSocket()->GetIP(), sess->GetSocket()->GetPort(), sess->GetLatency());
 
 	return true;
 }
@@ -2809,22 +2809,20 @@
 
 bool ChatHandler::HandleRenameGuildCommand(const char* args, WorldSession *m_session)
 {
-	Player* ptarget = getSelectedChar(m_session);
-
-	if(!*args || !ptarget)
+	Player* plr = getSelectedChar(m_session);
+	if(!plr || !plr->GetGuildId() || !plr->GetGuild() || !args || !strlen(args))
 		return false;
 
-	char* newname = (char*)args;
-
-	Guild* guild = ptarget->GetGuild();
-	if(guild == NULL)
+	Guild* pGuild = objmgr.GetGuildByGuildName(string(args));
+	if(pGuild)
 	{
-		RedSystemMessage(m_session, "Target is not in a guild.");
-		return true;
+		RedSystemMessage(m_session, "Guild name %s is already taken.", args);
+		return false;
 	}
 
-	guild->ChangeGuildName(newname);
-	BlueSystemMessage(ptarget->GetSession(), "The Name of your Guild has been changed to %s, please relog.", newname);
+	GreenSystemMessage(m_session, "Changed guild name of %s to %s. This will take effect next restart.", plr->GetGuild()->GetGuildName(), args);
+	CharacterDatabase.Execute("UPDATE guilds SET `guildName` = \'%s\' WHERE `guildId` = '%u'", CharacterDatabase.EscapeString(string(args)).c_str(), plr->GetGuild()->GetGuildId());
+	sWorld.LogGM(m_session, "Changed guild name of '%s' to '%s'", plr->GetGuild()->GetGuildName(), args);
 	return true;
 }
 
@@ -2832,7 +2830,7 @@
 bool ChatHandler::HandleGuildRemovePlayerCommand(const char* args, WorldSession *m_session)
 {
 	Player* plr = getSelectedChar(m_session);
-	if(!plr || (plr && plr->GetGuild() == NULL))
+	if(plr == NULL || plr->GetGuild() == NULL)
 		return false;
 
 	plr->GetGuild()->RemoveGuildMember(plr->m_playerInfo,m_session);
@@ -2844,7 +2842,7 @@
 bool ChatHandler::HandleGuildDisbandCommand(const char* args, WorldSession *m_session)
 {
 	Player* plr = getSelectedChar(m_session);
-	if(!plr || (plr && (plr->GetGuild() == NULL)))
+	if(plr == NULL || plr->GetGuild() == NULL)
 		return false;
 
 	plr->GetGuild()->Disband();
@@ -2856,7 +2854,7 @@
 bool ChatHandler::HandleGuildMembersCommand(const char* args, WorldSession *m_session)
 {
 	Player* plr = getSelectedChar(m_session);
-	if(!plr || (plr && (plr->GetGuild() == NULL)))
+	if(plr == NULL || plr->GetGuild() == NULL)
 		return false;
 
 	plr->GetGuild()->ListGuildMembers(m_session);
Index: src/hearthstone-world/Map.cpp
===================================================================
--- src/hearthstone-world/Map.cpp	(revision 1488)
+++ src/hearthstone-world/Map.cpp	(working copy)
@@ -51,9 +51,6 @@
 	// collision
 	if (sWorld.Collision && _mapInfo->collision)
 		CollideInterface.ActivateMap(_mapId);
-
-	if(sWorld.PathFinding /*&& _mapInfo->type != INSTANCE_PVP*/)
-		NavMeshInterface.LoadMap(_mapId);
 }
 
 Map::~Map()
Index: src/hearthstone-world/NavMeshInterface.cpp
===================================================================
--- src/hearthstone-world/NavMeshInterface.cpp	(revision 1488)
+++ src/hearthstone-world/NavMeshInterface.cpp	(working copy)
@@ -24,44 +24,79 @@
 void CNavMeshInterface::Init()
 {
 	Log.Notice("NavMeshInterface", "Init");
-	memset( internalX, 0, sizeof(uint32)*NUM_MAPS*64 );
-	memset( internalY, 0, sizeof(uint32)*NUM_MAPS*64 );
-	memset( m_navMesh, 0, sizeof(dtNavMesh*)*NUM_MAPS );
-	memset( m_navMeshLoadCount, 0, sizeof(int64)*NUM_MAPS*64*64 );
+	memset( MMaps, 0, sizeof(MMapManager*)*NUM_MAPS );
 }
 
 void CNavMeshInterface::DeInit()
 {
-	// bleh.
+	for(uint32 i = 0; i < NUM_MAPS; i++)
+		delete MMaps[i];
 }
 
-// CellHandler.h
-uint32 CNavMeshInterface::GetPosX(float x)
+MMapManager* CNavMeshInterface::GetOrCreateMMapManager(uint32 mapid)
 {
-	ASSERT((x >= _minX) && (x <= _maxX));
-	return (uint32)((_maxX-x)/_cellSize);
+	if(MMaps[mapid] != NULL)
+		return MMaps[mapid];
+
+	return (MMaps[mapid] = new MMapManager(mapid));
 }
 
-uint32 CNavMeshInterface::GetPosY(float y)
+bool CNavMeshInterface::IsNavmeshLoaded(uint32 mapid, uint32 x, uint32 y)
 {
-	ASSERT((y >= _minY) && (y <= _maxY));
-	return (uint32)((_maxY-y)/_cellSize);
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	return mmap->IsNavmeshLoaded(x, y);
 }
 
-void CNavMeshInterface::LoadMap(uint32 mapid)
+bool CNavMeshInterface::LoadNavMesh(uint32 mapid, uint32 x, uint32 y)
 {
-	if(m_navMesh[mapid] != NULL)
-		return;
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	return mmap->LoadNavMesh(x, y);
+}
 
+void CNavMeshInterface::UnloadNavMesh(uint32 mapid, uint32 x, uint32 y)
+{
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	mmap->UnloadNavMesh(x, y);
+}
+
+bool CNavMeshInterface::BuildPath(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out)
+{
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	return mmap->getNextPositionOnPathToLocation(startx, starty, startz, endx, endy, endz, out);
+}
+
+LocationVector CNavMeshInterface::BuildPath(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, bool best)
+{
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	if(best)
+		return mmap->getBestPositionOnPathToLocation(startx, starty, startz, endx, endy, endz);
+	return mmap->getNextPositionOnPathToLocation(startx, starty, startz, endx, endy, endz);
+}
+
+float CNavMeshInterface::GetWalkingHeight(uint32 mapid, float x, float y, float z, float z2)
+{
+	LocationVector Step;
+	float height = MMAP_UNAVAILABLE;
+	MMapManager* mmap = GetOrCreateMMapManager(mapid);
+	if(mmap->GetWalkingHeightInternal(x, y, z, z2, Step))
+		height = Step.z;
+	return height;
+}
+
+MMapManager::MMapManager(uint32 mapid)
+{
+	lastTileRef = 0;
+	ManagerMapId = mapid;
+
 	// load and init dtNavMesh - read parameters from file
 	uint32 pathLen = uint32(sWorld.MMapPath.length() + strlen("/000.mmap")+1);
 	char *fileName = new char[pathLen];
-	snprintf(fileName, pathLen, (sWorld.MMapPath+"/%03i.mmap").c_str(), mapid);
+	snprintf(fileName, pathLen, (sWorld.MMapPath+"/%03i.mmap").c_str(), ManagerMapId);
 
 	FILE* file = fopen(fileName, "rb");
 	if (!file)
 	{
-		Log.Notice("NavMeshInterface", "Could not load mmap %03i", mapid);
+		Log.Notice("NavMeshInterface", "Could not load mmap %03i", ManagerMapId);
 		delete [] fileName;
 		return;
 	}
@@ -75,51 +110,75 @@
 	if(mesh->init(&params) != DT_SUCCESS)
 	{
 		freeNavMesh(mesh);
-		Log.Error("NavMeshInterface", "Failed to initialize dtNavMesh for mmap %03u from file %s", mapid, fileName);
+		Log.Error("NavMeshInterface", "Failed to initialize dtNavMesh for mmap %03u from file %s", ManagerMapId, fileName);
 		delete [] fileName;
 		return;
 	}
 
 	delete [] fileName;
 
-	Log.Debug("NavMeshInterface", "Loaded %03i.mmap", mapid);
+	Log.Debug("NavMeshInterface", "Loaded %03i.mmap", ManagerMapId);
 
 	// store inside our map list
-	m_navMesh[mapid] = mesh;
+	m_navMesh = mesh;
 }
 
-dtNavMesh* CNavMeshInterface::GetNavmesh(uint32 mapid)
+MMapManager::~MMapManager()
 {
-	return m_navMesh[mapid];
+	delete m_navMesh;
 }
 
-bool CNavMeshInterface::IsNavmeshLoadedAtPosition(uint32 mapid, float x, float y)
+float MMapManager::calcAngle( float Position1X, float Position1Y, float Position2X, float Position2Y )
 {
-	int tileX = GetPosX(x)/8;
-	int tileY = GetPosY(y)/8;
-	return IsNavmeshLoaded(mapid, tileX, tileY);
-}
+	float dx = Position2X-Position1X;
+	float dy = Position2Y-Position1Y;
+	double angle = 0.0f;
 
-bool CNavMeshInterface::IsNavmeshLoaded(uint32 mapid, uint32 x, uint32 y)
-{
-	if(!internalX[mapid][x] && !internalY[mapid][y])
-		return false;
-	return (m_navMeshLoadCount[mapid][internalX[mapid][x]][internalY[mapid][y]] > 0 ? true : false);
+	// Calculate angle
+	if (dx == 0.0)
+	{
+		if (dy == 0.0)
+			angle = 0.0;
+		else if (dy > 0.0)
+			angle = M_PI * 0.5 /* / 2 */;
+		else
+			angle = M_PI * 3.0 * 0.5/* / 2 */;
+	}
+	else if (dy == 0.0)
+	{
+		if (dx > 0.0)
+			angle = 0.0;
+		else
+			angle = M_PI;
+	}
+	else
+	{
+		if (dx < 0.0)
+			angle = atanf(dy/dx) + M_PI;
+		else if (dy < 0.0)
+			angle = atanf(dy/dx) + (2*M_PI);
+		else
+			angle = atanf(dy/dx);
+	}
+
+	// Convert to degrees
+	angle = angle * float(180 / M_PI);
+
+	// Return
+	return float(angle);
 }
 
-bool CNavMeshInterface::LoadNavMesh(uint32 mapid, uint32 x, uint32 y)
+bool MMapManager::LoadNavMesh(uint32 x, uint32 y)
 {
-	if(m_navMesh[mapid] == NULL)
-		return false;
-
-	if(!IsNavmeshLoaded(mapid, x, y))
+	uint32 PackedTileID = packTileID(x, y);
+	if(!IsNavmeshLoaded(x, y))
 	{
-		ASSERT(m_navMesh[mapid]);
+		ASSERT(m_navMesh);
 
 		// load this tile :: mmaps/MMMXXYY.mmtile
 		uint32 pathLen = uint32(sWorld.MMapPath.length() + strlen("/0000000.mmtile")+1);
 		char *fileName = new char[pathLen];
-		snprintf(fileName, pathLen, (sWorld.MMapPath+"/%03i%02i%02i.mmtile").c_str(), mapid, x, y);
+		snprintf(fileName, pathLen, (sWorld.MMapPath+"/%03i%02i%02i.mmtile").c_str(), ManagerMapId, x, y);
 		FILE *file = fopen(fileName, "rb");
 		if (!file)
 		{
@@ -134,14 +193,14 @@
 		fread(&fileHeader, sizeof(MmapTileHeader), 1, file);
 		if (fileHeader.mmapMagic != MMAP_MAGIC)
 		{
-			Log.Error("NavMeshInterface", "Bad header in mmap %03u%02i%02i.mmtile", mapid, x, y);
+			Log.Error("NavMeshInterface", "Bad header in mmap %03u%02i%02i.mmtile", ManagerMapId, x, y);
 			fclose(file);
 			return false;
 		}
 
 		if (fileHeader.mmapVersion != MMAP_VERSION)
 		{
-			Log.Error("NavMeshInterface", "%03u%02i%02i.mmtile was built with generator v%i, expected v%i", mapid, x, y, fileHeader.mmapVersion, MMAP_VERSION);
+			Log.Error("NavMeshInterface", "%03u%02i%02i.mmtile was built with generator v%i, expected v%i", ManagerMapId, x, y, fileHeader.mmapVersion, MMAP_VERSION);
 			fclose(file);
 			return false;
 		}
@@ -152,93 +211,71 @@
 		size_t result = fread(data, fileHeader.size, 1, file);
 		if(!result)
 		{
-			Log.Error("NavMeshInterface", "Bad header or data in mmap %03u%02i%02i.mmtile", mapid, x, y);
+			Log.Error("NavMeshInterface", "Bad header or data in mmap %03u%02u%02u.mmtile", ManagerMapId, x, y);
 			fclose(file);
 			return false;
 		}
 		fclose(file);
 
 		dtStatus dtresult;
+		dtTileRef thistileref;
 		dtMeshHeader* header = (dtMeshHeader*)data;
 
 		// memory allocated for data is now managed by detour, and will be deallocated when the tile is removed
-		dtresult = m_navMesh[mapid]->addTile(data, fileHeader.size, DT_TILE_FREE_DATA, 0, 0);
-		if(dtresult == DT_IN_PROGRESS)
-		{	// We already have it loaded, oops.
-			internalX[mapid][x] = header->x;
-			internalY[mapid][y] = header->y;
+		dtresult = m_navMesh->addTile(data, fileHeader.size, DT_TILE_FREE_DATA, lastTileRef, &thistileref);
+		if(dtresult & DT_IN_PROGRESS) // We already have it loaded, oops.
 			free(data);
-		}
-		else if(dtresult != DT_SUCCESS)
+		else if(dtresult & DT_FAILURE)
 		{
 			free(data);
-			Log.Error("NavMeshInterface", "Could not load %03u%02i%02i.mmtile into navmesh", mapid, x, y);
+			Log.Error("NavMeshInterface", "Could not load %03u%02u%02u.mmtile into navmesh", ManagerMapId, x, y);
 			return false;
 		}
-		else
-		{
-			internalX[mapid][x] = header->x;
-			internalY[mapid][y] = header->y;
-			Log.Debug("NavMeshInterface", "Loaded mmtile %03i[%02i,%02i] into %03i[%02i,%02i]", mapid, x, y, mapid, internalX[mapid][x], internalY[mapid][y]);
-		}
+		else Log.Debug("NavMeshInterface", "Loaded mmtile %03u[%04u] into %03u[%02u,%02u]", ManagerMapId, thistileref, ManagerMapId, x, y);
+
+		TileReferences.insert(make_pair(PackedTileID, thistileref));
 	}
 
-	m_navMeshLoadCount[mapid][internalX[mapid][x]][internalY[mapid][y]]++;
+	TileLoadCount[PackedTileID]++;
 	return true;
 }
 
-void CNavMeshInterface::UnloadNavMesh(uint32 mapid, uint32 x, uint32 y)
+void MMapManager::UnloadNavMesh(uint32 x, uint32 y)
 {
-	if(m_navMeshLoadCount[mapid][internalX[mapid][x]][internalY[mapid][y]] == 1)
+	uint32 PackedTileID = packTileID(x, y);
+	if(TileLoadCount[PackedTileID] == 1)
 	{
-		if(m_navMesh[mapid]->removeTile(m_navMesh[mapid]->getTileRefAt(internalX[mapid][x], internalY[mapid][y]), NULL, NULL) != DT_SUCCESS)
+		dtTileRef Reference = TileReferences.at(PackedTileID);
+		dtStatus status = m_navMesh->removeTile(Reference, NULL, NULL);
+		if(status & DT_FAILURE)
 		{
-			Log.Error("NavMeshInterface", "Failed to unload mmtile %03i[%02i,%02i] from %03i[%02i,%02i]", mapid, internalX[mapid][x], internalY[mapid][y], mapid, x, y);
+			if(status & DT_INVALID_PARAM)
+				Log.Error("NavMeshInterface", "Invalid reference for mmtile %03u[%04u] from %03u[%02u,%02u]", ManagerMapId, Reference, ManagerMapId, x, y);
+			else
+				Log.Error("NavMeshInterface", "Failed to unload mmtile %03u[%04u] from %03u[%02u,%02u]", ManagerMapId, Reference, ManagerMapId, x, y);
 			return;
 		}
-		Log.Debug("NavMeshInterface", "Unloaded mmtile %03i[%02i,%02i] from %03i[%02i,%02i]", mapid, internalX[mapid][x], internalY[mapid][y], mapid, x, y);
+		Log.Debug("NavMeshInterface", "Unloaded mmtile %03u[%04i] from %03u[%02u,%02u]", ManagerMapId, Reference, ManagerMapId, x, y);
 	}
 
-	m_navMeshLoadCount[mapid][internalX[mapid][x]][internalY[mapid][y]]--;
+	TileLoadCount[PackedTileID]--;
 }
 
-LocationVector CNavMeshInterface::getBestPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz)
+bool MMapManager::IsNavmeshLoaded(uint32 x, uint32 y)
 {
-	LocationVector pos(startx, starty, startz);
-	LocationVector nextpos(startx, starty, startz);
-	LocationVector returnpos(endx, endy, endz);
-	pos = getNextPositionOnPathToLocation(mapid, startx, starty, startz, endx, endy, endz);
-	float line = calcAngle(startx, starty, pos.x, pos.y);
-	while(1)
-	{
-		nextpos = getNextPositionOnPathToLocation(mapid, pos.x, pos.y, pos.z, endx, endy, endz);
-		float angle = calcAngle( startx, starty, nextpos.x, nextpos.y );
-		if(angle != line)
-		{	// We have to turn, so stop our line here.
-			returnpos = pos;
-			break;
-		}
-		if(pos.x == nextpos.x || pos.y == nextpos.y)
-		{
-			returnpos = pos;
-			break;
-		}
-
-		pos = nextpos;
-	}
-	return returnpos;
+	return (TileLoadCount[packTileID(x, y)] > 0 ? true : false);
 }
 
-LocationVector CNavMeshInterface::getNextPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz)
+LocationVector MMapManager::getNextPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz)
 {
-	if(m_navMesh[mapid] == NULL)
+	if(m_navMesh == NULL)
 		return LocationVector(endx, endy, endz);
 
 	dtNavMeshQuery* query = mallocNavMeshQuery();
-	if(query->init(m_navMesh[mapid], 1024) != DT_SUCCESS)
+	if(query->init(m_navMesh, 1024) != DT_SUCCESS)
 	{
 		freeNavMeshQuery(query);
-		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", mapid);
+		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", ManagerMapId);
 		return LocationVector(endx, endy, endz);
 	}
 
@@ -314,16 +351,16 @@
 	return pos;
 }
 
-bool CNavMeshInterface::getNextPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out)
+bool MMapManager::getNextPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out)
 {
-	if(m_navMesh[mapid] == NULL)
+	if(m_navMesh == NULL)
 		return false;
 
 	dtNavMeshQuery* query = mallocNavMeshQuery();
-	if(query->init(m_navMesh[mapid], 1024) != DT_SUCCESS)
+	if(query->init(m_navMesh, 1024) != DT_SUCCESS)
 	{
 		freeNavMeshQuery(query);
-		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", mapid);
+		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", ManagerMapId);
 		return false;
 	}
 
@@ -395,16 +432,43 @@
 	return false;
 }
 
-bool CNavMeshInterface::GetWalkingHeightInternal(uint32 mapid, float positionx, float positiony, float positionz, float endz, LocationVector& out)
+LocationVector MMapManager::getBestPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz)
 {
-	if(m_navMesh[mapid] == NULL)
+	LocationVector pos(startx, starty, startz);
+	LocationVector nextpos(startx, starty, startz);
+	LocationVector returnpos(endx, endy, endz);
+	pos = getNextPositionOnPathToLocation(startx, starty, startz, endx, endy, endz);
+	float line = calcAngle(startx, starty, pos.x, pos.y);
+	while(1)
+	{
+		nextpos = getNextPositionOnPathToLocation(pos.x, pos.y, pos.z, endx, endy, endz);
+		float angle = calcAngle( startx, starty, nextpos.x, nextpos.y );
+		if(angle != line)
+		{	// We have to turn, so stop our line here.
+			returnpos = pos;
+			break;
+		}
+		if(pos.x == nextpos.x || pos.y == nextpos.y)
+		{
+			returnpos = pos;
+			break;
+		}
+
+		pos = nextpos;
+	}
+	return returnpos;
+}
+
+bool MMapManager::GetWalkingHeightInternal(float positionx, float positiony, float positionz, float endz, LocationVector& out)
+{
+	if(m_navMesh == NULL)
 		return false;
 
 	dtNavMeshQuery* query = mallocNavMeshQuery();
-	if(query->init(m_navMesh[mapid], 1024) != DT_SUCCESS)
+	if(query->init(m_navMesh, 1024) != DT_SUCCESS)
 	{
 		freeNavMeshQuery(query);
-		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", mapid);
+		Log.Error("NavMeshInterface", "Failed to initialize dtNavMeshQuery for mapId %03u", ManagerMapId);
 		return false;
 	}
 
@@ -485,52 +549,3 @@
 	}
 	return false;
 }
-
-float CNavMeshInterface::GetWalkingHeight(uint32 mapid, float x, float y, float z, float z2)
-{
-	float height = MMAP_UNAVAILABLE;
-	LocationVector Step;
-	if(GetWalkingHeightInternal(mapid, x, y, z, z2, Step))
-		height = Step.z;
-	return height;
-}
-
-float CNavMeshInterface::calcAngle( float Position1X, float Position1Y, float Position2X, float Position2Y )
-{
-	float dx = Position2X-Position1X;
-	float dy = Position2Y-Position1Y;
-	double angle=0.0f;
-
-	// Calculate angle
-	if (dx == 0.0)
-	{
-		if (dy == 0.0)
-			angle = 0.0;
-		else if (dy > 0.0)
-			angle = M_PI * 0.5 /* / 2 */;
-		else
-			angle = M_PI * 3.0 * 0.5/* / 2 */;
-	}
-	else if (dy == 0.0)
-	{
-		if (dx > 0.0)
-			angle = 0.0;
-		else
-			angle = M_PI;
-	}
-	else
-	{
-		if (dx < 0.0)
-			angle = atanf(dy/dx) + M_PI;
-		else if (dy < 0.0)
-			angle = atanf(dy/dx) + (2*M_PI);
-		else
-			angle = atanf(dy/dx);
-	}
-
-	// Convert to degrees
-	angle = angle * float(180 / M_PI);
-
-	// Return
-	return float(angle);
-}
Index: src/hearthstone-world/NavMeshInterface.h
===================================================================
--- src/hearthstone-world/NavMeshInterface.h	(revision 1488)
+++ src/hearthstone-world/NavMeshInterface.h	(working copy)
@@ -36,36 +36,86 @@
 		mmapVersion(MMAP_VERSION), size(0), usesLiquids(true) {}
 };
 
-// Crow: TODO: Integrate Cell Handler royalties.
+typedef map<uint32, dtTileRef> ReferenceMap;
+typedef map<dtTileRef, uint32> ReverseReferenceMap;
+
+class MMapManager
+{
+	uint32 GetPosX(float x)
+	{
+		ASSERT((x >= _minX) && (x <= _maxX));
+		return (uint32)((_maxX-x)/_cellSize);
+	};
+
+	uint32 GetPosY(float y)
+	{
+		ASSERT((y >= _minY) && (y <= _maxY));
+		return (uint32)((_maxY-y)/_cellSize);
+	};
+public:
+	MMapManager(uint32 mapid);
+	~MMapManager();
+
+private:
+	uint32 ManagerMapId;
+	dtNavMesh* m_navMesh;
+	dtTileRef lastTileRef;
+	ReferenceMap TileReferences;
+	ReverseReferenceMap TileLoadCount;
+	uint32 packTileID(int32 x, int32 y) { return uint32(x << 16 | y); };
+	float calcAngle( float Position1X, float Position1Y, float Position2X, float Position2Y );
+
+public:
+	bool LoadNavMesh(uint32 x, uint32 y);
+	void UnloadNavMesh(uint32 x, uint32 y);
+	bool IsNavmeshLoaded(uint32 x, uint32 y);
+
+	LocationVector getNextPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz);
+	LocationVector getBestPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz);
+
+	bool GetWalkingHeightInternal(float startx, float starty, float startz, float endz, LocationVector& out);
+	bool getNextPositionOnPathToLocation(float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out);
+};
+
 class SERVER_DECL CNavMeshInterface
 {
 public:
 	void Init();
 	void DeInit();
-	void LoadMap(uint32 mapid);
+	MMapManager* GetOrCreateMMapManager(uint32 mapid);
 
 public: // Navmesh settings
-	uint32 GetPosX(float x);
-	uint32 GetPosY(float y);
-	dtNavMesh* GetNavmesh(uint32 mapid);
 	bool LoadNavMesh(uint32 mapid, uint32 x, uint32 y);
+	void UnloadNavMesh(uint32 mapid, uint32 x, uint32 y);
 	bool IsNavmeshLoaded(uint32 mapid, uint32 x, uint32 y);
-	bool IsNavmeshLoadedAtPosition(uint32 mapid, float x, float y);
-	void UnloadNavMesh(uint32 mapid, uint32 x, uint32 y);
+	bool IsNavmeshLoadedAtPosition(uint32 mapid, float x, float y) { return IsNavmeshLoaded(mapid, (GetPosX(x)/8), (GetPosY(y)/8)); };
 
-	LocationVector getBestPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz);
-	LocationVector getNextPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz);
-	bool getNextPositionOnPathToLocation(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out);
-	bool GetWalkingHeightInternal(uint32 mapid, float startx, float starty, float startz, float endz, LocationVector& out);
 	float GetWalkingHeight(uint32 mapid, float positionx, float positiony, float positionz, float positionz2);
+	bool BuildPath(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, LocationVector& out);
+	LocationVector BuildPath(uint32 mapid, float startx, float starty, float startz, float endx, float endy, float endz, bool best = false);
 
 private:
-	float calcAngle( float Position1X, float Position1Y, float Position2X, float Position2Y );
+	uint32 GetPosX(float x)
+	{
+		ASSERT((x >= _minX) && (x <= _maxX));
+		return (uint32)((_maxX-x)/_cellSize);
+	};
 
-	dtNavMesh* m_navMesh[NUM_MAPS];
-	uint32 internalX[NUM_MAPS][64];
-	uint32 internalY[NUM_MAPS][64];
-	int64 m_navMeshLoadCount[NUM_MAPS][64][64];
+	uint32 GetPosY(float y)
+	{
+		ASSERT((y >= _minY) && (y <= _maxY));
+		return (uint32)((_maxY-y)/_cellSize);
+	};
+
+	MMapManager* GetMMap(uint32 mapid)
+	{
+		MMapManager* mmapreturn = NULL;
+		if(mapid < NUM_MAPS)
+			mmapreturn = MMaps[mapid];
+		return mmapreturn;
+	};
+
+	MMapManager* MMaps[NUM_MAPS];
 };
 
 extern SERVER_DECL CNavMeshInterface NavMeshInterface;
Index: win/VC100/hearthstone-shared.vcxproj
===================================================================
--- win/VC100/hearthstone-shared.vcxproj	(revision 1488)
+++ win/VC100/hearthstone-shared.vcxproj	(working copy)
@@ -276,11 +276,11 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp" />
-    <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastArea.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastContour.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp" />
+    <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastLayers.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMeshDetail.cpp" />
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRasterization.cpp" />
@@ -375,7 +375,7 @@
     <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h" />
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.h" />
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourStatus.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\PerfCounters.h" />
     <ClInclude Include="..\..\src\hearthstone-shared\Threading\Condition.h" />
Index: win/VC100/hearthstone-shared.vcxproj.filters
===================================================================
--- win/VC100/hearthstone-shared.vcxproj.filters	(revision 1488)
+++ win/VC100/hearthstone-shared.vcxproj.filters	(working copy)
@@ -264,6 +264,18 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Network\SocketEngine_iocp.cpp">
       <Filter>Network\Engines\Win</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\DBC.cpp">
+      <Filter>Database\DataStores</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\dbcfile.cpp">
+      <Filter>Database\DataStores</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\DBCStores.cpp">
+      <Filter>Database\DataStores</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\Database.cpp">
+      <Filter>Database</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.cpp">
       <Filter>Util\Pathfinding\Detour</Filter>
     </ClCompile>
@@ -279,9 +291,6 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.cpp">
       <Filter>Util\Pathfinding\Detour</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.cpp">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.cpp">
       <Filter>Util\Pathfinding\Recast</Filter>
     </ClCompile>
@@ -294,6 +303,9 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastFilter.cpp">
       <Filter>Util\Pathfinding\Recast</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastLayers.cpp">
+      <Filter>Util\Pathfinding\Recast</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastMesh.cpp">
       <Filter>Util\Pathfinding\Recast</Filter>
     </ClCompile>
@@ -306,18 +318,6 @@
     <ClCompile Include="..\..\src\hearthstone-shared\Pathfinding\Recast\RecastRegion.cpp">
       <Filter>Util\Pathfinding\Recast</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\DBC.cpp">
-      <Filter>Database\DataStores</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\dbcfile.cpp">
-      <Filter>Database\DataStores</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\DBC\DBCStores.cpp">
-      <Filter>Database\DataStores</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\src\hearthstone-shared\DataStorage\Database.cpp">
-      <Filter>Database</Filter>
-    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\src\hearthstone-shared\Config\Config.h">
@@ -666,27 +666,6 @@
     <ClInclude Include="..\..\src\hearthstone-shared\Network\SocketEngine_iocp.h">
       <Filter>Network\Engines\Win</Filter>
     </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourObstacleAvoidance.h">
-      <Filter>Util\Pathfinding\Detour</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h">
-      <Filter>Util\Pathfinding\Recast</Filter>
-    </ClInclude>
     <ClInclude Include="..\..\src\hearthstone-shared\ByteConverter.h">
       <Filter>Util</Filter>
     </ClInclude>
@@ -711,5 +690,26 @@
     <ClInclude Include="..\..\src\hearthstone-shared\DataStorage\Field.h">
       <Filter>Database</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourCommon.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMesh.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshBuilder.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNavMeshQuery.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourNode.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Detour\DetourStatus.h">
+      <Filter>Util\Pathfinding\Detour</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\hearthstone-shared\Pathfinding\Recast\Recast.h">
+      <Filter>Util\Pathfinding\Recast</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ No newline at end of file
